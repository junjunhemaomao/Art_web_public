import{_ as o,o as t,c as a,a6 as r}from"./chunks/framework.BB0md0jN.js";const h=JSON.parse('{"title":"Python游戏设计案例实战","description":"","frontmatter":{"layout":"doc","title":"Python游戏设计案例实战","readingTime":"10 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/计算机/Python游戏设计案例实战.md","filePath":"电影和阅读/微信读书/计算机/Python游戏设计案例实战.md"}'),l={name:"电影和阅读/微信读书/计算机/Python游戏设计案例实战.md"};function c(p,e,n,u,i,s){return t(),a("div",null,[...e[0]||(e[0]=[r('<h1 id="python游戏设计案例实战" tabindex="-1">Python游戏设计案例实战 <a class="header-anchor" href="#python游戏设计案例实战" aria-label="Permalink to &quot;Python游戏设计案例实战&quot;">​</a></h1><p><img src="https://cdn.weread.qq.com/weread/cover/2/YueWen_30393200/t6_YueWen_30393200.jpg" alt=" Python游戏设计案例实战"></p><ul><li><strong>书名</strong>： Python游戏设计案例实战</li><li><strong>作者</strong>： 夏敏捷 尚展垒</li><li><strong>简介</strong>： 本书以Python 3.5为编程环境，从基本的程序设计思想入手，逐步展开Python语言教学，是一本面向广大编程学习者的程序设计类教材。基础篇主要讲解Python的基础语法知识、控制语句、函数、文件、面向对象编程基础、Tkinter图形界面设计、网络编程和多线程、Python数据库应用等内容，并以小游戏案例作为各章的阶段性任务。实战篇和提高篇综合应用前面章节中介绍的技术，重现各个经典游戏的开发过程。本书以游戏开发案例为导向，通俗易懂，图文并茂。 本书适合作为高等院校计算机等相关专业的教材，还可作为Python语言学习者、程序设计人员和游戏编程爱好者的参考书。</li><li><strong>出版时间</strong>： 2019-11-01 00:00:00</li><li><strong>ISBN</strong>： 9787115503190</li><li><strong>分类</strong>： 计算机-编程设计</li><li><strong>出版社</strong>： 人民邮电出版社</li><li><strong>PC地址</strong>： <a href="https://weread.qq.com/web/reader/f2332e5071cfc370f232290" target="_blank" rel="noreferrer">https://weread.qq.com/web/reader/f2332e5071cfc370f232290</a></li></ul><h4 id="_2-2-程序设计的思路" tabindex="-1">2.2 程序设计的思路 <a class="header-anchor" href="#_2-2-程序设计的思路" aria-label="Permalink to &quot;2.2 程序设计的思路&quot;">​</a></h4><blockquote><p>📌 random.choice()可以从序列中随机选取元素。 ⏱ 2022-06-07 08:46:48</p></blockquote><h4 id="_2-3-random模块" tabindex="-1">2.3 random模块 <a class="header-anchor" href="#_2-3-random模块" aria-label="Permalink to &quot;2.3 random模块&quot;">​</a></h4><blockquote><p>📌 random.choice可从序列中获取一个随机元素。其函数原型为：random.choice（sequence），参数sequence表示一个有序类型。 ⏱ 2022-06-07 08:50:48</p></blockquote><blockquote><p>📌 泛指序列数据结构。列表（list）、元组（tuple）字符串都属于sequence。 ⏱ 2022-06-07 08:51:06</p></blockquote><blockquote><p>📌 random.shuffle(x[, random])用于将一个列表中的元素的顺序打乱。 ⏱ 2022-06-07 08:52:13</p></blockquote><h3 id="第3章-面向对象设计应用——发牌游戏" tabindex="-1">第3章 面向对象设计应用——发牌游戏 <a class="header-anchor" href="#第3章-面向对象设计应用——发牌游戏" aria-label="Permalink to &quot;第3章 面向对象设计应用——发牌游戏&quot;">​</a></h3><blockquote><p>📌 面向对象程序设计的一个关键性的理念是将数据以及对数据的操作封装在一起，组成一个相互依存、不可分割的整体，即对象。 ⏱ 2021-09-28 20:09:43</p></blockquote><h4 id="_3-2-python面向对象设计" tabindex="-1">3.2 Python面向对象设计 <a class="header-anchor" href="#_3-2-python面向对象设计" aria-label="Permalink to &quot;3.2 Python面向对象设计&quot;">​</a></h4><blockquote><p>📌 最后把它们组装起来。这些部件通过事先设计好的接口连接，以便协调地工作。 ⏱ 2021-09-28 20:10:48</p></blockquote><blockquote><p>📌 如果未定义构造函数，Python将提供一个默认的构造函数。 ⏱ 2021-09-28 20:17:43</p></blockquote><blockquote><p>📌 Python中类的析构函数是__del__，用来释放对象占用的资源，在Python收回对象空间之前自动执行。如果用户未定义析构函数，则Python会提供一个默认的析构函数进行必要的清理工作。 ⏱ 2021-09-28 20:20:19</p></blockquote><blockquote><p>📌 实例属性是在构造函数__init__（以两个下画线“_”开头和结束）中定义的， ⏱ 2021-09-28 20:26:08</p></blockquote><blockquote><p>📌 实例属性属于实例（对象）只能通过对象名访问； ⏱ 2021-09-28 20:27:23</p></blockquote><blockquote><p>📌 如果属性名以两个下画线“_”开头，则表示其是私有属性，否则是公有属性。私有属性在类的外部不能直接访问，需要通过调用对象的公有成员方法来访问， ⏱ 2021-09-28 20:58:40</p></blockquote><blockquote><p>📌 私有属性是为了数据封装和保密而设置的属性，一般只能在类的成员方法（类的内部）中使用访问。 ⏱ 2021-09-28 20:59:23</p></blockquote><blockquote><p>📌 公有方法通过对象名直接调用，私有方法不能通过对象名直接调用，只能在属于对象的方法中通过“self”调用或在外部通过Python支持的特殊方式来调用。 ⏱ 2021-09-28 21:03:01</p></blockquote><blockquote><p>📌 派生类可以继承父类的公有成员，但是不能继承其私有成员。 ⏱ 2021-09-29 01:57:34</p></blockquote><blockquote><p>📌 在继承中，基类的构造函数（<strong>init</strong>()方法）不会被自动调用，它需要在其派生类的构造中专门调用。 ⏱ 2021-09-29 01:58:00</p></blockquote><blockquote><p>📌 当我们定义一个类的时候，实际上就定义了一种数据类型。这种定义的数据类型与Python自带的数据类型，如string、list、dict没有区别。 ⏱ 2021-09-29 02:00:17</p></blockquote><h4 id="_8-2-程序设计的思路" tabindex="-1">8.2 程序设计的思路 <a class="header-anchor" href="#_8-2-程序设计的思路" aria-label="Permalink to &quot;8.2 程序设计的思路&quot;">​</a></h4><blockquote><p>📌 根据玩家用鼠标单击的拼块和空白块所在位置 ⏱ 2022-05-14 20:39:46</p></blockquote><h4 id="_8-3-python图像处理" tabindex="-1">8.3 Python图像处理 <a class="header-anchor" href="#_8-3-python图像处理" aria-label="Permalink to &quot;8.3 Python图像处理&quot;">​</a></h4><blockquote><p>📌 ImageDraw模块为image对象提供了基本的图形处理功能，例如，它可以为图像添加几何图形。 ⏱ 2022-05-14 20:50:55</p></blockquote><blockquote><p>📌 ImageEnhance模块包括一些用于图像增强的类。它们分别为Color类、Brightness类、Contrast类和Sharpness类。 ⏱ 2022-05-14 22:13:35</p></blockquote><blockquote><p>📌 ImageFile模块 ImageFile模块为图像打开和保存功能提供了支持。 ⏱ 2022-05-14 22:18:00</p></blockquote><h4 id="_19-1-pygame基础知识" tabindex="-1">19.1 Pygame基础知识 <a class="header-anchor" href="#_19-1-pygame基础知识" aria-label="Permalink to &quot;19.1 Pygame基础知识&quot;">​</a></h4><blockquote><p>📌 pygame.display是显示模块，pygame.keyboard是键盘模块，pygame.mouse是鼠标模块 ⏱ 2020-08-12 23:59:30</p></blockquote><blockquote><p>📌 pygame.sprite模块有两个非常重要的类：sprite精灵类和group精灵组。 sprite精灵类是所有可视游戏的基类。为了实现游戏对象，需要先子类化sprite，覆盖它的构造函数以设定imge和rect属性（决定sprite的外观和放置的位置），再覆盖update()方法。在sprite需要更新的时候可以调用update()方法。 group精灵组的实例用作精灵sprite对象的容器。在一些简单的游戏中，只要创建名为sprites、allsprite或其他类似的组，然后将所有sprite精灵对象添加到上面即可。group精灵组对象的update()方法被调用时，就会自动调用所有sprite精灵对象的update()方法。group精灵组对象的clear()方法可用于清理它包含的所有sprite对象（使用回调函数实现清理），group精灵组对象draw()方法可用于绘制所有的sprite对象。 ⏱ 2023-08-02 23:50:20</p></blockquote><blockquote><p>📌 8. pygame.image 该模块用于处理保存的GIF、PNG或者JPEG格式的图形，可用load()函数来读取图像文件。 ⏱ 2023-08-02 23:54:24</p></blockquote><h4 id="_19-2-pygame的使用" tabindex="-1">19.2 Pygame的使用 <a class="header-anchor" href="#_19-2-pygame的使用" aria-label="Permalink to &quot;19.2 Pygame的使用&quot;">​</a></h4><blockquote><p>📌 会花费较长的时间。如果只使用少量模块，则应该分别初始化这些模块以节省时间，如pygame.sound.init()仅仅初始化声音模块。 ⏱ 2023-08-03 00:02:30</p></blockquote><blockquote><p>📌 事实上，游戏屏幕也只是一个surface，pygame.display.set_mode()仅仅返回了一个屏幕surface对象。 ⏱ 2023-08-03 00:07:46</p></blockquote><blockquote><p>📌 对于任何一个surface对象，我们可以使用get_width()、get_height()和gei_size()函数来获取它的尺寸，使用get_rect()获取它的区域形状。 ⏱ 2023-08-03 00:09:17</p></blockquote><blockquote><p>📌 在无限循环中写入fpsClock.tick（50），就可以按指定帧频50Hz更新游戏画面（即每秒钟刷新50次屏幕）。 ⏱ 2023-08-03 00:48:01</p></blockquote><blockquote><p>📌 pygame.draw中函数的第一个参数总是一个surface，然后是颜色，最后是一系列的坐标等。 ⏱ 2023-08-03 00:50:03</p></blockquote><blockquote><p>📌 函数返回值是一个Rect对象，包含了绘制的区域，这样就可以很方便地更新需要更新的部分 ⏱ 2023-08-03 00:50:22</p></blockquote><blockquote><p>📌 pygame.draw.rect 格式：pygame.draw.rect（Surface, color, Rect, width=0） pygame.draw.rect在surface上绘制一个矩形，除了surface和color，该函数还接收一个矩形的坐标和线宽参数，如果线宽是0或省略，则填充 ⏱ 2023-08-03 00:51:58</p></blockquote><blockquote><p>📌 格式：pygame.draw.ellipse（Surface, color, Rect, width=0） pygame.draw.ellipse用于绘制椭圆，该函数的第三个参数就是这个椭圆的外接矩形。 ⏱ 2023-08-03 00:57:04</p></blockquote><blockquote><p>📌 事件随时可能发生，而且量也可能会很大，Pygame的做法是把一系列的事件存放一个队列中，逐个进行处理。 ⏱ 2023-08-03 01:00:30</p></blockquote><blockquote><p>📌 使用了pygame.event.get()来处理所有的事件，如果我们使用pygame.event.wait()，Pygame就会等到发生一个事件才继续下去，在一般游戏中不太实用，因为游戏往往是动态运行的。 ⏱ 2023-08-03 01:00:55</p></blockquote><blockquote><p>📌 当event.type == KEYDOWN时，即为键盘事件，然后再判断按键event.key的种类（即K_a，K_b，K_LEFT这种形式）。也可以用pygame.key.get_pressed()来获得所有按下的键值，它会返回一个元组。这个元组的索引就是键值，对应的就是是否按下此键。 ⏱ 2023-08-03 01:02:30</p></blockquote>',45)])])}const b=o(l,[["render",c]]);export{h as __pageData,b as default};
