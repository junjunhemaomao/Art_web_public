import{_ as t,o as e,c as l,a6 as p}from"./chunks/framework.BB0md0jN.js";const i=JSON.parse('{"title":"Python编程：从入门到实践（第2版）","description":"","frontmatter":{"layout":"doc","title":"Python编程：从入门到实践（第2版）","readingTime":"52 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/计算机_编程设计/Python编程_从入门到实践第2版.md","filePath":"电影和阅读/微信读书/计算机_编程设计/Python编程_从入门到实践第2版.md"}'),c={name:"电影和阅读/微信读书/计算机_编程设计/Python编程_从入门到实践第2版.md"};function u(b,o,q,k,a,n){return e(),l("div",null,[...o[0]||(o[0]=[p('<h1 id="python编程-从入门到实践-第2版" tabindex="-1">Python编程：从入门到实践（第2版） <a class="header-anchor" href="#python编程-从入门到实践-第2版" aria-label="Permalink to &quot;Python编程：从入门到实践（第2版）&quot;">​</a></h1><p><img src="https://cdn.weread.qq.com/weread/cover/90/YueWen_34336681/t6_YueWen_34336681.jpg" alt=" Python编程：从入门到实践（第2版）"></p><ul><li><strong>书名</strong>： Python编程：从入门到实践（第2版）</li><li><strong>作者</strong>： 埃里克·马瑟斯</li><li><strong>简介</strong>： 本书是针对所有层次Python读者而作的Python入门书。全书分两部分：第一部分介绍用Python编程所必须了解的基本概念，包括强大的Python库和工具，以及列表、字典、if语句、类、文件与异常、代码测试等内容；第二部分将理论付诸实践，讲解如何开发三个项目，包括简单的2D游戏、利用数据生成交互式的信息图以及创建和定制简单的Web应用，并帮助读者解决常见编程问题和困惑。第2版进行了全面修订，简化了Python安装流程，新增了f字符串、get()方法等内容，并且在项目中使用了Plotly库以及新版本的Django和Bootstrap，等等。</li><li><strong>出版时间</strong>： 2020-09-18 00:00:00</li><li><strong>ISBN</strong>： 9787115546081</li><li><strong>分类</strong>： 计算机-编程设计</li><li><strong>出版社</strong>： 人民邮电出版社</li><li><strong>PC地址</strong>： <a href="https://weread.qq.com/web/reader/08232ac0720befa90825d88" target="_blank" rel="noreferrer">https://weread.qq.com/web/reader/08232ac0720befa90825d88</a></li></ul><h3 id="第2章-变量和简单数据类型" tabindex="-1">第2章 变量和简单数据类型 <a class="header-anchor" href="#第2章-变量和简单数据类型" aria-label="Permalink to &quot;第2章 变量和简单数据类型&quot;">​</a></h3><blockquote><p>📌 不要企图编写完美无缺的代码，而是要先编写行之有效的代码，再决定是对其做进一步改进，还是转而去编写新代码。 ⏱ 2022-05-22 00:02:07</p></blockquote><h3 id="第3章-列表简介" tabindex="-1">第3章 列表简介 <a class="header-anchor" href="#第3章-列表简介" aria-label="Permalink to &quot;第3章 列表简介&quot;">​</a></h3><blockquote><p>📌 列表让你能够在一个地方存储成组的信息，其中可以只包含几个元素，也可以包含数百万个元素。 ⏱ 2022-05-20 00:38:19</p></blockquote><blockquote><p>📌 列表通常包含多个元素，因此给列表指定一个表示复数的名称（如letters、digits或names）是个不错的主意。 ⏱ 2022-05-20 00:37:42</p></blockquote><blockquote><p>📌 列表是有序集合，因此要访问列表的任意元素，只需将该元素的位置（索引）告诉Python即可。 ⏱ 2022-05-20 00:42:28</p></blockquote><blockquote><p>📌 你创建的大多数列表将是动态的，这意味着列表创建后，将随着程序的运行增删元素。 ⏱ 2022-05-20 00:47:18</p></blockquote><blockquote><p>📌 在列表中添加新元素时，最简单的方式是将元素附加（append）到列表。给列表附加元素时，它将添加到列表末尾。 ⏱ 2022-05-20 00:49:42</p></blockquote><blockquote><p>📌 可以先创建一个空列表，再使用一系列函数调用append()来添加元素。 ⏱ 2022-05-20 00:50:02</p></blockquote><blockquote><p>📌 这种创建列表的方式极其常见，因为经常要等程序运行后，你才知道用户要在程序中存储哪些数据。 ⏱ 2022-05-20 00:54:26</p></blockquote><blockquote><p>📌 使用方法insert()可在列表的任何位置添加新元素。为此，你需要指定新元素的索引和值。 motorcycles = [&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;]￼ ⏱ 2022-05-20 00:54:11</p></blockquote><blockquote><p>📌 如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还能继续使用它，就使用方法pop()。 ⏱ 2022-05-21 08:00:35</p></blockquote><blockquote><p>📌 有时候，你不知道要从列表中删除的值所处的位置。如果只知道要删除的元素的值，可使用方法remove()。 ⏱ 2022-05-21 08:00:49</p></blockquote><blockquote><p>📌 方法remove()只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来确保将每个值都删除。 ⏱ 2022-05-21 08:04:11</p></blockquote><blockquote><p>📌 注意　在并非所有的值都是小写时，按字母顺序排列列表要复杂些。决定排列顺序时，有多种解读大写字母的方式，要指定准确的排列顺序，可能比我们这里所做的要复杂。然而，大多数排序方式是以本节介绍的知识为基础的。 ⏱ 2022-05-21 12:46:41</p></blockquote><blockquote><p>📌 使用函数len()可快速获悉列表的长度。 ⏱ 2022-05-21 13:39:40</p></blockquote><blockquote><p>📌 在第4章，你将学习如何以更高效的方式处理列表元素。通过使用为数不多的几行代码来遍历列表元素，你就能高效地处理它们，即便列表包含数千乃至数百万个元素。 ⏱ 2022-05-21 13:42:25</p></blockquote><h3 id="第4章-操作列表" tabindex="-1">第4章 操作列表 <a class="header-anchor" href="#第4章-操作列表" aria-label="Permalink to &quot;第4章 操作列表&quot;">​</a></h3><blockquote><p>📌 编写for循环时，可以给依次与列表中每个值相关联的临时变量指定任意名称。 ⏱ 2022-05-21 23:23:29</p></blockquote><blockquote><p>📌 这些命名约定有助于你明白for循环中将对每个元素执行的操作。使用单数和复数式名称，可帮助你判断代码段处理的是单个列表元素还是整个列表。 ⏱ 2022-05-21 22:27:59</p></blockquote><blockquote><p>📌 在for循环中，想包含多少行代码都可以。在代码行for magician in magicians后面，每个缩进的代码行都是循环的一部分，将针对列表中的每个值都执行一次。 ⏱ 2022-05-21 23:23:29</p></blockquote><blockquote><p>📌 第二个函数调用print()中的换行符&quot;\\n&quot;（见❶）在每次迭代结束后都插入一个空行 ⏱ 2022-05-21 22:36:55</p></blockquote><blockquote><p>📌 在for循环后面，没有缩进的代码都只执行一次，不会重复执行。 ⏱ 2022-05-21 22:37:32</p></blockquote><blockquote><p>📌 你可能使用for循环来初始化游戏：遍历角色列表，将每个角色显示到屏幕上。然后在循环后面添加一个不缩进的代码块，在屏幕上绘制所有角色后显示一个Play Now按钮。 ⏱ 2022-05-21 23:23:29</p></blockquote><blockquote><p>📌 Python根据缩进来判断代码行与前一个代码行的关系。 ⏱ 2022-05-21 22:42:17</p></blockquote><blockquote><p>📌 Python函数range()让你能够轻松地生成一系列数 ⏱ 2022-05-21 22:49:56</p></blockquote><blockquote><p>📌 使用range()时，如果输出不符合预期，请尝试将指定的值加1或减1。 ⏱ 2022-05-21 22:47:48</p></blockquote><blockquote><p>📌 调用函数range()时，也可只指定一个参数，这样它将从0开始。例如，range(6)返回数0～5。 ⏱ 2022-05-21 22:48:06</p></blockquote><blockquote><p>📌 在Python中，用两个星号（**）表示乘方运算。 ⏱ 2022-05-21 22:53:41</p></blockquote><blockquote><p>📌 为了让代码更简洁，可不使用临时变量square，而直接将每个计算得到的值附加到列表末尾： ⏱ 2022-05-21 22:57:53</p></blockquote><blockquote><p>📌 有时候，使用临时变量会让代码更易读；而在其他情况下，这样做只会让代码无谓地变长。你首先应该考虑的是，编写清晰易懂且能完成所需功能的代码，等到审核代码时，再考虑采用更高效的方法。 ⏱ 2022-05-21 23:08:11</p></blockquote><blockquote><p>📌 列表解析将for循环和创建新元素的代码合并成一行，并自动附加新元素。 ⏱ 2022-05-21 23:13:04</p></blockquote><blockquote><p>📌 要创建切片，可指定要使用的第一个元素和最后一个元素的索引。 ⏱ 2022-05-21 23:17:52</p></blockquote><blockquote><p>📌 如果没有指定第一个索引，Python将自动从列表开头开始： ⏱ 2022-05-21 23:20:44</p></blockquote><blockquote><p>📌 无论列表多长，这种语法都能够让你输出从特定位置到列表末尾的所有元素 ⏱ 2022-05-21 23:21:38</p></blockquote><blockquote><p>📌 负数索引返回离列表末尾相应距离的元素 ⏱ 2022-05-21 23:22:22</p></blockquote><blockquote><p>📌 可在表示切片的方括号内指定第三个值。这个值告诉Python在指定范围内每隔多少元素提取一个。 ⏱ 2022-05-21 23:22:53</p></blockquote><blockquote><p>📌 在很多情况下，切片都很有用。例如，编写游戏时，你可以在玩家退出游戏时将其最终得分加入一个列表中，然后将该列表按降序排列以获取三个最高得分，再创建一个只包含前三个得分的切片；处理数据时，可使用切片来进行批量处理；编写Web应用程序时，可使用切片来分页显示信息，并在每页显示数量合适的信息。 ⏱ 2022-05-21 23:30:08</p></blockquote><blockquote><p>📌 要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:]）。这让Python创建一个始于第一个元素、终止于最后一个元素的切片，即整个列表的副本。 ⏱ 2022-05-21 23:34:21</p></blockquote><blockquote><p>📌 严格地说，元组是由逗号标识的，圆括号只是让元组看起来更整洁、更清晰。如果你要定义只包含一个元素的元组，必须在这个元素后面加上逗号： my_t = (3,) 创建只包含一个元素的元组通常没有意义，但自动生成的元组有可能只有一个元素。 ⏱ 2022-05-21 23:50:45</p></blockquote><blockquote><p>📌 相比于列表，元组是更简单的数据结构。如果需要存储的一组值在程序的整个生命周期内都不变，就可以使用元组。 ⏱ 2022-05-21 23:56:43</p></blockquote><blockquote><p>📌 如果一定要在让代码易于编写和易于阅读之间做出选择，Python程序员几乎总是选择后者。 ⏱ 2022-05-21 23:57:15</p></blockquote><blockquote><p>📌 要将程序的不同部分分开，可使用空行。 ⏱ 2022-05-21 23:57:47</p></blockquote><h3 id="第6章-字典" tabindex="-1">第6章 字典 <a class="header-anchor" href="#第6章-字典" aria-label="Permalink to &quot;第6章 字典&quot;">​</a></h3><blockquote><p>📌 字典可存储的信息量几乎不受限制，因此我们会演示如何遍历字典中的数据。 ⏱ 2021-05-08 12:38:44</p></blockquote><blockquote><p>📌 与大多数编程概念一样，要熟练使用字典，也需要一段时间的练习。使用字典一段时间后，你就会明白为何它们能够高效地模拟现实世界中的情形。 ⏱ 2021-05-08 12:40:08</p></blockquote><blockquote><p>📌 可将任何Python对象用作字典中的值。 ⏱ 2021-05-08 12:40:39</p></blockquote><blockquote><p>📌 键值对是两个相关联的值。指定键时，Python将返回与之相关联的值。键和值之间用冒号分隔，而键值对之间用逗号分隔。 ⏱ 2021-05-08 12:41:08</p></blockquote><blockquote><p>📌 使用字典来存储用户提供的数据或在编写能自动生成大量键值对的代码时，通常需要先定义一个空字典。 ⏱ 2022-05-28 19:47:53</p></blockquote><h3 id="第8章-函数" tabindex="-1">第8章 函数 <a class="header-anchor" href="#第8章-函数" aria-label="Permalink to &quot;第8章 函数&quot;">​</a></h3><blockquote><p>📌 最简单的关联方式是基于实参的顺序。这种关联方式称为位置实参。 ⏱ 2021-05-08 08:50:17</p></blockquote><blockquote><p>📌 关键字实参让你无须考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。 ⏱ 2021-05-08 08:56:15</p></blockquote><blockquote><p>📌 编写函数时，可给每个形参指定默认值。 ⏱ 2021-05-08 08:57:12</p></blockquote><blockquote><p>📌 使用默认值可简化函数调用，还可清楚地指出函数的典型用法。 ⏱ 2021-05-08 09:22:57</p></blockquote><blockquote><p>📌 然而，Python依然将这个实参视为位置实参， ⏱ 2021-05-08 09:24:45</p></blockquote><blockquote><p>📌 使用哪种调用方式无关紧要，只要函数调用能生成你期望的输出就行。使用对你来说最容易理解的调用方式即可。 ⏱ 2021-05-08 09:26:39</p></blockquote><blockquote><p>📌 如果遇到实参不匹配错误，不要大惊小怪。你提供的实参多于或少于函数完成工作所需的信息时，将出现实参不匹配错误。 ⏱ 2021-05-08 09:26:56</p></blockquote><blockquote><p>📌 在函数中，可使用return语句将值返回到调用函数的代码行。返回值让你能够将程序的大部分繁重工作移到函数中去完成，从而简化主程序。 ⏱ 2021-05-08 09:33:35</p></blockquote><blockquote><p>📌 调用返回值的函数时，需要提供一个变量，以便将返回的值赋给它。 ⏱ 2021-05-08 09:45:07</p></blockquote><blockquote><p>📌 为了让中间名变成可选的，可给形参middle_name指定一个空的默认值，并在用户没有提供中间名时不使用这个形参。 ⏱ 2021-05-08 12:19:47</p></blockquote><blockquote><p>📌 可将形参middle_name的默认值设置为空字符串，并将其移到形参列表的末尾： ⏱ 2023-07-23 00:06:36</p></blockquote><blockquote><p>📌 如果还要指定中间名，就必须确保它是最后一个实参，这样Python才能正确地将位置实参关联到形参（见❹）。 ⏱ 2023-07-23 00:07:39</p></blockquote><blockquote><p>📌 可选值让函数能够处理各种不同的情形，同时确保函数调用尽可能简单。 ⏱ 2021-05-08 12:47:18</p></blockquote><blockquote><p>📌 函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。 ⏱ 2021-05-08 12:47:19</p></blockquote><blockquote><p>📌 这个函数接受简单的文本信息，并将其放在一个更合适的数据结构中，让你不仅能打印这些信息，还能以其他方式处理它们。 ⏱ 2021-05-08 13:17:37</p></blockquote><blockquote><p>📌 可将None视为占位值。在条件测试中，None相当于False。 ⏱ 2021-05-08 13:19:09</p></blockquote><blockquote><p>📌 将列表传递给函数后，函数就可对其进行修改。在函数中对这个列表所做的任何修改都是永久性的，这让你能够高效地处理大量数据。 ⏱ 2021-05-16 01:59:05</p></blockquote><blockquote><p>📌 该程序还演示了这样一种理念：每个函数都应只负责一项具体的工作。第一个函数打印每个设计，第二个显示打印好的模型。这优于使用一个函数来完成这两项工作。编写函数时，如果发现它执行的任务太多，请尝试将这些代码划分到两个函数中。 ⏱ 2021-05-16 01:59:57</p></blockquote><blockquote><p>📌 要将列表的副本传递给函数，可以像下面这样做：function_name(list_name_[:])切片表示法[:]创建列表的副本。 ⏱ 2023-07-23 22:13:17</p></blockquote><blockquote><p>📌 虽然向函数传递列表的副本可保留原始列表的内容，但除非有充分的理由，否则还是应该将原始列表传递给函数。这是因为让函数使用现成的列表可避免花时间和内存创建副本，从而提高效率，在处理大型列表时尤其如此。 ⏱ 2023-07-23 22:15:52</p></blockquote><blockquote><p>📌 有时候，预先不知道函数需要接受多少个实参，好在Python允许函数从调用语句中收集任意数量的实参。 ⏱ 2023-07-23 22:16:07</p></blockquote><blockquote><p>📌 形参名*toppings中的星号让Python创建一个名为toppings的空元组，并将收到的所有值都封装到这个元组中。 ⏱ 2023-07-23 22:16:51</p></blockquote><blockquote><p>📌 有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键值对 ⏱ 2021-05-15 20:02:11</p></blockquote><blockquote><p>📌 通过将函数存储在独立的文件中，可隐藏程序代码的细节，将重点放在程序的高层逻辑上。 ⏱ 2021-05-15 19:50:04</p></blockquote><blockquote><p>📌 要调用被导入模块中的函数，可指定被导入模块的名称pizza和函数名make_pizza()，并用句点分隔（见❶） ⏱ 2023-07-24 08:49:43</p></blockquote><blockquote><p>📌 如果只想导入要使用的函数，代码将类似于下面这样：from pizza import make_pizzamake_pizza(16, &#39;pepperoni&#39;)make_pizza(12, &#39;mushrooms&#39;, &#39;green peppers&#39;, &#39;extra cheese&#39;)使用这种语法时，调用函数时无须使用句点。由于在import语句中显式地导入了函数make_pizza()，调用时只需指定其名称即可。 ⏱ 2023-07-24 08:51:10</p></blockquote><blockquote><p>📌 如果要导入函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名：函数的另一个名称，类似于外号。要给函数取这种特殊外号，需要在导入它时指定。 ⏱ 2021-05-16 02:01:05</p></blockquote><blockquote><p>📌 使用星号（*）运算符可让Python导入模块中的所有函数： ⏱ 2021-05-16 02:01:41</p></blockquote><blockquote><p>📌 由于导入了每个函数，可通过名称来调用每个函数，而无须使用句点表示法。 ⏱ 2021-05-16 02:02:06</p></blockquote><blockquote><p>📌 然而，使用并非自己编写的大型模块时，最好不要采用这种导入方法。这是因为如果模块中有函数的名称与当前项目中使用的名称相同，可能导致意想不到的结果：Python可能遇到多个名称相同的函数或变量，进而覆盖函数，而不是分别导入所有的函数。 最佳的做法是，要么只导入需要使用的函数，要么导入整个模块并使用句点表示法。这让代码更清晰，更容易阅读和理解。 ⏱ 2021-05-16 02:02:52</p></blockquote><blockquote><p>📌 每个函数都应包含简要地阐述其功能的注释。该注释应紧跟在函数定义后面，并采用文档字符串格式。 ⏱ 2021-05-16 02:03:19</p></blockquote><blockquote><p>📌 他们完全可以相信代码如描述的那样运行，并且只要知道函数的名称、需要的实参以及返回值的类型，就能在自己的程序中使用它。 ⏱ 2021-05-16 02:03:34</p></blockquote><blockquote><p>📌 给形参指定默认值时，等号两边不要有空格： ⏱ 2021-05-16 02:03:52</p></blockquote><blockquote><p>📌 PEP 8建议代码行的长度不要超过79字符，这样只要编辑器窗口适中，就能看到整行代码。如果形参很多，导致函数定义的长度超过了79字符，可在函数定义中输入左括号后按回车键，并在下一行按两次Tab键，从而将形参列表和只缩进一层的函数体区分开来。 ⏱ 2023-07-24 08:54:50</p></blockquote><blockquote><p>📌 程序员的目标之一是，编写简单的代码来完成任务，而函数有助于你实现这样的目标。它们让你编写好代码块并确定其能够正确运行后，就可置之不理。确定函数能够正确地完成其工作后，你就可以接着投身于下一个编码任务。 ⏱ 2023-07-24 09:00:16</p></blockquote><blockquote><p>📌 函数还让代码更容易测试和调试。如果程序使用一系列的函数来完成其任务，而其中的每个函数都完成一项具体的工作，测试和维护起来将容易得多：可编写分别调用每个函数的程序，并测试每个函数是否在它可能遇到的各种情形下都能正确地运行。 ⏱ 2023-07-24 09:01:00</p></blockquote><h3 id="第9章-类" tabindex="-1">第9章 类 <a class="header-anchor" href="#第9章-类" aria-label="Permalink to &quot;第9章 类&quot;">​</a></h3><blockquote><p>📌 你将指定可在实例中存储什么信息，定义可对这些实例执行哪些操作。你还将编写一些类来扩展既有类的功能，让相似的类能够高效地共享代码。 ⏱ 2023-07-24 09:08:40</p></blockquote><blockquote><p>📌 理解面向对象编程有助于你像程序员那样看世界，还可以帮助你真正明白自己编写的代码：不仅是各行代码的作用，还有代码背后更宏大的概念。了解类背后的概念可培养逻辑思维，让你能够通过编写程序来解决遇到的几乎任何问题。 ⏱ 2021-05-16 02:10:39</p></blockquote><blockquote><p>📌 我们将方法__init__()定义成包含三个形参：self、name和age。在这个方法的定义中，形参self必不可少，而且必须位于其他形参的前面。为何必须在方法定义中包含形参self呢？因为Python调用这个方法来创建Dog实例时，将自动传入实参self。每个与实例相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。 ⏱ 2021-05-16 02:14:18</p></blockquote><blockquote><p>📌 像这样可通过实例访问的变量称为属性。 ⏱ 2022-05-19 08:52:10</p></blockquote><blockquote><p>📌 Dog类还定义了另外两个方法：sit()和roll_over()（见❺）。这些方法执行时不需要额外的信息，因此它们只有一个形参self。 ⏱ 2022-05-19 08:52:47</p></blockquote><blockquote><p>📌 要访问实例的属性，可使用句点表示法。 ⏱ 2022-05-19 08:56:29</p></blockquote><blockquote><p>📌 要调用方法，可指定实例的名称（这里是my_dog）和要调用的方法，并用句点分隔。 ⏱ 2022-05-19 09:00:18</p></blockquote><blockquote><p>📌 类编写好后，你的大部分时间将花在根据类创建的实例上。你需要执行的一个重要任务是修改实例的属性。可以直接修改实例的属性，也可以编写方法以特定的方式进行修改。 ⏱ 2022-05-19 09:14:11</p></blockquote><blockquote><p>📌 创建实例时，有些属性无须通过形参来定义，可在方法__init__()中为其指定默认值 ⏱ 2023-07-26 08:52:06</p></blockquote><blockquote><p>📌 我们能以三种方式修改属性的值：直接通过实例进行修改，通过方法进行设置，以及通过方法进行递增（增加特定的值）。 ⏱ 2023-07-26 08:56:53</p></blockquote><blockquote><p>📌 要修改属性的值，最简单的方式是通过实例直接访问它。 ⏱ 2023-07-26 08:56:57</p></blockquote><blockquote><p>📌 在既有类的基础上编写新类时，通常要调用父类的方法__init__()。这将初始化在父类__init__()方法中定义的所有属性，从而让子类包含这些属性。 ⏱ 2023-07-26 23:45:12</p></blockquote><blockquote><p>📌 ❹处的super()是一个特殊函数，让你能够调用父类的方法。这行代码让Python调用Car类的方法__init__()，让ElectricCar实例包含这个方法中定义的所有属性。父类也称为超类（superclass），名称super由此而来。 ⏱ 2023-07-26 23:46:33</p></blockquote><blockquote><p>📌 让一个类继承另一个类后，就可以添加区分子类和父类所需的新属性和新方法了 ⏱ 2023-07-27 00:16:20</p></blockquote><blockquote><p>📌 重写父类的方法 对于父类的方法，只要它不符合子类模拟的实物的行为，都可以进行重写。为此，可在子类中定义一个与要重写的父类方法同名的方法。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。 ⏱ 2023-07-27 00:28:19</p></blockquote><blockquote><p>📌 现在，如果有人对电动汽车调用方法fill_gas_tank()，Python将忽略Car类中的方法fill_gas_tank()，转而运行上述代码。使用继承时，可让子类保留从父类那里继承而来的精华，并剔除不需要的糟粕。 ⏱ 2023-07-27 00:32:10</p></blockquote><blockquote><p>📌 将实例用作属性 ⏱ 2023-07-27 00:35:04</p></blockquote><blockquote><p>📌 可以将大型类拆分成多个协同工作的小类 ⏱ 2023-07-27 00:34:51</p></blockquote><blockquote><p>📌 例如，不断给ElectricCar类添加细节时，我们可能发现其中包含很多专门针对汽车电瓶的属性和方法。在这种情况下，可将这些属性和方法提取出来，放到一个名为Battery的类中，并将一个Battery实例作为ElectricCar类的属性： ⏱ 2023-07-27 00:46:39</p></blockquote><blockquote><p>📌 这让你进入了程序员的另一个境界：解决上述问题时，从较高的逻辑层面（而不是语法层面）考虑；考虑的不是Python，而是如何使用代码来表示实物。达到这种境界后，你会经常发现，对现实世界的建模方法没有对错之分。有些方法的效率更高，但要找出效率最高的表示法，需要经过一定的实践。 ⏱ 2023-07-27 01:22:32</p></blockquote><blockquote><p>📌 Python在这方面提供了帮助，允许将类存储在模块中，然后在主程序中导入所需的模块。 ⏱ 2023-07-27 01:24:24</p></blockquote><blockquote><p>📌 导入类是一种有效的编程方式。如果这个程序包含整个Class类，它该有多长啊！通过将这个类移到一个模块中并导入该模块，依然可以使用其所有功能，但主程序文件变得整洁而易于阅读了。这还让你能够将大部分逻辑存储在独立的文件中。确定类像你希望的那样工作后，就可以不管这些文件，而专注于主程序的高级逻辑了。 ⏱ 2023-07-27 01:30:16</p></blockquote><blockquote><p>📌 还可以导入整个模块，再使用句点表示法访问需要的类。 ⏱ 2023-07-27 01:33:24</p></blockquote><blockquote><p>📌 导入模块中的所有类 要导入模块中的每个类，可使用下面的语法： from module_name import * 不推荐使用这种导入方式，原因有二。第一，如果只看文件开头的import语句，就能清楚地知道程序使用了哪些类，将大有裨益。然而这种导入方式没有明确地指出使用了模块中的哪些类。第二，这种方式还可能引发名称方面的迷惑。如果不小心导入了一个与程序文件中其他东西同名的类，将引发难以诊断的错误。这里之所以介绍这种导入方式，是因为虽然不推荐使用，但你可能在别人编写的代码中见到它。 ⏱ 2023-07-27 01:34:44</p></blockquote><blockquote><p>📌 需要从一个模块中导入很多类时，最好导入整个模块，并使用module_name.ClassName语法来访问类。 ⏱ 2023-07-27 01:35:17</p></blockquote><blockquote><p>📌 在一个模块中导入另一个模块 有时候，需要将类分散到多个模块中，以免模块太大或在同一个模块中存储不相关的类。将类存储在多个模块中时，你可能会发现一个模块中的类依赖于另一个模块中的类。在这种情况下，可在前一个模块中导入必要的类。 ⏱ 2023-07-27 01:37:18</p></blockquote><blockquote><p>📌 一开始应让代码结构尽可能简单。先尽可能在一个文件中完成所有的工作，确定一切都能正确运行后，再将类移到独立的模块中。 ⏱ 2023-07-27 01:40:39</p></blockquote><blockquote><p>📌 先找出让你能够编写出可行代码的方式，再尝试改进代码。 ⏱ 2023-07-27 01:40:43</p></blockquote><blockquote><p>📌 一个有趣的函数是randint()。它将两个整数作为参数，并随机返回一个位于这两个整数之间（含）的整数。下面演示了如何生成一个位于1和6之间的随机整数： ⏱ 2023-07-27 01:43:01</p></blockquote><blockquote><p>📌 在模块random中，另一个有用的函数是choice()。它将一个列表或元组作为参数，并随机返回其中的一个元素 ⏱ 2023-07-27 01:48:13</p></blockquote><blockquote><p>📌 对于每个类，都应紧跟在类定义后面包含一个文档字符串。这种文档字符串简要地描述类的功能，并遵循编写函数的文档字符串时采用的格式约定。每个模块也都应包含一个文档字符串，对其中的类可用于做什么进行描述。 ⏱ 2023-07-27 01:50:12</p></blockquote><blockquote><p>📌 需要同时导入标准库中的模块和你编写的模块时，先编写导入标准库模块的import语句，再添加一个空行，然后编写导入你自己编写的模块的import语句。在包含多条import语句的程序中，这种做法让人更容易明白程序使用的各个模块都来自何处。 ⏱ 2023-07-27 01:50:40</p></blockquote><blockquote><p>📌 将一个类的实例用作另一个类的属性可让类更简洁。 ⏱ 2023-07-27 01:51:45</p></blockquote><blockquote><p>📌 异常，这是一种特殊的Python类，用于帮助你在发生错误时采取相应的措施。 ⏱ 2023-07-27 01:52:09</p></blockquote><h3 id="第10章-文件和异常" tabindex="-1">第10章 文件和异常 <a class="header-anchor" href="#第10章-文件和异常" aria-label="Permalink to &quot;第10章 文件和异常&quot;">​</a></h3><blockquote><p>📌 在本章中，你将学习处理文件，让程序能够快速地分析大量数据； ⏱ 2023-07-27 01:54:06</p></blockquote><blockquote><p>📌 模块json，它让你能够保存用户数据，以免在程序停止运行后丢失。学习处理文件和保存数据可让你的程序使用起来更容易： ⏱ 2022-06-21 21:01:27</p></blockquote><blockquote><p>📌 要以任何方式使用文件，那怕仅仅是打印其内容，都得先打开文件，才能访问它。 ⏱ 2023-07-27 08:59:46</p></blockquote><blockquote><p>📌 相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。为何会多出这个空行呢？因为read()到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在函数调用print()中使用rstrip()： ⏱ 2023-07-27 09:03:00</p></blockquote><blockquote><p>📌 本书前面说过，Python方法rstrip()删除字符串末尾的空白 ⏱ 2023-07-27 09:03:15</p></blockquote><blockquote><p>📌 注意　显示文件路径时，Windows系统使用反斜杠（\\）而不是斜杠（/），但在代码中依然可以使用斜杠。 ⏱ 2023-07-27 09:04:29</p></blockquote><blockquote><p>📌 通过使用绝对路径，可读取系统中任何地方的文件。 ⏱ 2023-07-27 09:07:35</p></blockquote><blockquote><p>📌 注意　如果在文件路径中直接使用反斜杠，将引发错误，因为反斜杠用于对字符串中的字符进行转义。例如，对于路径&quot;C:\\path\\to\\file.txt&quot;，其中的\\t将被解读为制表符。如果一定要使用反斜杠，可对路径中的每个反斜杠都进行转义，如&quot;C:\\path\\to\\file.txt&quot;。 ⏱ 2023-07-27 09:31:15</p></blockquote><blockquote><p>📌 Python使用称为异常的特殊对象来管理程序执行期间发生的错误。每当发生让Python不知所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行；如果未对异常进行处理，程序将停止并显示traceback，其中包含有关异常的报告。异常是使用try-except代码块处理的。try-except代码块让Python执行指定的操作，同时告诉Python发生异常时怎么办。使用try-except代码块时，即便出现异常，程序也将继续运行 ⏱ 2023-07-29 14:02:01</p></blockquote><blockquote><p>📌 ZeroDivisionError是个异常对象。Python无法按你的要求做时，就会创建这种对象。 ⏱ 2023-07-29 14:03:05</p></blockquote><blockquote><p>📌 如果try代码块中的代码运行起来没有问题，Python将跳过except代码块；如果try代码块中的代码导致了错误，Python将查找与之匹配的except代码块并运行其中的代码。 ⏱ 2023-07-29 14:04:02</p></blockquote><blockquote><p>📌 如果try-except代码块后面还有其他代码，程序将接着运行，因为已经告诉了Python如何处理这种错误。下面来看一个捕获错误后程序继续运行的示例。 ⏱ 2023-07-29 14:04:28</p></blockquote><blockquote><p>📌 程序崩溃可不好，但让用户看到traceback也不是个好主意。不懂技术的用户会被搞糊涂，怀有恶意的用户还会通过traceback获悉你不想他知道的信息。例如，他将知道你的程序文件的名称，还将看到部分不能正确运行的代码。有时候，训练有素的攻击者可根据这些信息判断出可对你的代码发起什么样的攻击。 ⏱ 2023-07-29 14:08:08</p></blockquote><blockquote><p>📌 依赖try代码块成功执行的代码都应放到else代码块中： ⏱ 2023-07-29 14:08:46</p></blockquote><blockquote><p>📌 使用文件时，一种常见的问题是找不到文件：查找的文件可能在其他地方，文件名可能不正确，或者这个文件根本就不存在。对于所有这些情形，都可使用try-except代码块以直观的方式处理。 ⏱ 2023-07-29 14:09:54</p></blockquote><blockquote><p>📌 ，有时候你希望程序在发生异常时保持静默，就像什么都没有发生一样继续运行。要让程序静默失败，可像通常那样编写try代码块，但在except代码块中明确地告诉Python什么都不要做。Python有一个pass语句，可用于让Python在代码块中什么都不要做： ⏱ 2023-07-29 14:13:13</p></blockquote><blockquote><p>📌 pass语句还充当了占位符，提醒你在程序的某个地方什么都没有做，并且以后也许要在这里做些什么。例如，在这个程序中，我们可能决定将找不到的文件的名称写入文件missing_files.txt中。用户看不到这个文件，但我们可以读取它，进而处理所有找不到文件的问题。 ⏱ 2023-07-29 14:14:07</p></blockquote><blockquote><p>📌 Python的错误处理结构让你能够细致地控制与用户分享错误信息的程度，要分享多少信息由你决定。 ⏱ 2023-07-29 14:14:38</p></blockquote><blockquote><p>📌 编写得很好且经过详尽测试的代码不容易出现内部错误，如语法或逻辑错误，但只要程序依赖于外部因素，如用户输入、存在指定的文件、有网络链接，就有可能出现异常。凭借经验可判断该在程序的什么地方包含异常处理块，以及出现错误时该向用户提供多少相关的信息。 ⏱ 2023-07-29 14:16:52</p></blockquote><blockquote><p>📌 很多程序都要求用户输入某种信息，如让用户存储游戏首选项或提供要可视化的数据。不管关注点是什么，程序都把用户提供的信息存储在列表和字典等数据结构中。用户关闭程序时，几乎总是要保存他们提供的信息。一种简单的方式是使用模块json来存储数据。模块json让你能够将简单的Python数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。你还可以使用json在Python程序之间分享数据。更重要的是，JSON数据格式并非Python专用的，这让你能够将以JSON格式存储的数据与使用其他编程语言的人分享。这是一种轻便而有用的格式，也易于学习。注意　JSON（JavaScript Object Notation）格式最初是为JavaScript开发的，但随后成了一种常见格式，被包括Python在内的众多语言采用。 ⏱ 2023-07-29 15:12:48</p></blockquote><blockquote><p>📌 第一个程序将使用json.dump()来存储这组数，而第二个程序将使用json.load()。 ⏱ 2023-07-29 15:13:17</p></blockquote><blockquote><p>📌 你经常会遇到这样的情况：代码能够正确地运行，但通过将其划分为一系列完成具体工作的函数，还可以改进。这样的过程称为重构。重构让代码更清晰、更易于理解、更容易扩展。 ⏱ 2023-07-29 15:14:31</p></blockquote><blockquote><p>📌 每个函数都执行单一而清晰的任务。 ⏱ 2023-07-29 15:14:59</p></blockquote><h3 id="第11章-测试代码" tabindex="-1">第11章 测试代码 <a class="header-anchor" href="#第11章-测试代码" aria-label="Permalink to &quot;第11章 测试代码&quot;">​</a></h3><blockquote><p>📌 编写函数或类时，还可为其编写测试。通过测试，可确定代码面对各种输入都能够按要求的那样工作。 ⏱ 2023-07-29 15:17:06</p></blockquote><blockquote><p>📌 使用Python模块unittest中的工具来测试代码， ⏱ 2023-07-29 15:19:06</p></blockquote><blockquote><p>📌 Python提供了一种自动测试函数输出的高效方式。 ⏱ 2023-07-29 15:20:34</p></blockquote><blockquote><p>📌 Python标准库中的模块unittest提供了代码测试工具。单元测试用于核实函数的某个方面没有问题。测试用例是一组单元测试，它们一道核实函数在各种情形下的行为都符合要求。 ⏱ 2023-07-29 15:21:32</p></blockquote><h3 id="第12章-武装飞船" tabindex="-1">第12章 武装飞船 <a class="header-anchor" href="#第12章-武装飞船" aria-label="Permalink to &quot;第12章 武装飞船&quot;">​</a></h3><blockquote><p>📌 pygame.display.flip()将不断更新 ⏱ 2023-07-29 19:45:13</p></blockquote><blockquote><p>📌 调用方法fill()用这种背景色填充屏幕。方法fill()用于处理surface，只接受一个实参：一种颜色。 ⏱ 2023-07-29 19:51:51</p></blockquote><blockquote><p>📌 Pygame之所以高效，是因为它让你能够像处理矩形（rect对象）一样处理所有的游戏元素，即便其形状并非矩形。像处理矩形一样处理游戏元素之所以高效，是因为矩形是简单的几何形状。例如，通过将游戏元素视为矩形，Pygame能够更快地判断出它们是否发生了碰撞。这种做法的效果通常很好，游戏玩家几乎注意不到我们处理的并不是游戏元素的实际形状。在这个类中，我们将把飞船和屏幕作为矩形进行处理。 ⏱ 2022-05-14 17:45:28</p></blockquote><blockquote><p>📌 Ship的方法__init__()接受两个参数：引用self和指向当前AlienInvasion实例的引用。这让Ship能够访问AlienInvasion中定义的所有游戏资源。在❶处，将屏幕赋给了Ship的一个属性，以便在这个类的所有方法中轻松访问。在❷处，使用方法get_rect()访问屏幕的属性rect，并将其赋给了self.screen_rect，这让我们能够将飞船放到屏幕的正确位置。 ⏱ 2023-07-30 20:26:20</p></blockquote><blockquote><p>📌 处理rect对象时，可使用矩形四角和中心的￼坐标和￼坐标。可通过设置这些值来指定矩形的位置。要让游戏元素居中，可设置相应rect对象的属性center、centerx或centery；要让游戏元素与屏幕边缘对齐，可使用属性top、bottom、left或right。除此之外，还有一些组合属性，如midbottom、midtop、midleft和midright。要调整游戏元素的水平或垂直位置，可使用属性x和y，分别是相应矩形左上角的￼坐标和￼坐标。这些属性让你无须做游戏开发人员原本需要手工完成的计算，因此会经常用到。 ⏱ 2023-07-30 20:55:02</p></blockquote><blockquote><p>📌 在Pygame中，原点(0, 0)位于屏幕左上角，向右下方移动时，坐标值将增大。 ⏱ 2023-07-30 20:55:21</p></blockquote><blockquote><p>📌 我们要将飞船放在屏幕底部的中央。为此，将self.rect.midbottom设置为表示屏幕的矩形的属性midbottom（见❹）。Pygame使用这些rect属性来放置飞船图像，使其与屏幕下边缘对齐并水平居中。 在❺处，定义了方法blitme()，它将图像绘制到self.rect指定的位置。 ⏱ 2023-07-30 20:57:20</p></blockquote><blockquote><p>📌 调用Ship()时，必须提供一个参数：一个AlienInvasion实例。在这里，self指向的是当前AlienInvasion实例。这个参数让Ship能够访问游戏资源，如对象screen。我们将这个Ship实例赋给了self.ship。 ⏱ 2023-07-30 20:59:22</p></blockquote><blockquote><p>📌 在大型项目中，经常需要在添加新代码前重构既有代码。重构旨在简化既有代码的结构，使其更容易扩展。 ⏱ 2022-05-14 18:41:59</p></blockquote><blockquote><p>📌 辅助方法在类中执行任务，但并非是通过实例调用的。在Python中，辅助方法的名称以单个下划线打头。 ⏱ 2022-12-13 12:34:54</p></blockquote><blockquote><p>📌 我们将把管理事件的代码移到一个名为_check_events()的方法中，以简化run_game()并隔离事件管理循环。通过隔离事件循环，可将事件管理与游戏的其他方面（如更新屏幕）分离。 ⏱ 2023-07-30 21:03:08</p></blockquote><blockquote><p>📌 要调用当前类的方法，可使用句点表示法，并指定变量名self和要调用的方法的名称 ⏱ 2023-07-30 21:12:28</p></blockquote><blockquote><p>📌 如果你开发过大量的游戏，可能早就开始像这样将代码放到不同的方法中了。不过如果你从未开发过这样的项目，可能不知道如何组织代码。这里采用的做法是，先编写可行的代码，等代码越来越复杂时再进行重构，以向你展示真正的开发过程：先编写尽可能简单的代码，等项目越来越复杂后对其进行重构。 ⏱ 2022-05-14 19:20:30</p></blockquote><blockquote><p>📌 每当用户按键时，都将在Pygame中注册一个事件。事件都是通过方法pygame.event.get()获取的，因此需要在方法_check_events()中指定要检查哪些类型的事件。每次按键都被注册为一个KEYDOWN事件。 ⏱ 2022-05-14 19:22:35</p></blockquote><blockquote><p>📌 玩家按住右箭头键不放时，我们希望飞船不断向右移动，直到玩家松开为止。我们将让游戏检测pygame.KEYUP事件，以便知道玩家何时松开右箭头键。然后，结合使用KEYDOWN和KEYUP事件以及一个名为moving_right的标志来实现持续移动。 ⏱ 2023-07-30 23:24:41</p></blockquote><blockquote><p>📌 飞船的属性都由Ship类控制，因此要给这个类添加一个名为moving_right的属性和一个名为update()的方法。方法update()检查标志moving_right的状态。如果该标志为True，就调整飞船的位置。我们将在while循环中调用这个方法，以调整飞船的位置。 ⏱ 2023-07-30 23:25:05</p></blockquote><blockquote><p>📌 在方法__init__()中，添加属性self.moving_right，并将其初始值设置为False（见❶）。接下来，添加方法update()，在前述标志为True时向右移动飞船（见❷）。方法update()将通过Ship实例来调用，因此不是辅助方法。 ⏱ 2023-07-30 23:40:35</p></blockquote><blockquote><p>📌 飞船的位置将在检测到键盘事件后（但在更新屏幕前）更新。这样，玩家输入时，飞船的位置将更新，从而确保使用更新后的位置将飞船绘制到屏幕上 ⏱ 2022-05-14 19:45:44</p></blockquote><blockquote><p>📌 这里之所以可以使用elif代码块，是因为每个事件都只与一个键相关联。如果玩家同时按下左右箭头键，将检测到两个不同的事件。 ⏱ 2022-05-14 19:56:36</p></blockquote><blockquote><p>📌 通过将速度设置指定为小数值，可在后面加快游戏节奏时更细致地控制飞船的速度。 ⏱ 2022-05-14 20:16:26</p></blockquote><blockquote><p>📌 主文件alien_invasion.py包含AlienInvasion类。这个类创建一系列贯穿整个游戏都要用到的属性：赋给self.settings的设置，赋给screen中的主显示surface，以及一个飞船实例。这个模块还包含游戏的主循环，即一个调用_check_events()、ship.update()和_update_screen()的while循环。 ⏱ 2022-05-14 19:47:55</p></blockquote><blockquote><p>📌 要玩游戏《外星人入侵》，只需运行文件alien_invasion.py，其他文件（settings.py和ship.py）包含的代码会被导入这个文件中。 ⏱ 2022-05-14 19:48:22</p></blockquote>',176)])])}const h=t(c,[["render",u]]);export{i as __pageData,h as default};
