import{_ as t,o as e,c as a,a6 as l}from"./chunks/framework.BB0md0jN.js";const h=JSON.parse('{"title":"人人都懂设计模式：从生活中领悟设计模式（Python实现）","description":"","frontmatter":{"layout":"doc","title":"人人都懂设计模式：从生活中领悟设计模式（Python实现）","readingTime":"11 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/人人都懂设计模式_从生活中领悟设计模式Python实现.md","filePath":"电影和阅读/微信读书/人人都懂设计模式_从生活中领悟设计模式Python实现.md"}'),r={name:"电影和阅读/微信读书/人人都懂设计模式_从生活中领悟设计模式Python实现.md"};function c(n,o,p,u,i,q){return e(),a("div",null,[...o[0]||(o[0]=[l('<h1 id="人人都懂设计模式-从生活中领悟设计模式-python实现" tabindex="-1">人人都懂设计模式：从生活中领悟设计模式（Python实现） <a class="header-anchor" href="#人人都懂设计模式-从生活中领悟设计模式-python实现" aria-label="Permalink to &quot;人人都懂设计模式：从生活中领悟设计模式（Python实现）&quot;">​</a></h1><p><img src="https://cdn.weread.qq.com/weread/cover/68/YueWen_25449864/t6_YueWen_25449864.jpg" alt=" 人人都懂设计模式：从生活中领悟设计模式（Python实现）"></p><ul><li><strong>书名</strong>： 人人都懂设计模式：从生活中领悟设计模式（Python实现）</li><li><strong>作者</strong>： 罗伟富</li><li><strong>简介</strong>： 设计模式（Design Pattern）是一套被反复使用、多数人知晓、无数工程师实践的代码设计经验的总结，它是面向对象思想的高度提炼和模板化。 本书带你一起从生活的角度思考设计模式，以轻松有趣的小故事开始，由浅入深地讲解每一种模式，思考每一种模式，总结每一种模式！力求用更通俗的语言阐述难懂的概念，用更简单的语法实现复杂的逻辑，用更短小的代码写出强悍的程序！ 使枯燥乏味的概念变得更有乐趣和意义，希望能带给读者一种全新的阅读体验和思考方式。 本书首先讲解了23种经典设计模式，其中19 种在现今的软件开发中常用的设计模式分别用单独的章节进行了详细讲解，剩余设计模式作为一个合集放在一章中进行了讲解；其次讲解了对基础设计模式的衍生，也是各大编程语言中非常重要而常见的各种编程机制，如过滤器模式、对象池技术、回调机制和MVC模式；最后作者结合自身的工作经验和项目积累，分享了他对设计模式、设计原则、项目重构的理解和看法。Python作为AI时代最重要的一种计算机语言，其在各大语言中的排名也逐年上升！本书所有示例代码均用Python编写，将会是国内不可多得的一本用Python来讲解设计模式的书。 本书适合的读者：一线互联网软件开发者、有一定编程基础的IT新人、对设计模式和编程思想感兴趣的人士。</li><li><strong>出版时间</strong>： 2019-04-01 00:00:00</li><li><strong>ISBN</strong>： 9787121361128</li><li><strong>分类</strong>： 计算机-编程设计</li><li><strong>出版社</strong>： 电子工业出版社</li><li><strong>PC地址</strong>： <a href="https://weread.qq.com/web/reader/e72323d071845588e729af0" target="_blank" rel="noreferrer">https://weread.qq.com/web/reader/e72323d071845588e729af0</a></li></ul><h2 id="基础篇" tabindex="-1">基础篇 <a class="header-anchor" href="#基础篇" aria-label="Permalink to &quot;基础篇&quot;">​</a></h2><blockquote><p>📌 List（列表）是Python中使用最频繁的数据类型，用“[]”标识。列表可以完成大多数集合类的数据结构实现，类似于Java中的ArrayList和C++中的Vector。 ⏱ 2023-07-27 21:01:28</p></blockquote><blockquote><p>📌 Tuple（元组）是另一种数据类型，用“（）”标识，内部元素用逗号隔开。元组不能二次赋值，相当于只读列表，用法与List类似。Tuple相当于Java中的final数组和C++中的const数组。 ⏱ 2023-07-27 21:01:41</p></blockquote><blockquote><p>📌 相当于Java和C++中的Map。 ⏱ 2023-07-27 21:02:13</p></blockquote><blockquote><p>📌 列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典中的元素通过键存取，而不通过偏移存取。 ⏱ 2021-05-19 03:15:15</p></blockquote><blockquote><p>📌 _foo：以单下画线开头时表示的是 protected 类型的变量，即保护类型只允许其本身与子类进行访问，不能用于 from module import *。● __foo：以双下画线开头时，表示的是私有类型（private）的变量，即只允许这个类本身进行访问。 ⏱ 2023-07-27 21:03:36</p></blockquote><blockquote><p>📌 不能在派生类中找到对应的方法时，它才开始到基类中逐个查找（先在本类中查找调用的方法，找不到才去基类中找）。 ⏱ 2023-07-27 21:06:49</p></blockquote><blockquote><p>📌 其中类图是应用最广泛的一种图，经常被用于软件架构设计中。 ⏱ 2023-07-27 23:05:32</p></blockquote><blockquote><p>📌 类图用于表示不同的实体（人、事物和数据），以及它们彼此之间的关系。该图描述了系统中对象的类型以及它们之间存在的各种静态关系，是一切面向对象方法的核心建模工具。 ⏱ 2024-08-08 20:24:48</p></blockquote><blockquote><p>📌 泛化（Generalization）是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。 ⏱ 2024-08-08 20:25:40</p></blockquote><blockquote><p>📌 实现（Realization）是一种类与接口的关系，表示类是接口所有特征和行为的实现。 ⏱ 2024-08-08 20:25:54</p></blockquote><h3 id="第1章-监听模式" tabindex="-1">第1章 监听模式 <a class="header-anchor" href="#第1章-监听模式" aria-label="Permalink to &quot;第1章 监听模式&quot;">​</a></h3><blockquote><p>📌 在对象间定义一种一对多的依赖关系，当这个对象状态发生改变时，所有依赖它的对象都会被通知并自动更新。 ⏱ 2024-08-09 09:39:29</p></blockquote><blockquote><p>📌 监听模式的核心思想就是在被观察者与观察者之间建立一种自动触发的关系。 ⏱ 2024-08-09 09:40:30</p></blockquote><blockquote><p>📌 不管用户想不想知道，也不管用户会不会在这期间访问App，消息都需要被准确无误地发送到。这就是典型的推模型的应用。 ⏱ 2024-08-11 22:04:48</p></blockquote><blockquote><p>📌 拉模型：被观察者在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到被观察者对象中获取，相当于观察者从被观察者对象中拉数据。 ⏱ 2024-08-11 22:05:05</p></blockquote><blockquote><p>📌 比如手机中的各种App的消息推送，服务端是被观察者，各个手机App 是观察者，一旦服务器上的数据（如 App 升级信息）有更新，就会被推送到手机客户端。在这个应用中你会发现服务器代码和App客户端代码其实是两套完全不一样的代码，它们是通过网络接口进行通信的，所以如果你只停留在代码层面是无法理解的 ⏱ 2024-08-11 22:09:08</p></blockquote><h3 id="第2章-状态模式" tabindex="-1">第2章 状态模式 <a class="header-anchor" href="#第2章-状态模式" aria-label="Permalink to &quot;第2章 状态模式&quot;">​</a></h3><blockquote><p>📌 状态模式的核心思想就是一个事物（对象）有多种状态，在不同的状态下所表现出来的行为和属性不一样。 ⏱ 2024-08-11 22:11:35</p></blockquote><blockquote><p>📌 ）在实现状态模式的时候，实现的场景状态有时候会非常复杂，决定状态变化的因素也非常多，我们可以把决定状态变化的属性单独抽象成一个类 StateInfo，这样判断状态属性是否符合当前的状态isMatch时就可以传入更多的信息。（2）每一种状态应当只有唯一的实例 ⏱ 2024-08-11 22:21:10</p></blockquote><blockquote><p>📌 1）封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类中，对状态转换代码进行集中管理，而不是分散在一个个业务逻辑中。（2）将所有与某个状态有关的行为放到一个类中（称为状态类），使开发人员只专注于该状态下的逻辑开发。 ⏱ 2024-08-11 22:23:34</p></blockquote><blockquote><p>📌 ）允许状态转换逻辑与状态对象合为一体，使用时只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。 ⏱ 2024-08-11 22:23:55</p></blockquote><blockquote><p>📌 ）一个操作中含有庞大的多分支的条件语句，这些分支依赖于该对象的状态，且每一个分支的业务逻辑都非常复杂时，我们可以使用状态模式来拆分不同的分支逻辑，使程序有更好的可读性和可维护性。 ⏱ 2024-08-11 22:24:34</p></blockquote><h3 id="第3章-中介模式" tabindex="-1">第3章 中介模式 <a class="header-anchor" href="#第3章-中介模式" aria-label="Permalink to &quot;第3章 中介模式&quot;">​</a></h3><blockquote><p>📌 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 ⏱ 2024-08-11 22:40:20</p></blockquote><h3 id="第4章-装饰模式" tabindex="-1">第4章 装饰模式 <a class="header-anchor" href="#第4章-装饰模式" aria-label="Permalink to &quot;第4章 装饰模式&quot;">​</a></h3><blockquote><p>📌 对象功能来说，装饰模式比生成子类的方式更为灵活。 ⏱ 2024-08-11 22:43:51</p></blockquote><h3 id="第5章-单例模式" tabindex="-1">第5章 单例模式 <a class="header-anchor" href="#第5章-单例模式" aria-label="Permalink to &quot;第5章 单例模式&quot;">​</a></h3><blockquote><p>📌 确保一个类只有一个实例，并且提供一个访问它的全局方法 ⏱ 2024-08-11 22:45:55</p></blockquote>',32)])])}const s=t(r,[["render",c]]);export{h as __pageData,s as default};
