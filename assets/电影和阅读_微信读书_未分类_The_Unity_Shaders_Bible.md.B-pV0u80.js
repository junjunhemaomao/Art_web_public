import{_ as o,o as t,c as a,a6 as r}from"./chunks/framework.BB0md0jN.js";const d=JSON.parse('{"title":"The Unity Shaders Bible","description":"","frontmatter":{"layout":"doc","title":"The Unity Shaders Bible","readingTime":"15 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/未分类/The_Unity_Shaders_Bible.md","filePath":"电影和阅读/微信读书/未分类/The_Unity_Shaders_Bible.md"}'),i={name:"电影和阅读/微信读书/未分类/The_Unity_Shaders_Bible.md"};function n(l,e,c,s,u,h){return t(),a("div",null,[...e[0]||(e[0]=[r('<h1 id="the-unity-shaders-bible" tabindex="-1">The Unity Shaders Bible <a class="header-anchor" href="#the-unity-shaders-bible" aria-label="Permalink to &quot;The Unity Shaders Bible&quot;">​</a></h1><p><img src="https://res.weread.qq.com/wrepub/CB_DGX1bx1cSBcy6hQ6gY6VFBOX_parsecover" alt=" The Unity Shaders Bible"></p><ul><li><strong>书名</strong>： The Unity Shaders Bible</li><li><strong>作者</strong>： Jettelly</li><li><strong>简介</strong>： &gt; - 出版时间：</li><li><strong>ISBN</strong>： &gt; - 分类：</li><li><strong>出版社</strong>： &gt; - PC地址：<a href="https://weread.qq.com/web/reader/d2842c43643425f444758316278316353426379366851366759365646424f58fb8" target="_blank" rel="noreferrer">https://weread.qq.com/web/reader/d2842c43643425f444758316278316353426379366851366759365646424f58fb8</a></li></ul><h2 id="_1-0-2-vertices" tabindex="-1">1.0.2. | Vertices. <a class="header-anchor" href="#_1-0-2-vertices" aria-label="Permalink to &quot;1.0.2. | Vertices.&quot;">​</a></h2><blockquote><p>📌 我们可以在着色器中独立访问所有这些属性，并将它们保存在向量中（例如，float4 pos: POSITION【n】）。这样做很有好处，因为我们可以修改它们的值，从而产生令人兴奋的效果。 ⏱ 2024-06-13 20:14:37</p></blockquote><blockquote><p>📌 这些点有两个主要特点：1. They are children of the transform component. 1.它们是转换组件的子组件。2. They have a defined position according to the center of the total volume of the object. 2. 根据物体总体积的中心，它们有明确的位置。 ⏱ 2024-06-13 20:16:41</p></blockquote><blockquote><p>📌 在Maya 3D中，有两个默认节点与对象相关联。这些节点被称为变换和形状。 ⏱ 2024-06-13 20:17:09</p></blockquote><blockquote><p>📌 这意味着我们可以移动、旋转或缩放对象的一组顶点，但同时，我们可以改变特定点或顶点的位置。 ⏱ 2024-06-13 20:17:55</p></blockquote><h2 id="_1-0-4-tangents" tabindex="-1">1.0.4. | Tangents. <a class="header-anchor" href="#_1-0-4-tangents" aria-label="Permalink to &quot;1.0.4. | Tangents.&quot;">​</a></h2><blockquote><p>📌 在我们的着色器中，我们可以访问这个属性，以便在 3D 模型上定位纹理或在其中保存信息。 ⏱ 2024-06-13 22:01:14</p></blockquote><h2 id="_1-0-6-vertex-color" tabindex="-1">1.0.6. | Vertex color. <a class="header-anchor" href="#_1-0-6-vertex-color" aria-label="Permalink to &quot;1.0.6. | Vertex color.&quot;">​</a></h2><blockquote><p>📌 当我们从 3D 软件中导出对象时，它会为对象分配一种颜色，该颜色要么受光照影响，要么复制另一种颜色。这种颜色称为顶点颜色，默认情况下与白色相对应，在 RGBA 通道中具有值“一”。 ⏱ 2024-06-13 22:02:21</p></blockquote><h2 id="_1-0-8-application-stage" tabindex="-1">1.0.8. | Application Stage. <a class="header-anchor" href="#_1-0-8-application-stage" aria-label="Permalink to &quot;1.0.8. | Application Stage.&quot;">​</a></h2><blockquote><p>📌 该阶段分为四个子过程：顶点着色、投影、裁剪和屏幕映射。 ⏱ 2024-08-21 23:13:44</p></blockquote><h2 id="_1-1-0-rasterization-stage" tabindex="-1">1.1.0. | Rasterization stage. <a class="header-anchor" href="#_1-1-0-rasterization-stage" aria-label="Permalink to &quot;1.1.0. | Rasterization stage.&quot;">​</a></h2><blockquote><p>📌 找到所有被屏幕对象占据的像素的过程称为光栅化。这个过程可以看作是我们场景中的对象和屏幕上的像素之间的同步步骤 ⏱ 2024-08-21 23:15:25</p></blockquote><blockquote><p>📌 三角形遍历列表显示了由多边形对象区域覆盖的像素。 ⏱ 2024-08-21 23:17:46</p></blockquote><h2 id="_1-1-1-pixel-processing-stage" tabindex="-1">1.1.1. | Pixel processing stage. <a class="header-anchor" href="#_1-1-1-pixel-processing-stage" aria-label="Permalink to &quot;1.1.1. | Pixel processing stage.&quot;">​</a></h2><blockquote><p>📌 最后阶段在所有像素准备好投影到屏幕上时开始。此时，片段着色器阶段（也称为像素着色器阶段）开始，并负责每个像素的可视性。 ⏱ 2024-08-21 23:18:17</p></blockquote><blockquote><p>📌 基本上，它所做的就是计算像素的最终颜色，然后将其发送到颜色缓冲区。 ⏱ 2024-08-21 23:18:32</p></blockquote><blockquote><p>📌 这些路径的示例包括正向渲染、延迟着色、遗留延迟和遗留顶点着色。每种方法都有不同的功能和性能特征。 ⏱ 2024-08-21 23:20:08</p></blockquote><blockquote><p>📌 在Unity中，默认的渲染路径对应于正向渲染；这是Unity中包括的三种管线渲染的初始路径。这是因为它具有更大的显卡兼容性和光照计算限制，使其成为更优化的过程。 ⏱ 2024-08-21 23:25:05</p></blockquote><blockquote><p>📌 选择主摄像机，在“渲染路径”属性中，我们can change the configuration according to the needs of our project). 可以根据我们项目的需要更改配置）。 ⏱ 2024-08-21 23:26:37</p></blockquote><h2 id="_1-1-3-forward-rendering" tabindex="-1">1.1.3. | Forward rendering. <a class="header-anchor" href="#_1-1-3-forward-rendering" aria-label="Permalink to &quot;1.1.3. | Forward rendering.&quot;">​</a></h2><blockquote><p>📌 基本照明模型对应于三个不同属性的总和，即环境颜色、漫反射和镜面反射。 ⏱ 2024-08-21 23:27:20</p></blockquote><blockquote><p>📌 这个渲染路径有两个不同的代码编写通道，我们可以在我们的着色器中使用，第一个是基本通道，第二个是附加通道。 ⏱ 2024-08-21 23:28:46</p></blockquote><blockquote><p>📌 附加通道可以处理每个像素的“附加灯光”，也可以处理影响物体的阴影，这意味着什么？如果我们场景中有两个灯光，我们的对象只会受到其中一个的影响，但是，如果我们为这种配置定义了附加通道，那么它将受到两个灯光的影响。 ⏱ 2024-08-21 23:30:54</p></blockquote><blockquote><p>📌 我们必须考虑的一点是，每个照亮的通道都会生成一个单独的绘制调用。 ⏱ 2024-08-21 23:31:25</p></blockquote><blockquote><p>📌 确定基元着色器之后，如果我们在着色器中添加另一个着色器，那么我们将为每个对象添加一个新的绘制调用，因此图形负载将显著增加。 ⏱ 2024-08-22 09:20:06</p></blockquote><h2 id="_1-1-4-deferred-shading" tabindex="-1">1.1.4. | Deferred shading. <a class="header-anchor" href="#_1-1-4-deferred-shading" aria-label="Permalink to &quot;1.1.4. | Deferred shading.&quot;">​</a></h2><blockquote><p>📌 这种渲染路径确保了场景中的每个光源都只经过一次光照计算，并且只在受其影响的像素上进行，这一切都是通过几何图形和光照的分离来实现的。 ⏱ 2024-08-22 09:21:00</p></blockquote><blockquote><p>📌 在多光源计算方面，延迟着色优于前向着色，但它带来了一些硬件兼容性限制和问题。 ⏱ 2024-08-22 09:20:51</p></blockquote><h2 id="_1-1-6-matrices-and-coordinates-systems" tabindex="-1">1.1.6. | Matrices and coordinates systems. <a class="header-anchor" href="#_1-1-6-matrices-and-coordinates-systems" aria-label="Permalink to &quot;1.1.6. | Matrices and coordinates systems.&quot;">​</a></h2><blockquote><p>📌 Shader Graph 有独立于 Unity 版本的版本和更新。 ⏱ 2024-08-22 09:25:07</p></blockquote><blockquote><p>📌 在Unity中创建着色器的最佳方式是通过HLSL语言，因为这样我们可以确保我们的程序在不同的渲染管道中编译，并且无论Unity升级如何，都可以继续工作。 ⏱ 2024-08-22 09:25:19</p></blockquote><blockquote><p>📌 在Unity中，矩阵表示空间变换，其中我们可以找到： ⏱ 2024-08-22 09:27:57</p></blockquote><blockquote><p>📌 所有这些都对应于四乘四矩阵（4x4），即它们中的每一个都有四个行和四个列的数字值。 ⏱ 2024-08-22 09:25:47</p></blockquote><blockquote><p>📌 模型矩阵（UNITY_MATRIX _M），它允许我们修改变换、旋转 ⏱ 2024-08-22 09:35:51</p></blockquote><blockquote><p>📌 以及对象顶点的缩放值。每次我们旋转、改变位置或缩放对象时，模型矩阵都会更新， ⏱ 2024-08-22 09:36:03</p></blockquote><blockquote><p>📌 在矩阵变换中，W坐标可以具有“零或一”的值。当W等于一（例如X，Y，Z，1）时，它指的是空间中的一个点，而当它等于零（例如X，Y，Z,0）时，它指的是空间中的一个方向。 ⏱ 2024-08-22 09:27:27</p></blockquote><blockquote><p>📌 关于矩阵需要考虑的要素之一是，只有在第一矩阵的列数等于第二矩阵的行数时才能进行乘法运算。我们已经知道，我们的模型矩阵有四行四列。columns (4x4), and the vertex position has a dimension of four rows and one column (4x1). 列（4x4），顶点位置具有4行1列（4x1）的维数。Since the number of columns in the model matrix is equal to the number of rows in the 由于模型矩阵中的列数等于vertex position, they can be multiplied and the result will be equal to a new matrix of four rows and one column (4x1), which would define a new vertex position. This multiplication process occurs for all vertices in our object, and this process is carried out in the vertex shader stage in our shader. 顶点位置，它们可以相乘，结果将等于一个四行一列（4x1）的新矩阵，这将定义一个新的顶点位置。这个过程发生在我们的对象中的所有顶点上，这个过程发生在我们的着色器中的顶点着色器阶段。 ⏱ 2024-08-22 09:31:43</p></blockquote><blockquote><p>📌 场景中的网格点 XYZW 【0,0,0,1】 与对象中顶点的位置之间的距离。如果我们想将空间坐标从对象空间转换到世界空间，可以使用内置着色器变量 unity_ObjectToWorld。 ⏱ 2024-08-22 09:33:02</p></blockquote><blockquote><p>📌 视图空间是指我们的对象顶点相对于相机视图的位置。如果我们想将世界空间坐标转换为视图空间坐标，可以使用UNITY_MATRIX_VP矩阵。 ⏱ 2024-08-22 09:35:25</p></blockquote><blockquote><p>📌 最后，裁剪空间，也称为投影空间，是指我们的对象顶点相对于相机视锥的位置，因此，这个因素将受到相机近clipping plane, far clipping plane and field of view. Again, if we want to transform a space coordinate from view-space to clip-space, we can do it using the UNITY_MATRIX_P matrix. 裁剪平面、远裁剪平面和视场。同样，如果我们想将空间坐标从视空间转换到裁剪空间，我们可以使用 UNITY_MATRIX _P 矩阵。 ⏱ 2024-08-22 09:38:49</p></blockquote><blockquote><p>📌 ，内置着色器变量 UNITY _ MATRIX _ MVP 表示三个不同矩阵的乘积。M 表示模型矩阵，V 表示视图矩阵，P 表示投影矩阵。该矩阵主要用于将对象的顶点从对象空间转换到裁剪空间。 ⏱ 2024-08-22 09:39:35</p></blockquote><blockquote><p>📌 我们的多边形对象是在“三维”环境中创建的，而我们将投影的计算机屏幕是“二维”的，因此我们需要将对象从一种空间转换到另一种空间。 ⏱ 2024-08-22 09:39:47</p></blockquote><h2 id="shaders-in-unity" tabindex="-1">Shaders in Unity. <a class="header-anchor" href="#shaders-in-unity" aria-label="Permalink to &quot;Shaders in Unity.&quot;">​</a></h2><blockquote><p>📌 着色器是一个具有“.shader”扩展名的小型程序（例如，color.shader），可用于在我们的项目中生成有趣的效果。内部，它具有数学计算和指令（命令）列表，允许对计算机屏幕上覆盖对象的区域内的每个像素进行颜色处理。 ⏱ 2024-08-22 09:41:16</p></blockquote><blockquote><p>📌 Unity 有三种与着色器相关的文件类型。首先，我们有具有“.shader”扩展名的程序，这些程序能够在不同的渲染管线中进行编译。 ⏱ 2024-08-22 09:41:58</p></blockquote><blockquote><p>📌 其次，我们有“.shadergraph”扩展名的程序，只能在通用 RP 或高清晰度 RP 中编译。此外，我们还有“.hlsl”扩展名的文件，允许我们创建自定义函数；通常在名为Custom Function, found in Shader Graph. 自定义函数，可在着色器图中找到。 ⏱ 2024-08-22 09:42:18</p></blockquote><blockquote><p>📌 还有一种扩展名为“.cginc”的程序，我们稍后会详细讨论。目前，我们只限于做出以下关联：“.cginc”与“.shader” CGPROGRAM相关联，“.hlsl”与“.shadergraph” HLSL PROGRAM相关联。 ⏱ 2024-08-22 09:50:01</p></blockquote><blockquote><p>📌 知道这个类比是非常基本的，因为每个扩展都具有不同的功能，并在特定的上下文中使用。 ⏱ 2024-08-22 09:52:08</p></blockquote><h2 id="_2-0-2-introduction-to-the-programming-language" tabindex="-1">2.0.2. | Introduction to the programming language. <a class="header-anchor" href="#_2-0-2-introduction-to-the-programming-language" aria-label="Permalink to &quot;2.0.2. | Introduction to the programming language.&quot;">​</a></h2><blockquote><p>📌 [插图]</p></blockquote><p>In Unity, there are at least four types of structures defined to generate shaders, among which we can find the combination of vertex shader and fragment shader then surface shader</p><p>在Unity中，至少定义了四种类型的结构来生成着色器，其中我们可以找到顶点着色器和片段着色器的组合，然后是表面着色器</p><p>for automatic lighting calculation and compute shader for more advanced concepts.</p><p>用于自动照明计算和计算着色器的更高级概念。</p><p>Each of these structures has previously described properties and functions that facilitate the compilation process; we can also easily define our operations, since the software adds these structures automatically.</p><p>这些结构中的每一个以前都描述了属性和功能，这些属性和功能有助于编译过程；由于软件会自动添加这些结构，因此我们也可以轻松地定义我们的操作。</p><p>2.0.2. | Introduction to the programming language.</p><p>2.0.2. | 介绍编程语言。</p><p>Before starting in the definition of code, we must take into consideration that in Unity there are three programming languages associated with shader development, these are HLSL (High-Level Shader Language - Microsoft), Cg (C for Graphics - NVIDIA) which still compiles into the shader but is no longer used in current versions of the software, and ShaderLab (declarative language -Unity).</p><blockquote><p>⏱ 2024-08-22 09:51:28</p></blockquote><h2 id="_3-0-9-mpd-keywordenum" tabindex="-1">3.0.9. | MPD KeywordEnum. <a class="header-anchor" href="#_3-0-9-mpd-keywordenum" aria-label="Permalink to &quot;3.0.9. | MPD KeywordEnum.&quot;">​</a></h2><blockquote><p>📌 shader_feature只会从材质检查器中导出选定的变体，而multi_compile会导出在着色器中找到的所有变体，不管它们是否被使用。考虑到这个特性，multi_compile非常适合导出或编译在执行时会改变的多个状态（例如超级马里奥中的star status）​。 ⏱ 2024-08-22 18:17:20</p></blockquote>',66)])])}const b=o(i,[["render",n]]);export{d as __pageData,b as default};
