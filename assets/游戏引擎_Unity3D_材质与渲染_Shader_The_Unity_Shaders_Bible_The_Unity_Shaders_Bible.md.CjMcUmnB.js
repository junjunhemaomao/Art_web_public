import{_ as a,o as r,c as t,a6 as i}from"./chunks/framework.DZKVy2Mg.js";const o="/Art_web_public/assets/20240822113003.C35xTyGU.png",s="/Art_web_public/assets/20240822121123.Dk32FYkk.png",l="/Art_web_public/assets/20240822154841.C1Lxe2gX.png",p="/Art_web_public/assets/20240822154905.GZJtuWG0.png",n="/Art_web_public/assets/20240822161121.B3FOMSL8.png",d="/Art_web_public/assets/20240822162236.CItRJPyJ.png",h="/Art_web_public/assets/20240822163650.WSiwm2pB.png",u="/Art_web_public/assets/20240822164004.JFnuRpEh.png",m="/Art_web_public/assets/20240822171158.Bzq5Hxfk.png",c="/Art_web_public/assets/20240822173656.oA7g_90i.png",_="/Art_web_public/assets/20240822181749.C45cb6WS.png",w=JSON.parse('{"title":"","description":"","frontmatter":{"readingTime":"9 min read"},"headers":[],"relativePath":"游戏引擎/Unity3D/材质与渲染/Shader/The_Unity_Shaders_Bible/The_Unity_Shaders_Bible.md","filePath":"游戏引擎/Unity3D/材质与渲染/Shader/The_Unity_Shaders_Bible/The_Unity_Shaders_Bible.md"}'),b={name:"游戏引擎/Unity3D/材质与渲染/Shader/The_Unity_Shaders_Bible/The_Unity_Shaders_Bible.md"};function g(y,e,q,P,S,f){return r(),t("div",null,[...e[0]||(e[0]=[i('<h4 id="unity-有三种与着色器相关的文件类型。" tabindex="-1">Unity 有三种与着色器相关的文件类型。 <a class="header-anchor" href="#unity-有三种与着色器相关的文件类型。" aria-label="Permalink to &quot;Unity 有三种与着色器相关的文件类型。&quot;">​</a></h4><ul><li>“.shader”扩展名的程序</li><li>“.shadergraph”扩展名的程序（只能在Universal RP 或High Definition RP 中编译。）</li><li>“.hlsl”扩展名的文件，允许创建自定义函数</li><li>“.cginc”的程序，我们稍后会详细讨论。</li></ul><p>​“.cginc”与“.shader” CGPROGRAM相关联，​“.hlsl”与“.shadergraph”HLSL PROGRAM相关联。<br><img src="'+o+'" alt=""><br> Unity中有三种与着色器开发相关的编程语言:</p><ul><li>HLSL（高级着色语言-微软）​</li><li>Cg（C图形-NVIDIA）​，它仍然可以编译成着色器，但不再用于当前版本的软件</li><li>ShaderLab（声明性语言-Unity）​ <img src="" alt=""> 软件会自动添加这些结构，因此我们也可以轻松地定义我们的操作。</li></ul><p>Cg是一种高级编程语言，专为在大多数GPU上编译而设计，由NVIDIA与微软合作开发，其语法与HLSL非常相似。 着色器使用 Cg 语言的原因是它们可以同时编译 HLSL 和 GLSL（OpenGL 着色语言）​，加快和优化视频游戏创建材质的过程。</p><p>当我们创建一个着色器时，我们的代码会编译到一个名为 CGPROGRAM 的字段中。Unity 目前正在努力在 Cg 和 HLSL 之间提供进一步的支持和兼容性，因此这些块很可能很快就会被 HLSLPROGRAM 和 ENDHLSL 所取代。因为HLSL是Unity当前版本（2019版及更高版本）的官方着色器编程语言。</p><p>Unity 中的所有着色器（Shader Graph 和 Compute 除外）都使用一种称为ShaderLab 的声明性语言编写。这种语言的语法允许您在 Unity 检查器中显示着色器的属性。</p><p>Fallback 是多平台游戏中的一个基本代码块，如果着色器在编译过程中出现问题，Fallback 会返回一个不同的着色器，这样图形硬件就可以继续其工作了。</p><p>SubShader是ShaderLab中的另一个块，它允许我们声明命令和生成通道。使用 Cg/HLSL 编写的着色器可以包含多个 SubShader。 但是，对于可编程 RP（Scriptable RP），一个着色器只能包含一个子着色器。</p><hr><p><img src="'+s+'" alt=""></p><h4 id="image-effect-shader" tabindex="-1">Image effect shader <a class="header-anchor" href="#image-effect-shader" aria-label="Permalink to &quot;Image effect shader&quot;">​</a></h4><p>它在结构上非常类似于无光着色器。图像效果主要用于内置RP中的后处理效果post-processing，需要&quot;OnRenderImage&quot;（C#）函数。</p><h4 id="compute-shader" tabindex="-1">Compute shader <a class="header-anchor" href="#compute-shader" aria-label="Permalink to &quot;Compute shader&quot;">​</a></h4><p>与普通着色器不同，它的扩展名是“.compute”​，程序设计语言是<strong>HLSL</strong>。在特定情况下使用，以加快一些游戏处理。</p><h4 id="ray-tracing-shader" tabindex="-1">Ray tracing shader <a class="header-anchor" href="#ray-tracing-shader" aria-label="Permalink to &quot;Ray tracing shader&quot;">​</a></h4><p>光线追踪着色器是一种实验性的程序，扩展名为“​.raytrace”​。它允许在GPU上进行光线跟踪处理。它只适用于HDRP，具有一定的技术局限性。必须至少有一个GTX 1080显卡或具有RTX支持的同等显卡，Windows 10版本1809+ 和Unity 2019.3b1及更高版本</p><hr><h2 id="顶点-片段着色器的结构" tabindex="-1">顶点/片段着色器的结构 <a class="header-anchor" href="#顶点-片段着色器的结构" aria-label="Permalink to &quot;顶点/片段着色器的结构&quot;">​</a></h2><p>GPU将从上到下线性地读取程序，下图是一个结构正确的例子<br><img src="'+l+'" alt=""><br> 下图的反面例子编译会报错，是因为在前面的函数引用了后面定义的函数<br><img src="'+p+'" alt=""></p><h4 id="shaderlab属性" tabindex="-1">ShaderLab属性 <a class="header-anchor" href="#shaderlab属性" aria-label="Permalink to &quot;ShaderLab属性&quot;">​</a></h4><blockquote><h5 id="propertyname-display-name-type-defaultvalue" tabindex="-1">PropertyName (&quot;display name&quot;, type) = defaultValue. <a class="header-anchor" href="#propertyname-display-name-type-defaultvalue" aria-label="Permalink to &quot;PropertyName (&quot;display name&quot;, type) = defaultValue.&quot;">​</a></h5><p>属性名称（&quot;显示名称，类型&quot;）=默认值。</p></blockquote><p>PropertyName”指的是属性的名称（例如_MainTex）​，是程序传递的变量名 ​“显示名称”对应的是将显示在Unity检查器中的属性的名称。 “type”表示属性类型（如颜色、矢量、2D等）​</p><h5 id="数字和滑块属性" tabindex="-1">数字和滑块属性 <a class="header-anchor" href="#数字和滑块属性" aria-label="Permalink to &quot;数字和滑块属性&quot;">​</a></h5><p><img src="'+n+'" alt=""></p><h5 id="颜色和矢量属性" tabindex="-1">颜色和矢量属性 <a class="header-anchor" href="#颜色和矢量属性" aria-label="Permalink to &quot;颜色和矢量属性&quot;">​</a></h5><p>有了这个属性，我们可以在我们的着色器中定义颜色和向量<br><img src="'+d+'" alt=""></p><h4 id="纹理属性" tabindex="-1">纹理属性 <a class="header-anchor" href="#纹理属性" aria-label="Permalink to &quot;纹理属性&quot;">​</a></h4><p>这些属性允许我们在着色器中实现纹理<br><img src="'+h+'" alt=""><br> 当声明一个属性时，它将用ShaderLab声明性语言编写，而我们的程序将用Cg或HLSL语言编写。 为它们是两种不同的语言，我们必须创建“连接变量”​。</p><p>这些变量使用“uniform”一词进行全局声明，然而，这一步可以跳过，因为程序将其识别为全局变量。因此，要添加一个属性到一个“.shader”​，我们必须首先声明属性在ShaderLab，然后在Cg或HLSL使用相同的名称的全局变量，然后我们可以使用它。<br><img src="'+u+'" alt=""></p><h4 id="drawers属性" tabindex="-1">drawers属性 <a class="header-anchor" href="#drawers属性" aria-label="Permalink to &quot;drawers属性&quot;">​</a></h4><p>这个类允许我们在Unity Inspector中生成自定义属性，从而促进了着色器中条件的编程。默认情况下，这种类型的属性不包括在我们的着色器中，相反，我们必须根据我们的需要来声明它们。到目前为止，有七个不同的： • Toggle.·切换开关 • Enum.·枚举 • KeywordEnum.·关键字枚举 • PowerSlider.·PowerSlider幻灯片 • IntRange.·内部范围内的 • Header.·标头</p><p>由于这些属性，我们可以在我们的程序中生成多个状态，允许创建动态效果，而不需要在执行时改变材质。通常将这些抽屉与两种类型的着色器变体一起使用，它们是指#pragma multi_compile 和#pragma shader_feature. <img src="'+m+'" alt=""></p><h4 id="mpd切换-mpd-toggle" tabindex="-1">MPD切换(MPD Toggle) <a class="header-anchor" href="#mpd切换-mpd-toggle" aria-label="Permalink to &quot;MPD切换(MPD Toggle)&quot;">​</a></h4><p>在ShaderLab我们不能使用布尔类型的属性，相反，我们有切换，履行相同的功能。允许使用着色器中的条件从一种状态切换到另一种状态。 它的默认值必须是一个整数，因为0代表关，1代表开。 想在代码中实现它，我们将不得不使用#pragma shader_feature。</p><blockquote><p>[Toggle] _PropertyName (&quot;Display Name&quot;, Float) = 0</p></blockquote><p><img src="'+c+'" alt=""><br> 在shader_feature中添加的变体是&quot;常量&quot;，因此它们以大写形式书写，这意味着，例如，如果我们的属性被称为_Change，那么在shader变体中，它应该被添加为&quot;_CHANGE&quot;。单词_ON对应于Toggle的默认状态。 值得一提的是，shader_feature不能为一个应用程序编译多个变体，这是什么意思？Unity将不会包含我们在最终构建中没有使用的变体，这意味着我们将无法在执行时从一种状态转移到另一种状态。为此，我们将不得不使用KeywordEnum drawer，它具有变体着色器&quot;multi_compile&quot;。</p><h4 id="mpd关键字枚举-mpd-keywordenum" tabindex="-1">MPD关键字枚举（MPD KeywordEnum） <a class="header-anchor" href="#mpd关键字枚举-mpd-keywordenum" aria-label="Permalink to &quot;MPD关键字枚举（MPD KeywordEnum）&quot;">​</a></h4><p>在材质检查器中生成一个弹出式菜单。与Toggle不同的是，此Drawer允许您为着色器配置多达九种不同的状态。要执行它，我们必须在括号中添加单词“KeywordEnum”​，然后列出我们将要使用的状态集。</p><h4 id="mdp关键字枚举-mdp-keywordenum" tabindex="-1">MDP关键字枚举（MDP KeywordEnum） <a class="header-anchor" href="#mdp关键字枚举-mdp-keywordenum" aria-label="Permalink to &quot;MDP关键字枚举（MDP KeywordEnum）&quot;">​</a></h4><blockquote><p>[KeywordEnum(StateOff, State01, etc...)] _PropertyName (&quot;Display name&quot;, Float) = 0</p></blockquote><p>要在代码中声明这个，我们可以使用着色器变体shader_feature和multi_compile 正如我们已经知道的，shader_feature只会从材质检查器中导出选定的变体，而multi_compile会导出在着色器中找到的所有变体，不管它们是否被使用。考虑到这个特性，multi_compile非常适合导出或编译在执行时会改变的多个状态（例如超级马里奥中的star status）​。<br><img src="'+_+'" alt=""></p>',42)])])}const k=a(b,[["render",g]]);export{w as __pageData,k as default};
