import{_ as i,o as a,c as e,a6 as t}from"./chunks/framework.BB0md0jN.js";const c=JSON.parse('{"title":"游戏架构：核心技术与面试精粹","description":"","frontmatter":{"layout":"doc","title":"游戏架构：核心技术与面试精粹","readingTime":"6 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/教育学习/游戏架构_核心技术与面试精粹.md","filePath":"电影和阅读/微信读书/教育学习/游戏架构_核心技术与面试精粹.md"}'),r={name:"电影和阅读/微信读书/教育学习/游戏架构_核心技术与面试精粹.md"};function o(u,l,n,_,s,p){return a(),e("div",null,[...l[0]||(l[0]=[t('<h1 id="游戏架构-核心技术与面试精粹" tabindex="-1">游戏架构：核心技术与面试精粹 <a class="header-anchor" href="#游戏架构-核心技术与面试精粹" aria-label="Permalink to &quot;游戏架构：核心技术与面试精粹&quot;">​</a></h1><p><img src="https://weread-1258476243.file.myqcloud.com/weread/cover/11/YueWen_23914460/t7_YueWen_23914460.jpg" alt=" 游戏架构：核心技术与面试精粹"></p><ul><li><strong>书名</strong>： 游戏架构：核心技术与面试精粹</li><li><strong>作者</strong>： 樊松阳</li><li><strong>简介</strong>： 本书从架构与封装、艺术资源、底层核心、自定义扩展和独立游戏五个方向组织内容，每一方向均围绕一个问题展开论述，重点讲解了Unity3D开发的高级技巧。这种问答的形式，既有助于读者扩展思考，又可用于面试题。本书除了涉及代码架构和引擎底层原理，还包含了美术资源管理、艺术效果制作、工作流程优化等，通过解析这些实际开发过程中遇到的问题，可以更全面地提升读者的知识储备。书中的大部分章节都附有示例代码，聚焦具体的知识点，让读者知其然并知其所以然。</li><li><strong>出版时间 2018-07-01 00</strong>: 00:00</li><li><strong>ISBN</strong>： 9787121342639</li><li><strong>分类</strong>： 教育学习-教材</li><li><strong>出版社</strong>： 电子工业出版社</li></ul><h2 id="_2-1-游戏循环" tabindex="-1">2.1 游戏循环 <a class="header-anchor" href="#_2-1-游戏循环" aria-label="Permalink to &quot;2.1 游戏循环&quot;">​</a></h2><ul><li><p>📌 主循环分为物理模拟、游戏逻辑、渲染绘制三个子循环。</p><ul><li>⏱ 2020-07-28 15:51:41</li></ul></li><li><p>📌 这三个循环是在同一个线程中的。</p><ul><li>⏱ 2020-07-28 15:53:54</li></ul></li><li><p>📌 而物理模拟循环运行的速度一般要快于游戏逻辑</p><ul><li>⏱ 2020-07-28 15:55:01</li></ul></li><li><p>📌 游戏归根结底是由交互序列组成的，因此它必然会有一个基础的结构：</p><ul><li>⏱ 2020-07-28 16:00:52</li></ul></li><li><p>📌 每次循环完成后，会更新一次画面的绘制，这个过程也被称为帧</p><ul><li>⏱ 2020-07-28 16:01:13</li></ul></li><li><p>📌 帧率（FPS, Frame Per Second）可以标定游戏循环的速率与真实时间的映射关系。帧率值越小，意味着游戏越“卡”。游戏在PC上，通常为60帧/秒，在手机上为30帧/秒。</p><ul><li>⏱ 2020-07-28 16:01:31</li></ul></li><li><p>📌 这种模式可以更好地处理掉帧引发的逻辑问题。大体思路是，当出现掉帧时，只运行逻辑，不绘制画面，用节省下来的时间追赶落后的帧。这种策略会降低图形绘制的频率，但可以保证逻辑的执行。</p><ul><li>⏱ 2020-07-28 17:54:31</li></ul></li><li><p>📌 特定的游戏，通常有自己的特点。例如，竞速类游戏与MMO网游在游戏循环的设计上就有很大的差别。竞速类游戏对实时反馈的要求很高，如果采用追赶模式，则抽帧造成的体验就会很差。在掉帧方面，MMO网游面临的则是角色在场景中漫游时，其他玩家的模型加载与位置同步造成的卡顿。在这种情况下，可能会使用分帧加载、AOI（Area Of Interest）等处理方法来保障游戏的流畅。</p><ul><li>⏱ 2020-07-28 17:53:33</li></ul></li><li><p>📌 因此，游戏循环通常是每个项目根据自己的特点“独家定制”的。在深入理解Unity 3D的生命周期函数后，我们就可以在其基础上，自主独立地搭建个性化的游戏循环框架了。</p><ul><li>⏱ 2020-07-28 17:54:10</li></ul></li></ul><h2 id="_2-2-时间记录" tabindex="-1">2.2 时间记录 <a class="header-anchor" href="#_2-2-时间记录" aria-label="Permalink to &quot;2.2 时间记录&quot;">​</a></h2><ul><li>📌 在掉帧的低端机上，帧率会处于波动状态，这时在编写时间相关的逻辑运算时，就要防止出现与标准帧率不一致的情况。在商业项目中，通常都会编写自己的时间处理类，以得到跨设备准确无误差的时间值。 <ul><li>⏱ 2020-07-28 18:15:43</li></ul></li></ul><h2 id="_3-1-有限状态机" tabindex="-1">3.1 有限状态机 <a class="header-anchor" href="#_3-1-有限状态机" aria-label="Permalink to &quot;3.1 有限状态机&quot;">​</a></h2><ul><li><p>📌 所谓有限，指的是状态有限，所有的状态可枚举出来。它在游戏中运用非常广泛，最常见的就是用于控制角色的状态。</p><ul><li>⏱ 2020-08-03 12:29:12</li></ul></li><li><p>📌 状态机的设计是一个逻辑梳理的过程，建议拿出纸笔画图制作。先将人物所有的状态列出来，然后再用转换连接它们，</p><ul><li>⏱ 2020-08-03 13:22:49</li></ul></li><li><p>📌 HandleInput是转换判断函数，</p><ul><li>⏱ 2020-08-03 13:23:23</li></ul></li></ul><h2 id="_3-2-脚本系统" tabindex="-1">3.2 脚本系统 <a class="header-anchor" href="#_3-2-脚本系统" aria-label="Permalink to &quot;3.2 脚本系统&quot;">​</a></h2><ul><li>📌 在Unity 3D中，我们使用的C#脚本并不属于脚本系统中的脚本范畴。这里的脚本的使用方式与字节码（ByteCode）类似，是在运行时通过虚拟机系统（Virtual Machine）来载入文件，动态更改逻辑影响游戏行为。从本质上讲，它是把行为控制部分从编码层转向了数据层。通过脚本系统，逻辑与行为更灵活地被外部数据控制，程序只负责执行。 <ul><li>⏱ 2020-08-03 14:02:08</li></ul></li></ul>',11)])])}const h=i(r,[["render",o]]);export{c as __pageData,h as default};
