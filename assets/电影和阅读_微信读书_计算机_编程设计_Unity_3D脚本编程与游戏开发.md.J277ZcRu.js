import{_ as e,o as t,c as l,a6 as a}from"./chunks/framework.BB0md0jN.js";const k=JSON.parse('{"title":"Unity 3D脚本编程与游戏开发","description":"","frontmatter":{"layout":"doc","title":"Unity 3D脚本编程与游戏开发","readingTime":"16 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/计算机_编程设计/Unity_3D脚本编程与游戏开发.md","filePath":"电影和阅读/微信读书/计算机_编程设计/Unity_3D脚本编程与游戏开发.md"}'),c={name:"电影和阅读/微信读书/计算机_编程设计/Unity_3D脚本编程与游戏开发.md"};function u(b,o,n,p,i,r){return t(),l("div",null,[...o[0]||(o[0]=[a('<h1 id="unity-3d脚本编程与游戏开发" tabindex="-1">Unity 3D脚本编程与游戏开发 <a class="header-anchor" href="#unity-3d脚本编程与游戏开发" aria-label="Permalink to &quot;Unity 3D脚本编程与游戏开发&quot;">​</a></h1><p><img src="https://cdn.weread.qq.com/weread/cover/37/YueWen_40264265/t6_YueWen_40264265.jpg" alt=" Unity 3D脚本编程与游戏开发"></p><ul><li><strong>书名</strong>： Unity 3D脚本编程与游戏开发</li><li><strong>作者</strong>： 马遥 沈琰编著</li><li><strong>简介</strong>： 本书以游戏开发为主要线索，全面讲解Unity 3D的编程技术，涵盖Unity 3D引擎的各个系统与模块。全书从帮助读者迅速建立脚本编程和游戏开发的框架思路开始讲起，逐步阐述Unity 3D游戏开发的核心概念，以及对游戏开发至关重要的物理系统和3D数学基础等技术基础。然后针对游戏中的界面、动画、特效与音频等Unity 3D各个常用模块的使用方法进行讲解，并详细介绍游戏开发中数据管理与资源管理相关的知识。随后通过潜入型游戏的完整案例将本书所讲知识融会贯通。最后，讲解游戏人工智能开发技术，以及对象池等高级编程技术，帮助读者提升应对实际工作的能力。本书内容全面，讲解细致，适合游戏开发的初学者入门，也适合相关培训机构作为教材。</li><li><strong>出版时间</strong>： 2021-05-01 00:00:00</li><li><strong>ISBN</strong>： 9787115558756</li><li><strong>分类</strong>： 计算机-编程设计</li><li><strong>出版社</strong>： 人民邮电出版社</li><li><strong>PC地址</strong>： <a href="https://weread.qq.com/web/reader/96332b4072666249963262f" target="_blank" rel="noreferrer">https://weread.qq.com/web/reader/96332b4072666249963262f</a></li></ul><h3 id="_1-1-控制物体的运动" tabindex="-1">1.1 控制物体的运动 <a class="header-anchor" href="#_1-1-控制物体的运动" aria-label="Permalink to &quot;1.1 控制物体的运动&quot;">​</a></h3><blockquote><p>📌 脚本组件要继承自MonoBehaviour，且脚本代码中的class名称必须与文件名一致。一般脚本创建时会自动生成这部分内容，但是如果修改了脚本文件名，那么在挂载时就会报错。 ⏱ 2023-05-05 09:08:56</p></blockquote><blockquote><p>📌 Start和Update又被称为“事件”，因为它们分别是在“该组件开始运行”和“更新该组件”这两个事件发生时被调用的。 ⏱ 2021-11-19 00:38:55</p></blockquote><blockquote><p>📌 Debug.Log()用于向Console（控制台）窗口输出一串信息。 ⏱ 2023-05-05 09:10:57</p></blockquote><blockquote><p>📌 Debug.Log()函数是写代码、查bug的好帮手，越是编程高手，越是使用得多。Debug.Log()函数也是最简单、最可靠的一种调试手段，未来还会反复使用这个方法，建议从现在开始就多多应用它。 ⏱ 2021-11-19 00:39:14</p></blockquote><blockquote><p>📌 修改Transform组件中的Position有两种常用方法。一种是使用Translate()函数。 ⏱ 2024-07-17 20:21:11</p></blockquote><blockquote><p>📌 这些主要源于C#语法的规定。直接写2.5会被认为是一个double类型的数，而这里需要的是float类型的数，所以必须加上f后缀。而写“new”的原因是Vector3是一个值类型，而position是一个属性，由于C#中引用和值的原理，因此不能使用“transform.position.y = 2.5f”这种写法直接修改物体的位置。 ⏱ 2023-05-05 12:44:54</p></blockquote><blockquote><p>📌 Translate()函数默认为局部坐标系，而修改position的方法是世界坐标系。 ⏱ 2023-05-05 13:29:27</p></blockquote><blockquote><p>📌 按游戏开发的常规方法，应当选择“每秒移动同样的距离”。举个例子，如果帧率为60帧/秒时物体每帧移动0.01米，那么帧率只有30帧/秒时就应该每帧移动0.02米，这样才能保证物体移动1秒的距离都是0.6米。 ⏱ 2023-05-05 13:31:22</p></blockquote><blockquote><p>📌 Time.deltaTime表示两帧之间的间隔，如帧率为60帧/秒时这个值为0.0167秒，帧率只有10帧/秒时这个值为0.1秒，用它乘以移动速度就可以抵消帧率变化的影响。 ⏱ 2023-05-05 22:13:25</p></blockquote><blockquote><p>📌 Input.GetAxis()函数的返回值是一个float类型的值，取值范围为-1~1。Unity用这种方法将各种不同的输入方式统一在了一起。 ⏱ 2023-05-06 08:57:00</p></blockquote><blockquote><p>📌 通过简单的乘法就可以将输入的幅度与物体运动的速度联系起来。 ⏱ 2023-05-06 09:02:37</p></blockquote><blockquote><p>📌 每帧最小移动距离为0，在60帧时x轴的每帧最大移动幅度是1<em>10</em>0.0167，即0.167米 ⏱ 2023-05-06 09:06:57</p></blockquote><blockquote><p>📌 （C#中类的成员变量称为字段，两种术语叫法，不影响理解） ⏱ 2023-05-06 09:18:54</p></blockquote><blockquote><p>📌 在真实的游戏开发过程中有很多参数需要设计师反复细致调节，因此Unity默认将public字段直接放在界面上，用户可以随时修改速度，并且被修改的参数会在下一次Update()函数执行时立即生效， ⏱ 2023-05-06 09:23:52</p></blockquote><h3 id="_1-2-触发器事件" tabindex="-1">1.2 触发器事件 <a class="header-anchor" href="#_1-2-触发器事件" aria-label="Permalink to &quot;1.2 触发器事件&quot;">​</a></h3><blockquote><p>📌 知道了物体如何移动，下一步就得知道如何判断一个物体是否碰到了另一个物体，这也是绝大部分游戏都需要用到的功能。 ⏱ 2023-05-06 09:46:06</p></blockquote><blockquote><p>📌 在Unity中，触发器和碰撞体共用了同一种组件——Collider，实际上两者是不同的概念。勾选Box Collider面板中的Is Trigger选项，碰撞体就变成了同样外形的触发器， ⏱ 2023-05-06 09:54:45</p></blockquote><blockquote><p>📌 给小球添加一个Rigidbody（刚体）组件，并勾选Is Kinematic（动力学）选项，其他选项不重要， ⏱ 2023-05-06 10:05:21</p></blockquote><blockquote><p>📌 触发事件实际上有3种，即开始触发（OnTriggerEnter）、触发持续中（OnTriggerStay）及结束触发（OnTriggerExit），分别代表另一个物体进入触发范围、在触发范围内、离开触发范围这3个阶段。 ⏱ 2023-05-06 12:41:01</p></blockquote><blockquote><p>📌 上面的代码利用other.name输出了进入触发范围的物体名称 ⏱ 2023-05-06 21:36:08</p></blockquote><blockquote><p>📌 此处仅添加了一个Destroy()函数调用，该函数用于销毁物体，而参数gameObject指代的正是脚本所挂载到的物体 ⏱ 2023-05-08 08:57:02</p></blockquote><h3 id="_2-1-unity基本概念" tabindex="-1">2.1 Unity基本概念 <a class="header-anchor" href="#_2-1-unity基本概念" aria-label="Permalink to &quot;2.1 Unity基本概念&quot;">​</a></h3><blockquote><p>📌 实际上，关键的概念只有GameObject（游戏物体）、Component（组件）和父子关系3个。 ⏱ 2021-11-18 12:08:27</p></blockquote><blockquote><p>📌 组件则是实现功能特性的单元。要理解组件的作用，首先需要知道游戏物体只是一个空的容器，专门用来存放组件。 ⏱ 2021-11-18 12:08:50</p></blockquote><blockquote><p>📌 计算机中的文件夹既不能直接保存文档数据，又不能直接当作程序运行，但是日常使用计算机又离不开它。Unity中的空物体也具有相似的作用，但它的功能比文件夹要多 ⏱ 2021-11-18 12:13:42</p></blockquote><blockquote><p>📌 。3D游戏中的声音也是有位置、强度、范围变化的，3D游戏也可以模拟出发声的位置，因此Audio Listener的位置会直接影响最终听到的声音。 ⏱ 2024-08-06 19:49:59</p></blockquote><blockquote><p>📌 这种用3个角度表示朝向或旋转的方法叫作欧拉角（Euler Angle）。 ⏱ 2024-08-06 19:55:00</p></blockquote><blockquote><p>📌 。虽然Unity在编辑器面板上使用欧拉角表示朝向，但在引擎内部是使用四元数表示朝向和旋转的。 ⏱ 2024-08-06 19:55:35</p></blockquote><blockquote><p>📌 由于组件与物体是一体的，因此脚本中引用组件实际上是引用了物体。 ⏱ 2021-11-18 12:22:47</p></blockquote><blockquote><p>📌 善用标签有助于团队协作。例如，事先定义好游戏中的各类标签，很容易就知道某个物体是做什么用的，从而可以让关卡设计师、美术设计师和软件工程师更好地协作。 ⏱ 2021-11-18 12:26:31</p></blockquote><h3 id="_2-2-用脚本获取物体和组件" tabindex="-1">2.2 用脚本获取物体和组件 <a class="header-anchor" href="#_2-2-用脚本获取物体和组件" aria-label="Permalink to &quot;2.2 用脚本获取物体和组件&quot;">​</a></h3><blockquote><p>📌 Unity的初级脚本编写没有过于困难的部分，大多数读者遇到障碍的原因在初始学习时跳过了关键性知识。如果跳过了关键性知识，可能会造成知识体系断层，导致进一步学习变得困难。 ⏱ 2021-11-18 12:27:56</p></blockquote><blockquote><p>📌 ：某个自己编写的脚本是一种组件类（class），挂载到物体上的脚本是一个实例化的组件，即一个对象（编程语言中的object）。从面向对象的角度来看，Unity的逻辑架构是非常自然的。一个游戏物体是一个对象；没有被挂载到物体上的脚本，是一个未被实例化的类，暂时还不是具体的对象；当脚本被挂载到物体上以后，就成了一个实实在在的对象 ⏱ 2021-11-18 12:28:53</p></blockquote><blockquote><p>📌 越是简单的代码越需要理解清楚。在脚本代码中，this表示该脚本对象自身，而gameObject是当前脚本的一个属性，指的是当前的物体，因此可以直接获取到。 ⏱ 2021-11-18 13:22:03</p></blockquote><blockquote><p>📌 Unity为了方便，设计了获取组件的简便写法。其思路是，在同一个物体上，从任意一个组件出发都可以直接获取到其他组件，不需要先获取游戏物体。也就是说，上面获取组件的写法有很多等价形式， ⏱ 2021-11-18 22:03:05</p></blockquote><blockquote><p>📌 初学者在看别人的代码时，很可能没有注意到GetComponent()方法的主体有时是物体，有时是组件，而上面的例子充分说明了获取同一个物体上的组件是十分灵活的。 ⏱ 2021-11-18 22:03:12</p></blockquote><blockquote><p>📌 常用技巧——可以用物体上任意一个组件代表该物体。 ⏱ 2021-11-18 22:03:24</p></blockquote><blockquote><p>📌 当一个物体可能包含多个同类型组件时，也可以直接获取到所有同类的组件，该方法名为GetComponents，它会返回一个装着所有找到的组件的数组。 ⏱ 2021-11-18 22:03:40</p></blockquote><blockquote><p>📌 GameObject.Find方法比较常用，但是它有两个弊端。第一，GameObject.Find()方法无法找到未激活的物体。第二，GameObject.Find()方法需要遍历场景中的所有物体，从性能上看是非常低效的。 ⏱ 2021-11-18 23:46:21</p></blockquote><blockquote><p>📌 在Unity中，“父子关系”的表达是Transform组件的职责。 ⏱ 2021-11-18 23:52:13</p></blockquote><h3 id="_2-3-用脚本创建物体" tabindex="-1">2.3 用脚本创建物体 <a class="header-anchor" href="#_2-3-用脚本创建物体" aria-label="Permalink to &quot;2.3 用脚本创建物体&quot;">​</a></h3><blockquote><p>📌 在游戏设计中，需要用到的物体都可以通过编辑器摆放在场景中。但是很多时候，无法事先创建所有需要的物体，如子弹、炮弹或随机刷新的怪物。这些物体要么是根据玩家操作而随时创建，要么是依据游戏玩法在特定时刻创建，都无法事先确定它们在什么时候出现。用脚本动态创建物体，即在游戏进行中创建物体，是一项基本功能 ⏱ 2021-11-19 00:17:30</p></blockquote><blockquote><p>📌 在游戏开发的实践中，一般将可能需要动态创建的物体，如怪物、子弹、导弹等都事先做成预制体，然后在游戏运行过程中由脚本负责创建即可。 ⏱ 2021-11-19 00:18:13</p></blockquote><blockquote><p>📌 Overrides：覆盖预制体。对物体的参数和组件做修改后，预制体文件本身是不变的。单击此按钮后，会弹出一个小窗口提示用户具体修改了哪些属性。 ⏱ 2021-11-19 00:18:30</p></blockquote><blockquote><p>📌 利用预制体创建物体，要使用实例化方法Instantiate()。它需要一个预制体的引用作为模版，返回值总是新创建那个物体的引用。 ⏱ 2021-11-19 00:19:50</p></blockquote><blockquote><p>📌 创建组件并将其添加到物体上，通常使用GameObject.AddComponent()方法。 ⏱ 2021-11-19 00:20:35</p></blockquote><blockquote><p>📌 使用Destroy()方法可以销毁物体或组件。 ⏱ 2021-11-19 00:20:23</p></blockquote><blockquote><p>📌 与延迟创建物体类似，延迟销毁也同样可以用Invoke()实现。 ⏱ 2021-11-19 00:21:46</p></blockquote><h3 id="_2-4-脚本的生命周期" tabindex="-1">2.4 脚本的生命周期 <a class="header-anchor" href="#_2-4-脚本的生命周期" aria-label="Permalink to &quot;2.4 脚本的生命周期&quot;">​</a></h3><blockquote><p>📌 实际上读者可以简单将它理解为，一个脚本的创建和销毁两个关键事件，以及在此过程中可能触发的各种事件。 ⏱ 2021-11-19 00:22:26</p></blockquote><blockquote><p>📌 当在组件脚本中写下Update()方法时，就意味着向引擎“注册”了更新事件。当引擎对所有组件执行更新操作时，也会捎带这个脚本组件。反过来说，如果没有定义Update()方法，那么引擎在更新时，就会跳过这个脚本。 ⏱ 2021-11-19 00:32:15</p></blockquote><blockquote><p>📌 可以把引擎每一帧需要做的事，想象成在标准跑道上跑一圈。 ⏱ 2021-11-19 00:32:41</p></blockquote><h3 id="_2-5-协程入门" tabindex="-1">2.5 协程入门 <a class="header-anchor" href="#_2-5-协程入门" aria-label="Permalink to &quot;2.5 协程入门&quot;">​</a></h3><blockquote><p>📌 之前提到，定时创建或销毁物体，可以使用Invoke方法。 ⏱ 2024-08-06 19:32:34</p></blockquote><blockquote><p>📌 实际上，Unity已经提供了“协程”这一概念，专门处理复杂的定时逻辑。 ⏱ 2021-11-19 00:35:18</p></blockquote><h3 id="_6-1-动画系统基本概念" tabindex="-1">6.1 动画系统基本概念 <a class="header-anchor" href="#_6-1-动画系统基本概念" aria-label="Permalink to &quot;6.1 动画系统基本概念&quot;">​</a></h3><blockquote><p>📌 状态机有两个要素：状态和状态转移。 ⏱ 2023-03-14 19:45:35</p></blockquote><blockquote><p>📌 用脚本直接实现状态机，只需要用一个变量保存当前状态，根据游戏逻辑切换状态即可。而对于动画系统来说，将状态机思想应用于管理动画状态极为合适，具有很好的通用性。 ⏱ 2023-03-14 19:45:29</p></blockquote>',62)])])}const s=e(c,[["render",u]]);export{k as __pageData,s as default};
