import{_ as e,o as t,c as l,a6 as c}from"./chunks/framework.BB0md0jN.js";const n=JSON.parse('{"title":"C从入门到精通（第5版）","description":"","frontmatter":{"layout":"doc","title":"C从入门到精通（第5版）","readingTime":"14 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/C从入门到精通第5版.md","filePath":"电影和阅读/微信读书/C从入门到精通第5版.md"}'),u={name:"电影和阅读/微信读书/C从入门到精通第5版.md"};function p(a,o,b,q,k,r){return t(),l("div",null,[...o[0]||(o[0]=[c('<h1 id="c-从入门到精通-第5版" tabindex="-1">C#从入门到精通（第5版） <a class="header-anchor" href="#c-从入门到精通-第5版" aria-label="Permalink to &quot;C#从入门到精通（第5版）&quot;">​</a></h1><p><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/406/27563406/t6_27563406.jpg" alt=" C#从入门到精通（第5版）"></p><ul><li><strong>书名</strong>： C#从入门到精通（第5版）</li><li><strong>作者</strong>： 明日科技</li><li><strong>简介</strong>： 《C#从入门到精通（第5版）》从初学者角度出发，通过通俗易懂的语言、丰富多彩的实例，详细介绍了使用C#进行WinForm应用程序开发应该掌握的各方面技术。全书共分26章，包括初识C#及其开发环境、开始C#之旅、变量与常量、表达式与运算符、字符与字符串、流程控制语句、数组和集合、属性和方法、结构和类、Windows窗体、Windows应用程序常用控件、Windows应用程序高级控件、数据访问技术、DataGridView数据控件、LINQ数据访问技术、程序调试与异常处理、面向对象技术高级应用、迭代器和分部类、泛型、文件及数据流技术、GDI+图形图像技术、Windows打印技术、网络编程技术、注册表技术、线程的使用、企业人事管理系统等内容。</li><li><strong>出版时间</strong>： 2019-10-01 00:00:00</li><li><strong>ISBN</strong>： 9787302535850</li><li><strong>分类</strong>： 计算机-编程设计</li><li><strong>出版社</strong>： 清华大学出版社</li><li><strong>PC地址</strong>： <a href="https://weread.qq.com/web/reader/2c032b6071a4958e2c07336" target="_blank" rel="noreferrer">https://weread.qq.com/web/reader/2c032b6071a4958e2c07336</a></li></ul><h3 id="第1章-初识c-及其开发环境" tabindex="-1">第1章 初识C#及其开发环境 <a class="header-anchor" href="#第1章-初识c-及其开发环境" aria-label="Permalink to &quot;第1章 初识C#及其开发环境&quot;">​</a></h3><blockquote><p>📌 语法简洁。不允许直接操作内存，去掉了指针操作。 ⏱ 2020-08-01 09:19:29</p></blockquote><blockquote><p>📌 .NET提供的垃圾回收器能够帮助开发者有效地管理内存资源。 ⏱ 2020-08-01 09:33:38</p></blockquote><h3 id="第2章-开始c-之旅" tabindex="-1">第2章 开始C#之旅 <a class="header-anchor" href="#第2章-开始c-之旅" aria-label="Permalink to &quot;第2章 开始C#之旅&quot;">​</a></h3><blockquote><p>📌 C#中所有的语句都必须位于类内。因此，类是C#语言的核心和基本构成模块。 ⏱ 2023-08-18 15:15:07</p></blockquote><blockquote><p>📌 Main()方法是程序的入口点，C#程序中必须包含一个Main()方法，在该方法中可以创建对象和调用其他方法，一个C#程序中只能有一个Main()方法，并且在C#中所有的Main()方法都必须是静态的。C#是一种面向对象的编程语言，即使是程序的启动入口点，它也是一个类的成员。由于程序启动时还没有创建类的对象，因此，必须将入口点Main()方法定义为静态方法，使它可以不依赖于类的实例对象而执行。 ⏱ 2023-08-18 15:21:22</p></blockquote><blockquote><p>📌 可以用3个修饰符修饰Main()方法，分别是public、static和void。☑　public：说明Main()方法是共有的，在类的外面也可以调用整个方法。☑　static：说明Mian()方法是一个静态方法，即这个方法属于类的本身而不是这个类的特定对象。调用静态方法不能使用类的实例化对象，必须直接使用类名来调用。☑　void：此修饰符说明Mian()方法无返回值。 ⏱ 2023-08-18 16:19:38</p></blockquote><blockquote><p>📌 在C#语言中，标识符中的字母是严格区分大小写的，如good和Good是不同的两个标识符。 ⏱ 2023-08-18 16:22:02</p></blockquote><blockquote><p>📌 语句通常以分号终止 ⏱ 2023-08-18 16:23:40</p></blockquote><blockquote><p>📌 尽量使用接口，然后使用类实现接口，以提高程序的灵活性。 ⏱ 2023-08-18 16:25:54</p></blockquote><blockquote><p>📌 关键的语句（包括声明关键的变量）必须要写注释。☑　建议局部变量在最接近使用它的地方声明。 ⏱ 2023-08-18 16:26:18</p></blockquote><blockquote><p>📌 避免写超过5个参数的方法。如果要传递多个参数，则使用结构。 ⏱ 2023-08-18 16:26:31</p></blockquote><blockquote><p>📌 避免在同一个文件中放置多个类 ⏱ 2023-08-18 16:28:22</p></blockquote><blockquote><p>📌 ☑　switch语句一定要有default语句来处理意外情况。 ⏱ 2023-08-18 16:30:47</p></blockquote><blockquote><p>📌 ☑　用Pascal规则来命名方法和类型，Pascal的命名规则是第一个字母必须大写，并且后面的连结词的第一个字母均为大写。 ⏱ 2023-08-18 16:34:55</p></blockquote><blockquote><p>📌 ☑　用Camel规则来命名局部变量和方法的参数，Camel规则是指名称中第一个单词的第一个字母小写，并且后面的连接词的第一个字母均为大写。 ⏱ 2023-08-18 16:35:12</p></blockquote><blockquote><p>📌 ☑　所有的成员变量前加前缀“_”。 ⏱ 2023-08-18 16:35:44</p></blockquote><h3 id="第3章-变量与常量" tabindex="-1">第3章 变量与常量 <a class="header-anchor" href="#第3章-变量与常量" aria-label="Permalink to &quot;第3章 变量与常量&quot;">​</a></h3><blockquote><p>📌 在程序中，一般会根据变量的“有效范围”将变量分为“成员变量”和“局部变量”。 ⏱ 2023-08-19 10:27:17</p></blockquote><blockquote><p>📌 在类体中定义的变量被称为成员变量，成员变量在整个类中都有效。类的成员变量又可分为两种，即静态变量和实例变量。 ⏱ 2023-08-19 10:41:55</p></blockquote><blockquote><p>📌 静态变量的有效范围可以跨类，甚至可达到整个应用程序之内。对于静态变量，除了能在定义它的类内存取，还能直接以“类名.静态变量”的方式在其他类内使用。 ⏱ 2023-08-19 10:42:53</p></blockquote><blockquote><p>📌 在类的方法体中定义的变量（方法内部定义，“{”与“}”之间的代码中声明的变量）称为局部变量。局部变量只在当前代码块中有效。 ⏱ 2023-08-19 10:49:45</p></blockquote><blockquote><p>📌 局部变量只有在当前定义的方法内有效，不能用于类的其他方法中。局部变量的生命周期取决于方法，当方法被调用时，C#编译器为方法中的局部变量分配内存空间，当该方法的调用结束后，则会释放方法中局部变量占用的内存空间，局部变量也将会销毁。 ⏱ 2023-08-19 10:50:17</p></blockquote><blockquote><p>📌 C#中的变量类型根据其定义可以分为两种：一种是值类型；另一种是引用类型。这两种类型的差异在于数据的存储方式，值类型的变量本身直接存储数据。而引用类型则存储实际数据的引用，程序通过此引用找到真正的数据 ⏱ 2023-08-19 10:55:55</p></blockquote><blockquote><p>📌 每个值类型变量都有自己的数据副本，因此对一个值类型变量的操作不会影响其他变量。 ☑　复制值类型变量时，复制的是变量的值，而不是变量的地址。 ⏱ 2023-08-19 10:57:16</p></blockquote><blockquote><p>📌 整型数据在C#程序中有3种表示形式，分别为十进制、八进制和十六进制。 ⏱ 2023-08-19 11:20:11</p></blockquote><blockquote><p>📌 注意 八进制必须以0开头。 ⏱ 2023-08-19 11:20:22</p></blockquote><blockquote><p>📌 注意 十六进制必须以0X或0x开头。 ⏱ 2023-08-19 11:20:31</p></blockquote><blockquote><p>📌 使用这种类型时必须特别注意数值的大小，否则可能会导致运算溢出的错误。 ⏱ 2023-08-19 11:22:19</p></blockquote><blockquote><p>📌 浮点类型主要包含float和double两种数值类型。 ⏱ 2023-08-19 11:22:49</p></blockquote><blockquote><p>📌 如果不做任何设置，包含小数点的数值都被认为是double类型 ⏱ 2023-08-19 11:25:25</p></blockquote><blockquote><p>📌 如果要将数值以float类型来处理，就应该通过强制使用f或F将其指定为float类型。 ⏱ 2023-08-19 11:25:37</p></blockquote><blockquote><p>📌 如果需要使用float类型变量时，必须在数值的后面跟随f或F，否则编译器会直接将其作为double类型处理。也可以在double类型的值前面加上(float)，对其进行强制转换。 ⏱ 2023-08-19 11:36:43</p></blockquote><blockquote><p>📌 布尔类型变量不能与其他类型之间进行转换。布尔类型通常被用在流程控制中作为判断条件。 ⏱ 2023-08-19 11:41:12</p></blockquote><blockquote><p>📌 ，整数类型和浮点类型的默认初始化为0，布尔类型的初始化为false。 ⏱ 2023-08-19 11:41:39</p></blockquote><blockquote><p>📌 引用类型是构建C#应用程序的主要对象类型数据。在应用程序执行的过程中，预先定义的对象类型以new创建对象实例，并且存储在堆中。堆是一种由系统弹性配置的内存空间，没有特定大小及存活时间，因此可以被弹性地运用于对象的访问。 ⏱ 2023-08-19 11:46:46</p></blockquote><blockquote><p>📌 引用类型被赋值前的值都是null。 ⏱ 2023-08-19 11:53:11</p></blockquote><blockquote><p>📌 所有被称为“类”的都是引用类型，主要包括类、接口、数组和委托。 ⏱ 2023-08-19 11:59:08</p></blockquote><blockquote><p>📌 从内存空间上看，值类型是在栈中操作，而引用类型则在堆中分配存储单元。栈在编译时就分配好内存空间，在代码中有栈的明确定义，而堆是程序运行中动态分配的内存空间，可以根据程序的运行情况动态地分配内存的大小。因此，值类型总是在内存中占用一个预定义的字节数。而引用类型的变量则在堆中分配一个内存空间，这个内存空间包含的是对另一个内存位置的引用，这个位置是托管堆中的一个地址，即存放此变量实际值的地方。 也就是说值类型相当于现金，要用就直接用，而引类型相当于存折，要用得先去银行取。 ⏱ 2023-08-19 12:05:01</p></blockquote><blockquote><p>📌 C#的所有值类型均隐式派生自System.ValueType，而System.ValueType直接派生于System.Object。即System.ValueType本身是一个类类型，而不是值类型。其关键在于ValueType重写了Equals()方法，从而对值类型按照实例的值来比较，而不是引用地址来比较。 ⏱ 2023-08-19 12:05:56</p></blockquote><blockquote><p>📌 枚举类型是一种独特的值类型，它用于声明一组具有相同性质的常量，编写与日期相关的应用程序时，经常需要使用年、月、日、星期等日期数据，可以将这些数据组织成多个不同名称的枚举类型。使用枚举可以增加程序的可读性和可维护性。同时，枚举类型可以避免类型错误。 ⏱ 2023-08-19 12:08:28</p></blockquote><blockquote><p>📌 要理解类型转换，读者可以这么想象，大脑前面是一片内存，源和目标分别是两个大小不同的内存块（由变量及数据的类型来决定），将源数据赋值给目标内存的过程，就是用目标内存块去套取源内存中的数据，能套多少算多少。 ⏱ 2023-08-19 12:48:58</p></blockquote><blockquote><p>📌 所谓隐式转换就是不需要声明就能进行的转换。进行隐式转换时，编译器不需要进行检查就能自动进行转换。 ⏱ 2023-08-19 13:31:50</p></blockquote><blockquote><p>📌 将值类型转换为引用类型的过程叫作装箱，相反，将引用类型转换为值类型的过程叫作拆箱 ⏱ 2023-08-21 20:15:02</p></blockquote><blockquote><p>📌 装箱是将一个值类型转换为一个对象类型（object），而拆箱则是将一个对象类型显式转换为一个值类型。 ⏱ 2023-08-21 20:13:44</p></blockquote><blockquote><p>📌 C#中使用关键字const定义常量，并且在创建常量时必须设置它的初始值 ⏱ 2023-08-21 20:15:16</p></blockquote><blockquote><p>📌 与变量不同，常量在整个程序中只能被赋值一次。 ⏱ 2023-08-21 20:15:37</p></blockquote>',50)])])}const s=e(u,[["render",p]]);export{n as __pageData,s as default};
