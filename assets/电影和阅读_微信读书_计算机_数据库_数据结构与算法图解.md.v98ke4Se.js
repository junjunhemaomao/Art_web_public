import{_ as e,o as t,c as l,a6 as a}from"./chunks/framework.BB0md0jN.js";const n=JSON.parse('{"title":"数据结构与算法图解","description":"","frontmatter":{"layout":"doc","title":"数据结构与算法图解","readingTime":"9 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/计算机_数据库/数据结构与算法图解.md","filePath":"电影和阅读/微信读书/计算机_数据库/数据结构与算法图解.md"}'),c={name:"电影和阅读/微信读书/计算机_数据库/数据结构与算法图解.md"};function u(r,o,q,b,p,k){return t(),l("div",null,[...o[0]||(o[0]=[a('<h1 id="数据结构与算法图解" tabindex="-1">数据结构与算法图解 <a class="header-anchor" href="#数据结构与算法图解" aria-label="Permalink to &quot;数据结构与算法图解&quot;">​</a></h1><p><img src="https://cdn.weread.qq.com/weread/cover/13/YueWen_26211939/t6_YueWen_26211939.jpg" alt=" 数据结构与算法图解"></p><ul><li><strong>书名</strong>： 数据结构与算法图解</li><li><strong>作者</strong>： 杰伊·温格罗</li><li><strong>简介</strong>： 本书是数据结构与算法的入门指南，不局限于某种特定语言，略过复杂的数学公式，用通俗易懂的方式针对编程初学者介绍数据结构与算法的基本概念，培养读者编程逻辑。主要内容包括：为什么要了解数据结构与算法，大O表示法及其代码优化利用，栈、队列等的合理使用，等等。</li><li><strong>出版时间</strong>： 2019-04-04 00:00:00</li><li><strong>ISBN</strong>： 9787115509000</li><li><strong>分类</strong>： 计算机-数据库</li><li><strong>出版社</strong>： 人民邮电出版社</li><li><strong>PC地址</strong>： <a href="https://weread.qq.com/web/reader/689329a0718ff663689395d" target="_blank" rel="noreferrer">https://weread.qq.com/web/reader/689329a0718ff663689395d</a></li></ul><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><blockquote><p>📌 因为大O记法全书都会用到，所以对这一章的理解非常重要。 ⏱ 2024-06-27 09:39:52</p></blockquote><blockquote><p>📌 递归，计算机科学中的核心概念。 ⏱ 2024-06-27 09:40:10</p></blockquote><blockquote><p>📌 你得按顺序从第1章开始读起。虽然有些书允许读者单独翻阅某些章节，或跳过某些章节，但这本不是。本书的每一章都假定你已经读过其之前的内容，而且全书内容也确实是精心安排的，使得你在按序阅读的过程中逐步提高认知水平。 ⏱ 2024-06-27 09:40:36</p></blockquote><blockquote><p>📌 有时候，理解一个复杂概念的最好方法就是把它拆分成小块，并且在完全明白某一块以后才去着手其他部分。要是我在描述某个术语时说得比较模糊，千万别把它当成一个完整的定义，想看清该术语的全貌，你得读完关于它的所有内容才行。 ⏱ 2024-06-27 09:40:54</p></blockquote><h2 id="第1章-数据结构为何重要" tabindex="-1">第1章 数据结构为何重要 <a class="header-anchor" href="#第1章-数据结构为何重要" aria-label="Permalink to &quot;第1章 数据结构为何重要&quot;">​</a></h2><blockquote><p>📌 数据结构不同，程序的运行速度可能相差多个数量级。 ⏱ 2024-06-27 09:42:41</p></blockquote><h3 id="_1-1-基础数据结构-数组" tabindex="-1">1.1 基础数据结构：数组 <a class="header-anchor" href="#_1-1-基础数据结构-数组" aria-label="Permalink to &quot;1.1 基础数据结构：数组&quot;">​</a></h3><blockquote><p>📌 本章我们将会研究这些操作在数组上的运行速度。 ⏱ 2024-06-27 09:46:47</p></blockquote><blockquote><p>📌 我们也将学到本书的第一个重要理论：操作的速度，并不按时间计算，而是按步数计算。 ⏱ 2024-06-27 09:46:58</p></blockquote><blockquote><p>📌 受硬件影响的计时方法，非常不可靠。然而，若按步数来算，则确切得多。如果A操作要5步，B操作要500步，那么我们可以很肯定地说，无论是在什么样的硬件上对比，A都快过B。因此，衡量步数是分析速度的关键。 ⏱ 2024-06-27 09:47:41</p></blockquote><blockquote><p>📌 首先看看读取，即查看数组中某个索引所指的数据值。这只要一步就够了，因为计算机本身就有跳到任一索引位置的能力 ⏱ 2024-06-27 09:53:36</p></blockquote><blockquote><p>📌 当程序声明一个数组时，它会先划分出一些连续的空格子以备使用 ⏱ 2024-06-27 09:53:51</p></blockquote><blockquote><p>📌 。而且，每个格子的内存地址都比前一个大1， ⏱ 2024-06-27 09:54:11</p></blockquote><blockquote><p>📌 数组本身会记有第一个格子的内存地址，因此，计算机知道这个数组的开头在哪里。 ⏱ 2024-06-27 10:01:22</p></blockquote><blockquote><p>📌 所以，数组的读取是一种非常高效的操作，因为它只要一步就好。一步自然也是最快的速度。这种一步读取任意索引的能力，也是数组好用的原因之一。 ⏱ 2024-06-27 10:17:10</p></blockquote><blockquote><p>📌 查找就是检查它是否包含某个值，如果包含，还得给出其索引。 ⏱ 2024-06-27 10:17:28</p></blockquote><blockquote><p>📌 计算机并没有眼睛，它只能一步一步地检查整个数组。想要查找数组中是否存在某个值，计算机会先从索引0开始，检查其值，如果不匹配，则继续下一个索引，以此类推，直至找到为止。 ⏱ 2024-06-27 10:17:49</p></blockquote><blockquote><p>📌 自此，计算机不用再往后跳了，因为结果已经得到。 ⏱ 2024-06-27 10:18:07</p></blockquote><blockquote><p>📌 种逐个格子去检查的做法，就是最基本的查找方法——线性查找。 ⏱ 2024-06-27 10:18:36</p></blockquote><blockquote><p>📌 同样，如果我们要找的值并不存在于数组中，那么计算机也还是得查遍每个格子，才能确定这个值不在数组中。 ⏱ 2024-06-27 10:20:24</p></blockquote><blockquote><p>📌 于是，一个5格的数组，其线性查找的步数最大值是5，而对于一个500格的数组，则是500。 ⏱ 2024-06-27 10:20:37</p></blockquote><blockquote><p>📌 以此类推，一个N格的数组，其线性查找的最多步数是N（N可以是任何自然数）。 ⏱ 2024-06-27 10:22:11</p></blockquote><blockquote><p>📌 可见，无论是多长的数组，查找都比读取要慢，因为读取永远都只需要一步，而查找却可能需要多步。 ⏱ 2024-06-27 10:20:57</p></blockquote><blockquote><p>📌 往数组里插入一个新元素的速度，取决于你想把它插入到哪个位置上。 ⏱ 2024-06-27 10:22:52</p></blockquote><blockquote><p>📌 计算机知道数组开头的内存地址，也知道数组包含多少个元素，所以可以算出要插入的内存地址，然后一步跳到那里插入就行了。 ⏱ 2024-06-27 10:23:07</p></blockquote><blockquote><p>📌 但在数组开头或中间插入，就另当别论了。这种情况下，我们需要移动其他元素以腾出空间，于是得花费额外的步数。 ⏱ 2024-06-27 10:23:58</p></blockquote><blockquote><p>📌 而这也不是一步就能移好，因为我们首先要将&quot;elderberries&quot;右移一格，以空出位置给&quot;dates&quot;，然后再将&quot;dates&quot;右移，以空出位置给&quot;cucumbers ⏱ 2024-06-27 10:24:19</p></blockquote><h2 id="第8章-用栈和队列来构造灵巧的代码" tabindex="-1">第8章 用栈和队列来构造灵巧的代码 <a class="header-anchor" href="#第8章-用栈和队列来构造灵巧的代码" aria-label="Permalink to &quot;第8章 用栈和队列来构造灵巧的代码&quot;">​</a></h2><blockquote><p>📌 栈和队列。事实上它们并不是全新的东西，只不过是多加了一些约束条件的数组而已。 ⏱ 2024-06-27 09:33:56</p></blockquote><blockquote><p>📌 具体一点说，栈和队列都是处理临时数据的灵活工具。在操作系统、打印任务、数据遍历等各种需要临时容器才能构造出美妙算法的场景，它们都大有作为。 ⏱ 2024-06-27 09:34:08</p></blockquote><blockquote><p>📌 处理临时数据就像是点餐。在菜做好并送到客人手上之前，订单是有用的，但过后，你无须保留那张订单。临时数据就是一些处理完便不再有用的信息，因此没有保留的必要。此外，就像出菜时应先出给早下单的客人，你可能还得注意数据按什么顺序去处理。栈和队列就正好能把数据按顺序处理，并在处理完成后将其抛弃。 ⏱ 2024-06-27 09:34:54</p></blockquote><h3 id="_8-1-栈" tabindex="-1">8.1 栈 <a class="header-anchor" href="#_8-1-栈" aria-label="Permalink to &quot;8.1 栈&quot;">​</a></h3><blockquote><p>📌 绝大部分计算机科学家都把栈的末尾称为栈顶，把栈的开头称为栈底。 ⏱ 2024-06-27 09:37:38</p></blockquote><blockquote><p>📌 如果想把0插入到栈底或中间，那是不允许的，因为这就是栈的特性：只能在末尾插入数据。从栈顶移除数据叫作出栈。 ⏱ 2024-06-27 09:38:11</p></blockquote>',38)])])}const s=e(c,[["render",u]]);export{n as __pageData,s as default};
