import{_ as i,o as t,c as a,a6 as o}from"./chunks/framework.BB0md0jN.js";const c=JSON.parse('{"title":"Python程序设计开发宝典","description":"","frontmatter":{"layout":"doc","title":"Python程序设计开发宝典","readingTime":"7 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/计算机/Python程序设计开发宝典.md","filePath":"电影和阅读/微信读书/计算机/Python程序设计开发宝典.md"}'),e={name:"电影和阅读/微信读书/计算机/Python程序设计开发宝典.md"};function n(r,l,u,p,h,s){return t(),a("div",null,[...l[0]||(l[0]=[o('<h1 id="python程序设计开发宝典" tabindex="-1">Python程序设计开发宝典 <a class="header-anchor" href="#python程序设计开发宝典" aria-label="Permalink to &quot;Python程序设计开发宝典&quot;">​</a></h1><p><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/564/26943564/t7_26943564.jpg" alt=" Python程序设计开发宝典"></p><ul><li><strong>书名</strong>： Python程序设计开发宝典</li><li><strong>作者</strong>： 董付国</li><li><strong>简介</strong>： 全书共13章，面向Python 3.5.x、Python 3.6.x和Python 3.7.x，重点关注Python内置对象和标准库对象的高级应用以及比较前沿的一些新技术，偶尔涉及一点扩展库用法。第1章介绍Python语言编程规范与代码优化建议、开发环境配置、程序伪编译与打包。第2章详解运算符与内置函数的用法。第3章详解各种序列对象、推导式、切片和序列解包。第4章详解选择结构和循环结构，关键字else、break与continue。第5章详解函数的基本用法，可调用对象与修饰器、函数参数、变量的作用域、生成器函数、lambda表达式、函数柯里化、泛型函数、协程函数和回调函数。第6章详解类的定义、不同类型的成员、依赖注入技术和运算符重载。第7章详解字符串编码与格式化方法、字符串对象方法、文本排版与压缩、汉字拼音有关的技术。第8章详解正则表达式语法、re模块、正则表达式对象与match对象。第9章详解文件对象用法、文件内容操作。第10章详解文件与文件夹操作。第11章详解异常处理结构、文档测试与单元测试、覆盖测试与软件性能测试、代码调试技术。第12章详解不同类型的并行处理技术。第13章详解asyncio提供的网络通信功能。 本书不但可以作为Python程序设计教材，还可作为Python开发工程师的指导用书。</li><li><strong>出版时间 2017-08-01 00</strong>: 00:00</li><li><strong>ISBN</strong>： 9787302472100</li><li><strong>分类</strong>： 计算机-编程设计</li><li><strong>出版社</strong>： 清华大学出版社</li></ul><h2 id="第5章-代码复用技术-一-函数" tabindex="-1">第5章 代码复用技术（一）：函数 <a class="header-anchor" href="#第5章-代码复用技术-一-函数" aria-label="Permalink to &quot;第5章 代码复用技术（一）：函数&quot;">​</a></h2><ul><li><p>📌 应尽量减少使用直接复制代码的方式来实现复用。解决这个问题的有效方法是设计函数（function）和类（class）。</p><ul><li>⏱ 2021-04-10 19:31:33</li></ul></li><li><p>📌 把大任务拆分成多个函数也是分治法的经典应用，复杂问题简单化，使得软件开发像搭积木一样简单。</p><ul><li>⏱ 2021-04-10 20:48:09</li></ul></li><li><p>📌 不要在同一个函数中执行太多的功能，尽量只让其完成一个高度相关且大小合适的功能，提高模块的内聚性。</p><ul><li>⏱ 2021-04-10 20:48:10</li></ul></li><li><p>📌 在实际项目开发中，往往会把一些通用的函数封装到一个模块中，并把这个通用模块文件放到顶层文件夹中，这样更方便管理。</p><ul><li>⏱ 2021-04-10 20:48:09</li></ul></li></ul><h2 id="_5-1-函数定义与使用" tabindex="-1">5.1 函数定义与使用 <a class="header-anchor" href="#_5-1-函数定义与使用" aria-label="Permalink to &quot;5.1 函数定义与使用&quot;">​</a></h2><ul><li><p>📌 不论return语句出现在函数的什么位置，一旦得到执行将直接结束函数的执行。</p><ul><li>⏱ 2021-04-10 20:57:50</li></ul></li><li><p>📌 Python允许函数的嵌套定义，在函数内部可以再定义另外一个函数。</p><ul><li>⏱ 2021-04-10 23:18:21</li></ul></li><li><p>📌 尽管函数嵌套定义使用很方便，也很灵活，但是并不提倡过多使用，因为这样会导致内部的函数反复定义而影响执行效率。</p><ul><li>⏱ 2021-04-10 23:18:56</li></ul></li><li><p>📌 修饰器（decorator）是函数嵌套定义的另一个重要应用。修饰器本质上也是一个函数，只不过这个函数接收其他函数作为参数并对其进行一定的改造之后返回新函数。</p><ul><li>⏱ 2021-04-10 23:19:40</li></ul></li><li><p>📌 可以为函数和自定义对象动态增加新成员。</p><ul><li>⏱ 2021-04-10 23:42:40</li></ul></li><li><p>📌 这需要一定的栈空间。另外，调用一个函数时会为该函数分配一个栈帧，用来存放普通参数和函数内部局部变量的值，这个栈帧会在函数调用结束后自动释放。</p><ul><li>⏱ 2021-04-11 00:27:56</li></ul></li><li><p>📌 因此，递归深度如果太大的话，可能会导致栈空间不足进而导致程序崩溃。</p><ul><li>⏱ 2021-04-11 00:28:50</li></ul></li></ul><h2 id="第6章-代码复用技术-二-面向对象程序设计" tabindex="-1">第6章 代码复用技术（二）：面向对象程序设计 <a class="header-anchor" href="#第6章-代码复用技术-二-面向对象程序设计" aria-label="Permalink to &quot;第6章 代码复用技术（二）：面向对象程序设计&quot;">​</a></h2><ul><li><p>📌 面向对象程序设计的一个关键性观念是将数据以及对数据的操作封装在一起，组成一个相互依存、不可分割的整体（对象），不同对象之间通过消息机制来通信或者同步。</p><ul><li>⏱ 2021-04-10 18:34:28</li></ul></li><li><p>📌 面向对象程序设计的关键就是如何合理地定义这些类并且组织多个类之间的关系。</p><ul><li>⏱ 2021-04-10 18:34:38</li></ul></li></ul><h2 id="_6-1-类的定义与使用" tabindex="-1">6.1 类的定义与使用 <a class="header-anchor" href="#_6-1-类的定义与使用" aria-label="Permalink to &quot;6.1 类的定义与使用&quot;">​</a></h2><ul><li><p>📌 如果派生自其他基类的话则需要把所有基类放到一对括号中并使用逗号分隔，然后是一个冒号，最后换行并定义类的内部实现。</p><ul><li>⏱ 2021-04-10 19:16:38</li></ul></li><li><p>📌 在Python中，type是一个特殊的类，可以看作是所有类型（包括object）的基类。</p><ul><li>⏱ 2021-04-10 19:27:53</li></ul></li><li><p>📌 Python对象都有一个成员__class__可以查看其所属的类，与内置函数type（）的返回结果一致；所有Python类都有一个成员__bases__，返回包含该类所有基类的元组；</p><ul><li>⏱ 2021-04-10 19:29:08</li></ul></li><li><p>📌 与函数一样，定义类时也可以使用修饰器。</p><ul><li>⏱ 2021-04-10 19:30:30</li></ul></li></ul>',11)])])}const d=i(e,[["render",n]]);export{c as __pageData,d as default};
