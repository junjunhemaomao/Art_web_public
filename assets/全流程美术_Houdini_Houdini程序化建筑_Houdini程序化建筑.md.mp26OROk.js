import{_ as e,o as i,c as o,ag as r}from"./chunks/framework.Bx1bucHt.js";const b=JSON.parse('{"title":"Houdini波函数坍塌算法的实践——程序化建筑","description":"","frontmatter":{},"headers":[],"relativePath":"全流程美术/Houdini/Houdini程序化建筑/Houdini程序化建筑.md","filePath":"全流程美术/Houdini/Houdini程序化建筑/Houdini程序化建筑.md"}'),t={name:"全流程美术/Houdini/Houdini程序化建筑/Houdini程序化建筑.md"};function n(h,a,l,d,s,u){return i(),o("div",null,[...a[0]||(a[0]=[r('<h1 id="houdini波函数坍塌算法的实践——程序化建筑" tabindex="-1">Houdini波函数坍塌算法的实践——程序化建筑 <a class="header-anchor" href="#houdini波函数坍塌算法的实践——程序化建筑" aria-label="Permalink to &quot;Houdini波函数坍塌算法的实践——程序化建筑&quot;">​</a></h1><h2 id="制作流程" tabindex="-1">制作流程： <a class="header-anchor" href="#制作流程" aria-label="Permalink to &quot;制作流程：&quot;">​</a></h2><ol><li>在houdini中读取基础模型后，拼接成组合模型。整理好</li><li>对组合模块填表</li><li>在houdini中或者引擎中搭建box，使用预处理的HDA，归一化box模型组合，生成点</li><li>在核心HDA中，给基础点基本信息，做数据处理的前置准备</li><li>接下来用HDA里的Python节点，波函数坍塌计算完成后。把点的方向转换成点的法线</li><li>基础模块复制到组合模块的点上。此时程序化制作完成。</li><li>脚本匹配引擎内基础模块的路径。HDA就可以在引擎内生成建筑了</li></ol><h2 id="模块划分及填表" tabindex="-1">模块划分及填表 <a class="header-anchor" href="#模块划分及填表" aria-label="Permalink to &quot;模块划分及填表&quot;">​</a></h2><p>4种尺寸，400,300,200,100</p><h2 id="基础模块制作" tabindex="-1">基础模块制作 <a class="header-anchor" href="#基础模块制作" aria-label="Permalink to &quot;基础模块制作&quot;">​</a></h2><h3 id="_1-墙面基础模块制作" tabindex="-1">1. 墙面基础模块制作 <a class="header-anchor" href="#_1-墙面基础模块制作" aria-label="Permalink to &quot;1. 墙面基础模块制作&quot;">​</a></h3><h3 id="_2-地面基础模块制作" tabindex="-1">2. 地面基础模块制作 <a class="header-anchor" href="#_2-地面基础模块制作" aria-label="Permalink to &quot;2. 地面基础模块制作&quot;">​</a></h3><h3 id="_3-地面多尺寸模块制作" tabindex="-1">3. 地面多尺寸模块制作 <a class="header-anchor" href="#_3-地面多尺寸模块制作" aria-label="Permalink to &quot;3. 地面多尺寸模块制作&quot;">​</a></h3><h2 id="自动导出hda制作" tabindex="-1">自动导出HDA制作 <a class="header-anchor" href="#自动导出hda制作" aria-label="Permalink to &quot;自动导出HDA制作&quot;">​</a></h2><h2 id="组装模型" tabindex="-1">组装模型 <a class="header-anchor" href="#组装模型" aria-label="Permalink to &quot;组装模型&quot;">​</a></h2><p>读取之前的模型，并按表格进行组装<br> 传递进行计算的是一个打包的JSON文件，不是模型本身</p><h3 id="墙面模型组" tabindex="-1">墙面模型组 <a class="header-anchor" href="#墙面模型组" aria-label="Permalink to &quot;墙面模型组&quot;">​</a></h3><h3 id="屋顶模型组" tabindex="-1">屋顶模型组 <a class="header-anchor" href="#屋顶模型组" aria-label="Permalink to &quot;屋顶模型组&quot;">​</a></h3><h3 id="特殊模型组" tabindex="-1">特殊模型组 <a class="header-anchor" href="#特殊模型组" aria-label="Permalink to &quot;特殊模型组&quot;">​</a></h3><h2 id="模块接口写入" tabindex="-1">模块接口写入 <a class="header-anchor" href="#模块接口写入" aria-label="Permalink to &quot;模块接口写入&quot;">​</a></h2><h2 id="python批量导入工具" tabindex="-1">Python批量导入工具 <a class="header-anchor" href="#python批量导入工具" aria-label="Permalink to &quot;Python批量导入工具&quot;">​</a></h2><h2 id="pandas-安装" tabindex="-1">pandas 安装 <a class="header-anchor" href="#pandas-安装" aria-label="Permalink to &quot;pandas 安装&quot;">​</a></h2><h2 id="读取excel表格数据为json" tabindex="-1">读取Excel表格数据为Json <a class="header-anchor" href="#读取excel表格数据为json" aria-label="Permalink to &quot;读取Excel表格数据为Json&quot;">​</a></h2>',19)])])}const q=e(t,[["render",n]]);export{b as __pageData,q as default};
