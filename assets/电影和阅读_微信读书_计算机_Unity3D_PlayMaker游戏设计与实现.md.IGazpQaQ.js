import{_ as t,o as a,c as o,a6 as l}from"./chunks/framework.BB0md0jN.js";const b=JSON.parse('{"title":"Unity3D PlayMaker游戏设计与实现","description":"","frontmatter":{"layout":"doc","title":"Unity3D PlayMaker游戏设计与实现","readingTime":"12 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/计算机/Unity3D_PlayMaker游戏设计与实现.md","filePath":"电影和阅读/微信读书/计算机/Unity3D_PlayMaker游戏设计与实现.md"}'),r={name:"电影和阅读/微信读书/计算机/Unity3D_PlayMaker游戏设计与实现.md"};function c(i,e,n,k,p,u){return a(),o("div",null,[...e[0]||(e[0]=[l('<h1 id="unity3d-playmaker游戏设计与实现" tabindex="-1">Unity3D PlayMaker游戏设计与实现 <a class="header-anchor" href="#unity3d-playmaker游戏设计与实现" aria-label="Permalink to &quot;Unity3D PlayMaker游戏设计与实现&quot;">​</a></h1><p><img src="https://cdn.weread.qq.com/weread/cover/79/YueWen_25449757/t6_YueWen_25449757.jpg" alt=" Unity3D PlayMaker游戏设计与实现"></p><ul><li><strong>书名</strong>： Unity3D PlayMaker游戏设计与实现</li><li><strong>作者</strong>： 周頔 孙辛欣 盛歆漪</li><li><strong>简介</strong>： 与传统软件操作类图书不同的是，本书并没有以PlayMaker的各种组件为顺序进行介绍，而是从如何制作一个完整电子游戏的角度出发，详细介绍了如何使用PlayMaker在Unity3D的环境中设计并开发游戏的各个重要组成部分，包括制作游戏的玩家控制角色，非玩家控制角色，地形、天空、关卡、声音，以及图形用户界面等。本书内容深入浅出，层层递进。通过对本书内容的学习，读者就可以制作出完整的3D游戏。全书分为7章。第1章主要介绍了游戏设计与开发、Unity游戏引擎、PlayMaker可视化编程插件等相关知识。第2章介绍了Unity的获取与使用、Unity的基本操作、PlayMaker的获取与导入、PlayMaker的基本操作。第3章至第7章依次介绍了如何使用PlayMaker和Unity3D开发游戏中的玩家控制角色、战斗型非玩家控制角色、服务型非玩家控制角色、游戏环境的设计、图形用户界面设计以及如何发布游戏。本书附有配套的数字资源，包括书中案例的完整资料，方便读者对照学习。</li><li><strong>出版时间</strong>： 2019-04-01 00:00:00</li><li><strong>ISBN</strong>： 9787121355615</li><li><strong>分类</strong>： 计算机-理论知识</li><li><strong>出版社</strong>： 电子工业出版社</li><li><strong>PC地址</strong>： <a href="https://weread.qq.com/web/reader/d58327d07184551dd58c816" target="_blank" rel="noreferrer">https://weread.qq.com/web/reader/d58327d07184551dd58c816</a></li></ul><h2 id="内容导读" tabindex="-1">内容导读 <a class="header-anchor" href="#内容导读" aria-label="Permalink to &quot;内容导读&quot;">​</a></h2><blockquote><p>📌 PlayMaker在 Unity3D中控制游戏对象的方法，包括平铺直叙式 FSM、多 FSM协同式。 ⏱ 2023-03-15 21:13:49</p></blockquote><h2 id="chapter-01-游戏设计概论" tabindex="-1">CHAPTER 01 游戏设计概论 <a class="header-anchor" href="#chapter-01-游戏设计概论" aria-label="Permalink to &quot;CHAPTER 01 游戏设计概论&quot;">​</a></h2><blockquote><p>📌 PlayMaker 的使用逻辑其实非常清晰：游戏中的物体如果要进行某种行为，不管这个行为有多复杂，一般而言它都可以细分成一个由多个步骤组成的序列。 ⏱ 2021-02-08 01:57:10</p></blockquote><blockquote><p>📌 如果把行为中的每一个步骤都称为一个状态（State），那么整个行为就可以通过把多个状态相互连接来表示。这些状态之间的连接，也就是从一个状态跳转至另一个状态的转换事件（Transition）。而这种把多个状态连接到一起、共同表现游戏对象的某种行为的方式，就被称为有限状态机（Finite State Machine，FSM） ⏱ 2021-02-08 01:57:33</p></blockquote><blockquote><p>📌 对于每一个步骤来说，又可以继续向下细分为一系列的动作（Action）。这种由 Action-State-Transition-FSM 构成的描述逻辑，正是PlayMaker替代程序、控制Unity中游戏对象的基础。 ⏱ 2021-02-08 01:57:53</p></blockquote><blockquote><p>📌 除了直接使用 PlayMaker 中的资源，开发团队还根据《炉石传说》的属性另行开发了包括卡牌、魔法、金钱等在内的众多专有 Action，集合成一个名为“Pegasus”的 PlayMaker Action包。这些专有Action，再加上PlayMaker自带的Action，就控制了《炉石传说》中涉及玩家的所有事物和行为。 ⏱ 2021-02-08 01:59:38</p></blockquote><h2 id="chapter-02-初识unity3d和playmaker" tabindex="-1">CHAPTER 02 初识Unity3D和PlayMaker <a class="header-anchor" href="#chapter-02-初识unity3d和playmaker" aria-label="Permalink to &quot;CHAPTER 02 初识Unity3D和PlayMaker&quot;">​</a></h2><blockquote><p>📌 采用多个 FSM 不仅可以让每个 FSM 中的动作逻辑更清晰简单、便于阅读，而且不同动作之间相互独立，避免了相互干扰。这样即便后续再对某个动作进行修改，也不会对其他动作造成影响。 ⏱ 2023-07-04 09:09:45</p></blockquote><blockquote><p>📌 如果一个角色或者物体需要完成多个不同类型的行为，那么每一种行为就用一个 FSM，也就是用一个 FSM 来负责描述这种行为的执行步骤。所以一个FSM中通常含有多个State（状态），每个 State都需要完成一些预先设定好的 Action（动作），不同 State之间会设置有各种跳转的规则，这些规则被称为 Transition（转换事件）。 ⏱ 2023-07-04 09:15:51</p></blockquote><blockquote><p>📌 38] 如果不勾选，该FSM在游戏开始后就不会被执行。除非它被其他FSM调用。 ⏱ 2023-07-04 09:16:54</p></blockquote><h2 id="chapter-03-玩家控制角色的设计" tabindex="-1">CHAPTER 03 玩家控制角色的设计 <a class="header-anchor" href="#chapter-03-玩家控制角色的设计" aria-label="Permalink to &quot;CHAPTER 03 玩家控制角色的设计&quot;">​</a></h2><blockquote><p>📌 Unity 默认的系统单位是米（m），但各种 3D 建模软件默认的系统单位却并不都是米。 ⏱ 2023-07-04 09:23:46</p></blockquote><blockquote><p>📌 设置 5 个独立的 FSM：Walk FSM、Rotate FSM、Jump FSM、Attack FSM、Pick FSM，分别用来控制Hero的前/后移动、左/右转动、跳跃、攻击敌人、收集物体。 ⏱ 2023-07-04 09:46:09</p></blockquote><blockquote><p>📌 所以还必须给Hero设置一个Health FSM，作为它的生命系统。控制它什么时候死亡，什么时候复活。 ⏱ 2023-07-04 09:47:12</p></blockquote><blockquote><p>📌 对于左/右转向这种行为，不需要播放任何动画，只需要让 Hero 绕Y轴旋转一定角度即可。 ⏱ 2023-07-04 09:49:28</p></blockquote><blockquote><p>📌 至此，运行整个项目可以发现，Hero 已经能在玩家按下 Up 键/W键时往前走，按 Down 键/S 键时往后走，按 Left 键/A 键时向左转，按Right 键/D 键时向右转。而且 Hero 还能边行走边转向，比如 Hero 可以在按住 Up 键时对 Left 键进行响应，即边向前走边转向；当 Up 键和Left键都按下时，对松开Left键进行响应，即Hero结束转向继续往前走。 ⏱ 2023-07-04 09:49:55</p></blockquote><blockquote><p>📌 1.Walk FSM 中的状态 Rest 里有一个动作专门用来播放 Hero 休息时的动画，而 Rotate FSM 中的 Rest 状态里没有。这是因为Walk FSM 与 Rotate FSM 是同时执行的，如果 Rotate FSM 的Rest状态中也播放 Hero休息时的动画，那么就会与 Walk FSM中播放休息动画的动作重叠，而且我们是随机选择播放两个休息动画，因此可能造成 Walk FSM 中的动画和 Rotate FSM 中的动画冲突。所以我们只在 Rotate FSM 的 Rest 状态中进行左键右键的按下判断，而不做其他别的事情。 ⏱ 2023-07-04 09:50:42</p></blockquote><blockquote><p>📌 这里面其实包含两部分内容：第一部分需要让 Hero做出挥拳攻击的动作，第二部分需要检测挥出的拳是否真的击中了敌人，如果击中了敌人，还需要扣除敌人一定量的生命值。 ⏱ 2023-07-04 19:02:32</p></blockquote><blockquote><p>📌 。而 PlayMaker 中并没有现成的Action 能控制物体流畅地进行速度由快变慢、再由慢变快的位移。这是PlayMaker的缺陷。 ⏱ 2023-07-04 19:04:22</p></blockquote><blockquote><p>📌 因此，此处需要使用一个脚本（Script）来完成这个工作。 ⏱ 2023-07-04 19:04:29</p></blockquote><blockquote><p>📌 。无论是哪一种收集，其行为模式都可以概括为：移动至距离目标物体一定范围内，然后按下某个键（比如 Z 键），目标物体就会消失，代表该物体已经被角色收集到了。 ⏱ 2023-07-04 19:06:04</p></blockquote><blockquote><p>📌 我们将 Pick FSM 中的行为逻辑按如下流程进行设计：当角色与目标物体距离小于 2 个单位时，玩家可以通过按 Z 键捡拾这个物体；当距离大于等于 2 个单位时，即使按下 Z 键也不会发生捡拾的动作；角色与目标物体距离小于2个单位时，也可以决定不捡这个物体，而是转身离开；一旦物体被角色捡走，那么这个物体从场景中消失；角色会记住自己已经捡到多少个此类物体。 ⏱ 2023-07-04 19:06:52</p></blockquote><h2 id="chapter-04-非玩家控制角色的设计一-战斗型npc" tabindex="-1">CHAPTER 04 非玩家控制角色的设计一：战斗型NPC <a class="header-anchor" href="#chapter-04-非玩家控制角色的设计一-战斗型npc" aria-label="Permalink to &quot;CHAPTER 04 非玩家控制角色的设计一：战斗型NPC&quot;">​</a></h2><blockquote><p>📌 ，这些角色主要可以分为以下三种：1.战斗型 NPC：指能武力攻击对手的那些 NPC，有的属于玩家的友军，能帮助玩家控制角色攻击游戏中的敌人；有的属于玩家的敌军，如果玩家击杀他们，就能获得相应的荣誉值、经验值，或者装备。2.服务型 NPC：指为玩家控制角色提供各种服务的 NPC，比如通过聊天等方式为玩家控制角色提供辅助信息，推动剧情的发展，引导玩家的下一步行为，或者作为店主，给玩家控制角色提供一些交易。3.路人型 NPC：指游戏中那些与玩家控制角色没有互动的 NPC。 ⏱ 2023-07-04 21:11:56</p></blockquote><blockquote><p>📌 我们把 PCC 的行为分成前/后移动、转向、攻击、跳跃、收集共五个互相独立的部分，而且这五部分不存在先后关系。什么时候调用哪个部分，完全是由用户按键决定的， ⏱ 2023-07-04 21:17:48</p></blockquote><blockquote><p>📌 但是 NPC 则不同，他们的行为完全不受玩家的控制，也就是说必须要如图 4.2 所示，设置一个总体行为管理模块，由这个管理模块来决定什么时候调用哪个具体的下属功能模块。 ⏱ 2023-07-04 21:17:38</p></blockquote><blockquote><p>📌 大致可以分成巡逻、追击、攻击这三种行为。其中，将“追击”定义为朝向目标的快速移动，而“攻击”表示会对目标造成伤害的进攻行为。 ⏱ 2023-07-04 21:18:23</p></blockquote>',31)])])}const s=t(r,[["render",c]]);export{b as __pageData,s as default};
