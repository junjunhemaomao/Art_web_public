import{_ as i,o as a,c as e,a6 as r}from"./chunks/framework.BB0md0jN.js";const S=JSON.parse('{"title":"Unity Shader入门精要","description":"","frontmatter":{"layout":"doc","title":"Unity Shader入门精要","readingTime":"32 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/计算机/Unity_Shader入门精要.md","filePath":"电影和阅读/微信读书/计算机/Unity_Shader入门精要.md"}'),u={name:"电影和阅读/微信读书/计算机/Unity_Shader入门精要.md"};function t(h,l,n,d,p,s){return a(),e("div",null,[...l[0]||(l[0]=[r('<h1 id="unity-shader入门精要" tabindex="-1">Unity Shader入门精要 <a class="header-anchor" href="#unity-shader入门精要" aria-label="Permalink to &quot;Unity Shader入门精要&quot;">​</a></h1><p><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/473/22691473/t7_22691473.jpg" alt=" Unity Shader入门精要"></p><ul><li><strong>书名</strong>： Unity Shader入门精要</li><li><strong>作者</strong>： 冯乐乐</li><li><strong>简介</strong>： 本书不仅要教会读者如何使用Unity Shader，更重要的是要帮助读者学习Unity中的一些渲染机制以及如何使用Unity Shader实现各种自定义的渲染效果，希望这本书可以为读者打开一扇新的大门，让读者离制作心目中杰出游戏的心愿更近一步。</li><li><strong>出版时间 2016-06-01 00</strong>: 00:00</li><li><strong>ISBN</strong>： 9787115423054</li><li><strong>分类</strong>： 计算机-编程设计</li><li><strong>出版社</strong>： 人民邮电出版社</li></ul><h2 id="_1-1-程序员的三大浪漫" tabindex="-1">1.1 程序员的三大浪漫 <a class="header-anchor" href="#_1-1-程序员的三大浪漫" aria-label="Permalink to &quot;1.1 程序员的三大浪漫&quot;">​</a></h2><ul><li><p>📌 因为Shader需要牵扯到整个渲染流程。当学习C++、C#这样的高级语言时，我们可以在不了解计算机架构的情况下仍然编写出实现各种功能的代码，这样的高级语言更符合人类的思维方式。然而，Shader并不是这样的。</p><ul><li>⏱ 2021-04-12 23:11:26</li></ul></li><li><p>📌 Shader只是整个渲染流程中的一个子部分。虽然它很关键，但想要学习它，我们就需要了解整个渲染流程是如何进行的。</p><ul><li>⏱ 2021-04-12 23:17:05</li></ul></li><li><p>📌 尽管Shader的编写语言已经达到了我们可以理解的程度，但Shader更多地是面向GPU的工作方式，所以它的一些语法对我们来说并不那么直观。因此，任何一篇只讲语法、不讲渲染框架的文章都无法解决读者的困惑。</p><ul><li>⏱ 2021-04-12 23:17:17</li></ul></li></ul><h2 id="第2章-渲染流水线" tabindex="-1">第2章 渲染流水线 <a class="header-anchor" href="#第2章-渲染流水线" aria-label="Permalink to &quot;第2章 渲染流水线&quot;">​</a></h2><ul><li>📌 渲染流水线的最终目的在于生成或者说是渲染一张二维纹理，即我们在电脑屏幕上看到的所有效果。它的输入是一个虚拟摄像机、一些光源、一些Shader以及纹理等。 <ul><li>⏱ 2022-12-26 16:36:52</li></ul></li></ul><h2 id="_2-1-综述" tabindex="-1">2.1 综述 <a class="header-anchor" href="#_2-1-综述" aria-label="Permalink to &quot;2.1 综述&quot;">​</a></h2><ul><li><p>📌 渲染流程分成3个阶段：应用阶段（Application Stage）、几何阶段（Geometry Stage）、光栅化阶段（Rasterizer Stage）。</p><ul><li>⏱ 2021-04-13 00:45:00</li></ul></li><li><p>📌 这一阶段最重要的输出是渲染所需的几何信息，即渲染图元（rendering primitives）。</p><ul><li>⏱ 2021-04-13 00:45:51</li></ul></li><li><p>📌 几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。通过对输入的渲染图元进行多步处理后，这一阶段将会输出屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等相关信息，并传递给下一个阶段。</p><ul><li>⏱ 2021-04-13 00:46:51</li></ul></li><li><p>📌 光栅化阶段这一阶段将会使用上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。这一阶段也是在GPU上运行。光栅化的任务主要是决定每个渲染图元中的哪些像素应该被绘制在屏幕上。它需要对上一个阶段得到的逐顶点数据（例如纹理坐标、顶点颜色等）进行插值，然后再进行逐像素处理。</p><ul><li>⏱ 2021-04-13 00:47:16</li></ul></li></ul><h2 id="_2-2-cpu和gpu之间的通信" tabindex="-1">2.2 CPU和GPU之间的通信 <a class="header-anchor" href="#_2-2-cpu和gpu之间的通信" aria-label="Permalink to &quot;2.2 CPU和GPU之间的通信&quot;">​</a></h2><ul><li><p>📌 显卡对于显存的访问速度更快，而且大多数显卡对于RAM没有直接的访问权利。</p><ul><li>⏱ 2021-04-13 00:51:53</li></ul></li><li><p>📌 当把数据加载到显存中后，RAM中的数据就可以移除了。但对于一些数据来说，CPU仍然需要访问它们（例如，我们希望CPU可以访问网格数据来进行碰撞检测），那么我们可能就不希望这些数据被移除，因为从硬盘加载到RAM的过程是十分耗时的。</p><ul><li>⏱ 2021-04-13 00:53:03</li></ul></li><li><p>📌 在准备好上述所有工作后，CPU就需要调用一个渲染命令来告诉GPU:“嘿！老兄，我都帮你把数据准备好啦，你可以按照我的设置来开始渲染啦！”而这个渲染命令就是Draw Call。</p><ul><li>⏱ 2021-04-13 01:35:56</li></ul></li><li><p>📌 Draw Call就是一个命令，它的发起方是CPU，接收方是GPU。</p><ul><li>⏱ 2021-04-16 13:43:05</li></ul></li></ul><h2 id="_2-3-gpu流水线" tabindex="-1">2.3 GPU流水线 <a class="header-anchor" href="#_2-3-gpu流水线" aria-label="Permalink to &quot;2.3 GPU流水线&quot;">​</a></h2><ul><li><p>📌 顶点着色器的处理单位是顶点，也就是说，输入进来的每个顶点都会调用一次顶点着色器。顶点着色器本身不可以创建或者销毁任何顶点，而且无法得到顶点与顶点之间的关系。例如，我们无法得知两个顶点是否属于同一个三角网格。但正是因为这样的相互独立性，GPU可以利用本身的特性并行化处理每一个顶点，这意味着这一阶段的处理速度会很快。</p><ul><li>⏱ 2021-04-16 13:55:09</li></ul></li><li><p>📌 顶点着色器可以在这一步中改变顶点的位置，这在顶点动画中是非常有用的。例如，我们可以通过改变顶点位置来模拟水面、布料等。</p><ul><li>⏱ 2021-04-16 13:56:19</li></ul></li><li><p>📌 ，完全在视野外的图元不会继续向下传递，因为它们不需要被渲染。而那些部分在视野内的图元需要进行一个处理，这就是裁剪。例如，一条线段的一个顶点在视野内，而另一个顶点不在视野内，那么在视野外部的顶点应该使用一个新的顶点来代替，这个新的顶点位于这条线段和视野边界的交点处。</p><ul><li>⏱ 2021-04-16 13:59:40</li></ul></li><li><p>📌 产生这种差异的原因是，微软的窗口都使用了这样的坐标系统，因为这和我们的阅读方式是一致的：从左到右、从上到下，并且很多图像文件也是按照这样的格式进行存储的。不管原因如何，差异就这么造成了。留给我们开发者的就是，要时刻小心这样的差异，如果你发现得到的图像是倒转的，那么很有可能就是这个原因造成的。</p><ul><li>⏱ 2021-04-16 14:02:58</li></ul></li><li><p>📌 光栅化阶段有两个最重要的目标：计算每个图元覆盖了哪些像素，以及为这些像素计算它们的颜色。</p><ul><li>⏱ 2021-04-16 14:11:05</li></ul></li><li><p>📌 但如果要得到整个三角网格对像素的覆盖情况，我们就必须计算每条边上的像素坐标。</p><ul><li>⏱ 2021-04-16 14:13:06</li></ul></li><li><p>📌 如果一个幸运的片元通过了上面的所有测试，它就可以自豪地来到合并功能的面前。</p><ul><li>⏱ 2021-11-14 01:50:22</li></ul></li><li><p>📌 更多时候，我们只需要在一个Unity Shader设置一些输入、编写顶点着色器和片元着色器、设置一些状态就可以达到大部分常见的屏幕效果。</p><ul><li>⏱ 2021-11-14 01:52:18</li></ul></li><li><p>📌 渲染流水线几乎和本书所有章节都息息相关，如果读者此时仍然无法完全理解渲染流水线，仍可以继续学习下去。但如果读者在学习过程中发现有些设置或代码无法理解，可以不断查阅本章内容，相信会有更深的理解。</p><ul><li>⏱ 2021-11-14 02:07:44</li></ul></li></ul><h2 id="_2-4-一些容易困惑的地方" tabindex="-1">2.4 一些容易困惑的地方 <a class="header-anchor" href="#_2-4-一些容易困惑的地方" aria-label="Permalink to &quot;2.4 一些容易困惑的地方&quot;">​</a></h2><ul><li><p>📌 一个常见的误区是，Draw Call中造成性能问题的元凶是GPU，认为GPU上的状态切换是耗时的，其实不是的，真正“拖后腿”其实的是CPU。</p><ul><li>⏱ 2021-11-14 02:14:53</li></ul></li><li><p>📌 GPU的渲染能力是很强的，渲染200个还是2000个三角网格通常没有什么区别，因此渲染速度往往快于CPU提交命令的速度。如果Draw Call的数量太多，CPU就会把大量时间花费在提交Draw Call上，造成CPU的过载。</p><ul><li>⏱ 2021-11-14 02:16:50</li></ul></li><li><p>📌 提交大量很小的Draw Call会造成CPU的性能瓶颈，即CPU把时间都花费在准备Draw Call的工作上了。那么，一个很显然的优化想法就是把很多小的DrawCall合并成一个大的Draw Call，这就是批处理的思想。</p><ul><li>⏱ 2021-11-14 02:18:02</li></ul></li><li><p>📌 ，批处理技术更加适合于那些静态的物体，例如不会移动的大地、石头等，对于这些静态物体我们只需要合并一次即可。</p><ul><li>⏱ 2021-11-14 02:18:52</li></ul></li><li><p>📌 在游戏开发过程中，为了减少Draw Call的开销，有两点需要注意。（1）避免使用大量很小的网格。当不可避免地需要使用很小的网格结构时，考虑是否可以合并它们。（2）避免使用过多的材质。尽量在不同的网格之间共用同一个材质。</p><ul><li>⏱ 2021-11-14 02:20:09</li></ul></li><li><p>📌 如果读者不是为了对较旧的设备进行兼容，不建议继续使用固定管线的渲染方式。</p><ul><li>⏱ 2021-11-14 02:20:38</li></ul></li></ul><h2 id="_2-5-那么-你明白什么是shader了吗" tabindex="-1">2.5 那么，你明白什么是Shader了吗 <a class="header-anchor" href="#_2-5-那么-你明白什么是shader了吗" aria-label="Permalink to &quot;2.5 那么，你明白什么是Shader了吗&quot;">​</a></h2><ul><li><p>📌 我们之所以要花很大篇幅来讲述GPU的渲染流水线，是因为Shader所在的阶段就是渲染流水线的一部分，更具体来说，Shader就是：·GPU流水线上一些可高度编程的阶段，而由着色器编译出来的最终代码是会在GPU上运行的（对于固定管线的渲染来说，着色器有时等同于一些特定的渲染设置）；·有一些特定类型的着色器，如顶点着色器、片元着色器等；·依靠着色器我们可以控制流水线中的渲染细节，例如用顶点着色器来进行顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。但同时，我们也要明白，要得到出色的游戏画面是需要包括Shader在内的所有渲染流水线阶段的共同参与才可完成：设置适当的渲染状态，使用合适的混合函数，开启还是关闭深度测试/深度写入等。Unity作为一个出色的编辑工具，为我们提供了一个既可以方便地编写着色器，同时又可设置渲染状态的地方：Unity Shader。在下一章中，我们将真正走进Unity Shader的世界。</p><ul><li>⏱ 2021-11-14 02:29:56</li></ul></li><li><p>📌 ·依靠着色器我们可以控制流水线中的渲染细节，例如用顶点着色器来进行顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。</p><ul><li>⏱ 2021-11-14 02:21:59</li></ul></li></ul><h2 id="第3章-unity-shader基础" tabindex="-1">第3章 Unity Shader基础 <a class="header-anchor" href="#第3章-unity-shader基础" aria-label="Permalink to &quot;第3章 Unity Shader基础&quot;">​</a></h2><ul><li>📌 Shader并不是什么神秘的东西，它们其实就是渲染流水线中的某些特定阶段，如顶点着色器阶段、片元着色器阶段等。 <ul><li>⏱ 2021-11-14 02:31:14</li></ul></li></ul><h2 id="_3-1-unity-shader概述" tabindex="-1">3.1 Unity Shader概述 <a class="header-anchor" href="#_3-1-unity-shader概述" aria-label="Permalink to &quot;3.1 Unity Shader概述&quot;">​</a></h2><ul><li><p>📌 Unity Shader定义了渲染所需的各种代码（如顶点着色器和片元着色器）、属性（如使用哪些纹理等）和指令（渲染和标签设置等），而材质则允许我们调节这些属性，并将其最终赋给相应的模型。</p><ul><li>⏱ 2021-11-14 02:33:47</li></ul></li><li><p>📌 Unity一共提供了4种Unity Shader模板供我们选择——Standard Surface Shader, Unlit Shader, Image Effect Shader以及Compute Shader。</p><ul><li>⏱ 2021-11-14 02:36:16</li></ul></li><li><p>📌 Unlit Shader则会产生一个不包含光照（但包含雾效）的基本的顶点/片元着色器</p><ul><li>⏱ 2021-11-14 02:36:40</li></ul></li><li><p>📌 Image Effect Shader则为我们实现各种屏幕后处理效果</p><ul><li>⏱ 2021-11-14 02:39:23</li></ul></li><li><p>📌 本书的重点在于如何在Unity中编写顶点/片元着色器，因此在后续的学习中，我们通常会使用Unlit Shader来生成一个基本的顶点/片元着色器模板。</p><ul><li>⏱ 2021-11-14 02:39:51</li></ul></li><li><p>📌 Unity Shader本质上就是一个文本文件。</p><ul><li>⏱ 2021-11-14 02:41:05</li></ul></li></ul><h2 id="_3-2-unity-shader的基础-shaderlab" tabindex="-1">3.2 Unity Shader的基础：ShaderLab <a class="header-anchor" href="#_3-2-unity-shader的基础-shaderlab" aria-label="Permalink to &quot;3.2 Unity Shader的基础：ShaderLab&quot;">​</a></h2><ul><li><p>📌 学习和编写着色器的过程一直是一个学习曲线很陡峭的过程。通常情况下，为了自定义渲染效果往往需要和很多文件和设置打交道，这些过程很容易消磨掉初学者的耐心。</p><ul><li>⏱ 2021-11-14 02:45:19</li></ul></li><li><p>📌 在Unity中，所有的Unity Shader都是使用ShaderLab来编写的。ShaderLab是Unity提供的编写Unity Shader的一种说明性语言。</p><ul><li>⏱ 2021-11-14 02:46:45</li></ul></li><li><p>📌 Properties语句块中定义了着色器所需的各种属性，这些属性将会出现在材质面板中。</p><ul><li>⏱ 2021-11-14 02:48:04</li></ul></li><li><p>📌 它们都定义了要显示一个材质所需的所有东西，而不仅仅是着色器代码。</p><ul><li>⏱ 2021-11-14 02:48:31</li></ul></li><li><p>📌 Unity在背后会根据使用的平台来把这些结构编译成真正的代码和Shader文件，而开发者只需要和Unity Shader打交道即可。</p><ul><li>⏱ 2021-11-14 02:49:10</li></ul></li></ul><h2 id="_3-3-unity-shader的结构" tabindex="-1">3.3 Unity Shader的结构 <a class="header-anchor" href="#_3-3-unity-shader的结构" aria-label="Permalink to &quot;3.3 Unity Shader的结构&quot;">​</a></h2><ul><li><p>📌 通过在字符串中添加斜杠（“/”），可以控制Unity Shader在材质面板中出现的位置。</p><ul><li>⏱ 2021-11-14 02:52:49</li></ul></li><li><p>📌 材质和Unity Shader的桥梁：PropertiesProperties语义块中包含了一系列属性（property），这些属性将会出现在材质面板中。</p><ul><li>⏱ 2021-11-14 13:33:26</li></ul></li><li><p>📌 如果我们需要在Shader中访问它们，就需要使用每个属性的名字（Name）。在Unity中，这些属性的名字通常由一个下划线开始。显示的名称（display name）则是出现在材质面板上的名字。</p><ul><li>⏱ 2022-01-20 16:09:37</li></ul></li><li><p>📌 对于2D、Cube、3D这3种纹理类型，默认值的定义稍微复杂，它们的默认值是通过一个字符串后跟一个花括号来指定的，其中，字符串要么是空的，要么是内置的纹理名称，如“white”“black”“gray”或者“bump”。</p><ul><li>⏱ 2022-01-20 16:17:25</li></ul></li><li><p>📌 即使我们不在Properties语义块中声明这些属性，也可以直接在CG代码片中定义变量。此时，我们可以通过脚本向Shader中传递这些属性。因此，Properties语义块的作用仅仅是为了让这些属性可以出现在材质面板中。</p><ul><li>⏱ 2021-11-14 13:36:14</li></ul></li><li><p>📌 重量级成员：SubShader每一个Unity Shader文件可以包含多个SubShader语义块，但最少要有一个。当Unity需要加载这个Unity Shader时，Unity会扫描所有的SubShader语义块，然后选择第一个能够在目标平台上运行的SubShader。如果都不支持的话，Unity就会使用Fallback语义指定的Unity Shader。</p><ul><li>⏱ 2021-11-14 13:39:19</li></ul></li><li><p>📌 Unity提供这种语义的原因在于，不同的显卡具有不同的能力。</p><ul><li>⏱ 2021-11-14 13:39:30</li></ul></li><li><p>📌 每个Pass定义了一次完整的渲染流程，但如果Pass的数目过多，往往会造成渲染性能的下降。因此，我们应尽量使用最小数目的Pass</p><ul><li>⏱ 2021-11-14 13:56:28</li></ul></li><li><p>📌 ShaderLab提供了一系列渲染状态的设置指令，这些指令可以设置显卡的各种状态，例如是否开启混合/深度测试等</p><ul><li>⏱ 2021-11-14 14:04:36</li></ul></li><li><p>📌 当在SubShader块中设置了上述渲染状态时，将会应用到所有的Pass。</p><ul><li>⏱ 2021-11-14 14:05:06</li></ul></li><li><p>📌 SubShader的标签（Tags）是一个键值对（Key/Value Pair），它的键和值都是字符串类型。这些键值对是SubShader和渲染引擎之间的沟通桥梁。它们用来告诉Unity的渲染引擎：SubShader我希望怎样以及何时渲染这个对象。</p><ul><li>⏱ 2022-01-20 20:03:39</li></ul></li><li><p>📌 上述标签仅可以在SubShader中声明，而不可以在Pass块中声明。</p><ul><li>⏱ 2022-01-20 20:06:45</li></ul></li><li><p>📌 通过这个名称，我们可以使用ShaderLab的UsePass命令来直接使用其他Unity Shader中的Pass。例如： UsePass &quot;MyShader/MYPASSNAME&quot;</p><ul><li>⏱ 2021-11-14 14:53:04</li></ul></li><li><p>📌 在渲染阴影纹理时，Unity会在每个Unity Shader中寻找一个阴影投射的Pass。通常情况下，我们不需要自己专门实现一个Pass，这是因为Fallback使用的内置Shader中包含了这样一个通用的Pass。</p><ul><li>⏱ 2021-11-14 14:20:14</li></ul></li></ul><h2 id="_3-4-unity-shader的形式" tabindex="-1">3.4 Unity Shader的形式 <a class="header-anchor" href="#_3-4-unity-shader的形式" aria-label="Permalink to &quot;3.4 Unity Shader的形式&quot;">​</a></h2><ul><li><p>📌 也就是说，当给Unity提供一个表面着色器的时候，它在背后仍旧把它转换成对应的顶点/片元着色器。我们可以理解成，表面着色器是Unity对顶点/片元着色器的更高一层的抽象。</p><ul><li>⏱ 2021-11-14 14:40:25</li></ul></li><li><p>📌 表面着色器被定义在SubShader语义块（而非Pass语义块）中的CGPROGRAM和ENDCG之间。</p><ul><li>⏱ 2021-11-14 14:52:06</li></ul></li><li><p>📌 CGPROGRAM和ENDCG之间的代码是使用CG/HLSL编写的，也就是说，我们需要把CG/HLSL语言嵌套在ShaderLab语言中。</p><ul><li>⏱ 2021-11-14 14:50:06</li></ul></li><li><p>📌 顶点/片元着色器是写在Pass语义块内，而非SubShader内的。</p><ul><li>⏱ 2021-11-14 15:07:15</li></ul></li><li><p>📌 实际上，在Unity 5.2中，所有固定函数着色器都会在背后被Unity编译成对应的顶点/片元着色器，因此真正意义上的固定函数着色器已经不存在了。</p><ul><li>⏱ 2021-11-14 15:09:10</li></ul></li><li><p>📌 如果你想和各种光源打交道，你可能更喜欢使用表面着色器，但需要小心它在移动平台的性能表现。·如果你需要使用的光照数目非常少，例如只有一个平行光，那么使用顶点/片元着色器是一个更好的选择。·最重要的是，如果你有很多自定义的渲染效果，那么请选择顶点/片元着色器。</p><ul><li>⏱ 2021-11-14 15:11:40</li></ul></li></ul><h2 id="_3-5-本书使用的unity-shader形式" tabindex="-1">3.5 本书使用的Unity Shader形式 <a class="header-anchor" href="#_3-5-本书使用的unity-shader形式" aria-label="Permalink to &quot;3.5 本书使用的Unity Shader形式&quot;">​</a></h2><ul><li>📌 仅仅了解高层抽象虽然可能会暂时使工作简化，但从长久来看“知其然而不知其所以然”所带来的影响更加深远。 <ul><li>⏱ 2021-11-14 15:13:43</li></ul></li></ul><h2 id="_3-6-答疑解惑" tabindex="-1">3.6 答疑解惑 <a class="header-anchor" href="#_3-6-答疑解惑" aria-label="Permalink to &quot;3.6 答疑解惑&quot;">​</a></h2><ul><li><p>📌 在Unity里，Unity Shader实际上指的就是一个ShaderLab文件——硬盘上以．shader作为文件后缀的一种文件。</p><ul><li>⏱ 2021-11-15 00:38:15</li></ul></li><li><p>📌 可以说，从本质上来讲，UnityShader只有两种形式：顶点/片元着色器和固定函数着色器（在Unity 5.2以后的版本中，固定函数着色器也会在背后被转化成顶点/片元着色器，因此从本质上来说Unity中只存在顶点/片元着色器）。</p><ul><li>⏱ 2022-01-21 14:38:33</li></ul></li></ul><h2 id="_4-2-笛卡儿坐标系" tabindex="-1">4.2 笛卡儿坐标系 <a class="header-anchor" href="#_4-2-笛卡儿坐标系" aria-label="Permalink to &quot;4.2 笛卡儿坐标系&quot;">​</a></h2><ul><li><p>📌 伸出你的中指，不出意外的话它应该指向你的前方（如果你一定要展示自己骨骼惊奇的话我也没有办法）。</p><ul><li>⏱ 2021-11-18 09:47:49</li></ul></li><li><p>📌 左右手坐标系之间是可以进行互相转换的。最简单的方法就是把其中一个轴反转，并保持其他两个轴不变。</p><ul><li>⏱ 2022-01-21 14:47:36</li></ul></li><li><p>📌 对于开发者来说，使用左手坐标系还是右手坐标系都是可以的，它们之间并没有优劣之分。无论使用哪种坐标系，绝大多数情况下并不会影响底层的数学运算，而只是在映射到视觉上时会有差别</p><ul><li>⏱ 2022-01-21 14:47:28</li></ul></li><li><p>📌 我们可以分别在一个左手坐标系和右手坐标系中描述这样一次运动，即使用数学表达式来描述它。我们会发现，在不同的坐标系中描述这样同一次运动是不一样的，如图4.11所示。</p><ul><li>⏱ 2022-01-21 14:48:35</li></ul></li><li><p>📌 可以看出，为了达到同样的视觉效果（这里指把妞妞移动到视觉上的同一个位置），左右手坐标系在z轴上的移动以及旋转方向是不同的。如果使用相同的数学运算（指均向z轴某方向移动或均朝旋转正方向旋转等），那么得到的视觉效果就是不一样的。因此，如果我们需要从左手坐标系迁移到右手坐标系，并且保持视觉上的不变，就需要进行一些转换。</p><ul><li>⏱ 2022-01-21 14:48:59</li></ul></li><li><p>📌 Unity使用的是左手坐标系。</p><ul><li>⏱ 2022-01-21 14:49:09</li></ul></li><li><p>📌 这意味着，在模型空间中，一个物体的右侧（right）、上侧（up）和前侧（forward）分别对应了x轴、y轴和z轴的正方向。</p><ul><li>⏱ 2022-01-21 14:49:56</li></ul></li></ul><h2 id="_5-1-本书使用的软件和环境" tabindex="-1">5.1 本书使用的软件和环境 <a class="header-anchor" href="#_5-1-本书使用的软件和环境" aria-label="Permalink to &quot;5.1 本书使用的软件和环境&quot;">​</a></h2><ul><li><p>📌 在书中经常会使用UnityObjectToWorldNormal内置函数把法线从模型空间变换到世界空间中，但这个函数是在Unity 5中被引入的</p><ul><li>⏱ 2022-01-21 14:58:34</li></ul></li><li><p>📌 Mac使用的图像编程接口是基于OpenGL的</p><ul><li>⏱ 2022-01-21 15:00:55</li></ul></li></ul><h2 id="_5-2-一个最简单的顶点-片元着色器" tabindex="-1">5.2 一个最简单的顶点/片元着色器 <a class="header-anchor" href="#_5-2-一个最简单的顶点-片元着色器" aria-label="Permalink to &quot;5.2 一个最简单的顶点/片元着色器&quot;">​</a></h2><ul><li><p>📌 #pragma vertex vert #pragma fragment frag它们将告诉Unity，哪个函数包含了顶点着色器的代码，哪个函数包含了片元着色器的代码。更通用的编译指令表示如下： #pragma vertex name #pragma fragment name其中name就是我们指定的函数名，这两个函数的名字不一定是vert和frag，它们可以是任意自定义的合法函数名，但我们一般使用vert和frag来定义这两个函数，因为它们很直观。</p><ul><li>⏱ 2022-01-21 15:34:34</li></ul></li><li><p>📌 vert函数的输入v包含了这个顶点的位置，这是通过POSITION语义指定的。它的返回值是一个float4类型的变量，它是该顶点在裁剪空间中的位置，POSITION和SV_POSITION都是CG/HLSL中的语义（semantics），它们是不可省略的，</p><ul><li>⏱ 2022-01-21 15:36:42</li></ul></li><li><p>📌 例如这里，POSITION将告诉Unity，把模型的顶点坐标填充到输入参数v中，SV_POSITION将告诉Unity，顶点着色器的输出是裁剪空间中的顶点坐标。</p><ul><li>⏱ 2022-01-21 16:00:41</li></ul></li><li><p>📌 UNITY_MATRIX_MVP矩阵是Unity内置的模型·观察·投影矩阵</p><ul><li>⏱ 2022-01-21 16:06:00</li></ul></li><li><p>📌 SV_Target也是HLSL中的一个系统语义，它等同于告诉渲染器，把用户的输出颜色存储到一个渲染目标（render target）中，这里将输出到默认的帧缓存中。</p><ul><li>⏱ 2022-01-21 16:07:27</li></ul></li><li><p>📌 这个需求是很常见的，我们需要使用纹理坐标来访问纹理，而法线可用于计算光照。</p><ul><li>⏱ 2022-01-21 16:09:21</li></ul></li></ul><h2 id="_6-2-标准光照模型" tabindex="-1">6.2 标准光照模型 <a class="header-anchor" href="#_6-2-标准光照模型" aria-label="Permalink to &quot;6.2 标准光照模型&quot;">​</a></h2><ul><li>📌 在标准光照模型中，我们使用了一种被称为环境光的部分来近似模拟间接光照。环境光的计算非常简单，它通常是一个全局变量，即场景中的所有物体都使用这个环境光。 <ul><li>⏱ 2022-05-27 18:21:33</li></ul></li></ul><h2 id="_6-3-unity中的环境光和自发光" tabindex="-1">6.3 Unity中的环境光和自发光 <a class="header-anchor" href="#_6-3-unity中的环境光和自发光" aria-label="Permalink to &quot;6.3 Unity中的环境光和自发光&quot;">​</a></h2><ul><li>📌 如果要计算自发光也非常简单，我们只需要在片元着色器输出最后的颜色之前，把材质的自发光颜色添加到输出颜色上即可。 <ul><li>⏱ 2022-05-27 18:25:57</li></ul></li></ul><h2 id="_6-4-在unity-shader中实现漫反射光照模型" tabindex="-1">6.4 在Unity Shader中实现漫反射光照模型 <a class="header-anchor" href="#_6-4-在unity-shader中实现漫反射光照模型" aria-label="Permalink to &quot;6.4 在Unity Shader中实现漫反射光照模型&quot;">​</a></h2><ul><li><p>📌 首先，我们需要为这个Shader起一个名字</p><ul><li>⏱ 2022-05-27 18:36:00</li></ul></li><li><p>📌 为了得到并且控制材质的漫反射颜色，我们首先在Shader的Properties语义块中声明了一个Color类型的属性，并把它的初始值设为白色：</p><ul><li>⏱ 2022-05-27 18:36:04</li></ul></li><li><p>📌 然后，我们在SubShader语义块中定义了一个Pass语义块。这是因为顶点/片元着色器的代码需要写在Pass语义块，而非SubShader语义块中。而且，我们在Pass的第一行指明了该Pass的光照模式：</p><ul><li>⏱ 2022-05-27 18:35:47</li></ul></li><li><p>📌 只有定义了正确的LightMode，我们才能得到一些Unity的内置光照变量</p><ul><li>⏱ 2022-05-27 18:28:23</li></ul></li><li><p>📌 然后，我们使用CGPROGRAM和ENDCG来包围CG代码片，以定义最重要的顶点着色器和片元着色器代码。</p><ul><li>⏱ 2022-05-27 18:35:26</li></ul></li><li><p>📌 为了使用Unity内置的一些变量，如后面要讲到的_LightColor0，还需要包含进Unity的内置文件Lighting.cginc：</p><ul><li>⏱ 2022-05-27 18:42:05</li></ul></li></ul><h2 id="_3-1-unity-shader概述-1" tabindex="-1">3.1 Unity Shader概述 <a class="header-anchor" href="#_3-1-unity-shader概述-1" aria-label="Permalink to &quot;3.1 Unity Shader概述&quot;">​</a></h2><h3 id="划线评论" tabindex="-1">划线评论 <a class="header-anchor" href="#划线评论" aria-label="Permalink to &quot;划线评论&quot;">​</a></h3><ul><li>📌 那么如何充分利用Unity Shader来为我们的游戏增光添彩呢？ 3.1.1 一对好兄弟：材质和Unity Shader 总体来说，在Unity中我们需要配合使用材质（Material）和Unity Shader才能达到需要的效果。一个最常见的流程是： （1）创建一个材质； （2）创建一个Unity Shader，并把它赋给上一步中创建的材质； （3）把材质赋给要渲染的对象； （4）在材质面板中调整Unity Shader的属性，以得到满意的效果。 图3.1显示了Unity Shader和材质是如何一起工作来控制物体的渲染的。 [插图] ▲图3.1 Unity Shader和材质。首先创建需要的Unity Shader和材质，然后把Unity Shader赋给材质，并在材质面板上调整属性（如使用的纹理、漫反射系数等）。最后，将材质赋给相应的模型来查看最终的渲染效果 可以发现，Unity Shader定义了渲染所需的各种代码（如顶点着色器和片元着色器）、属性（如使用哪些纹理等）和指令（渲染和标签设置等），而材质则允许我们调节这些属性，并将其最终赋给相应的模型。 3.1.2 Unity中的材质 Unity中的材质需要结合一个GameObject的Mesh或者Particle Systems组件来工作。它决定了我们的游戏对象看起来是什么样子的（这当然也需要Unity Shader的配合）。 <ul><li>💭 shader关心过程和细节实现，material是结果的引用描述</li><li>⏱ 2021-11-14 02:34:48</li></ul></li></ul>',46)])])}const U=i(u,[["render",t]]);export{S as __pageData,U as default};
