import{_ as o,o as a,c as t,a6 as l}from"./chunks/framework.BB0md0jN.js";const q=JSON.parse('{"title":"OpenCV轻松入门：面向Python","description":"","frontmatter":{"layout":"doc","title":"OpenCV轻松入门：面向Python","readingTime":"11 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/计算机_编程设计/OpenCV轻松入门_面向Python.md","filePath":"电影和阅读/微信读书/计算机_编程设计/OpenCV轻松入门_面向Python.md"}'),n={name:"电影和阅读/微信读书/计算机_编程设计/OpenCV轻松入门_面向Python.md"};function r(c,e,p,i,u,h){return a(),t("div",null,[...e[0]||(e[0]=[l('<h1 id="opencv轻松入门-面向python" tabindex="-1">OpenCV轻松入门：面向Python <a class="header-anchor" href="#opencv轻松入门-面向python" aria-label="Permalink to &quot;OpenCV轻松入门：面向Python&quot;">​</a></h1><p><img src="https://cdn.weread.qq.com/weread/cover/8/YueWen_26297910/t6_YueWen_26297910.jpg" alt=" OpenCV轻松入门：面向Python"></p><ul><li><strong>书名</strong>： OpenCV轻松入门：面向Python</li><li><strong>作者</strong>： 李立宗</li><li><strong>简介</strong>： 本书基于面向Python的OpenCV（OpenCVforPython），介绍了图像处理的方方面面。本书以OpenCV官方文档的知识脉络为主线，并对细节进行补充和说明。书中不仅介绍了OpenCV函数的使用方法，还介绍了函数实现的算法原理。在介绍OpenCV函数的使用方法时，提供了大量的程序示例。而且在介绍函数对图像的处理前，往往先展示函数对数值、数组的处理，方便读者从数值的角度观察和理解函数的处理过程和结果。在介绍具体的算法原理时，本书尽量使用通俗易懂的语言和贴近生活的示例来说明问题，避免使用过多复杂抽象的公式。本书适合计算机视觉领域的初学者阅读，包括在校学生、教师、专业技术人员、图像处理爱好者。</li><li><strong>出版时间</strong>： 2019-05-01 00:00:00</li><li><strong>ISBN</strong>： 9787121362903</li><li><strong>分类</strong>： 计算机-编程设计</li><li><strong>出版社</strong>： 电子工业出版社</li><li><strong>PC地址</strong>： <a href="https://weread.qq.com/web/reader/30232de0719146363020e69" target="_blank" rel="noreferrer">https://weread.qq.com/web/reader/30232de0719146363020e69</a></li></ul><h2 id="第1章-opencv入门" tabindex="-1">第1章 OpenCV入门 <a class="header-anchor" href="#第1章-opencv入门" aria-label="Permalink to &quot;第1章 OpenCV入门&quot;">​</a></h2><blockquote><p>📌 OpenCV库由C和C++语言编写，涵盖计算机视觉各个领域内的500多个函数，可以在多种操作系统上运行。 ⏱ 2020-08-25 21:29:55</p></blockquote><h3 id="_1-2-图像处理基本操作" tabindex="-1">1.2 图像处理基本操作 <a class="header-anchor" href="#_1-2-图像处理基本操作" aria-label="Permalink to &quot;1.2 图像处理基本操作&quot;">​</a></h3><blockquote><p>📌 在图像处理过程中，读取图像、显示图像、保存图像是最基本的操作。 ⏱ 2020-08-25 21:38:12</p></blockquote><blockquote><p>📌 如果设置的当前工作路径是e:\\lesson，程序就会读取当前工作路径下的文件image\\lena.bmp，该文件的完整文件名就是e:\\lesson\\ image\\lena.bmp。正是我们想要读取的指定文件。 ⏱ 2020-08-25 21:51:54</p></blockquote><blockquote><p>📌 在实际使用中，可以通过函数cv2.waitKey()获取按下的按键，并针对不同的键做出不同的反应，从而实现交互功能。 ⏱ 2020-08-25 21:59:44</p></blockquote><blockquote><p>📌 函数cv2.waitKey()能够获取按键的ASCII码。例如，如果该函数的返回值为97，表示按下了键盘上的字母a键。 ⏱ 2020-08-25 22:15:32</p></blockquote><blockquote><p>📌 Python提供了函数ord()，用来获取字符的ASCII码值。 ⏱ 2020-08-25 22:15:58</p></blockquote><h2 id="第2章-图像处理基础" tabindex="-1">第2章 图像处理基础 <a class="header-anchor" href="#第2章-图像处理基础" aria-label="Permalink to &quot;第2章 图像处理基础&quot;">​</a></h2><blockquote><p>📌 使用面向Python的OpenCV（OpenCV for Python）必须熟练掌握Numpy库，尤其是Numpy.array库，Numpy.array库是Python处理图像的基础。 ⏱ 2020-08-25 22:34:30</p></blockquote><blockquote><p>📌 用于表示256个灰度级的数值0~255，正好可以用一个字节（8位二进制值）来表示。 ⏱ 2020-08-26 12:40:22</p></blockquote><blockquote><p>📌 用一个三维数组来表示一幅RGB色彩空间的彩色图像。 ⏱ 2020-08-25 22:53:29</p></blockquote><blockquote><p>📌 可以根据需要对不同色彩空间的图像进行类型转换，例如，将灰度图像处理为二值图像，将彩色图像处理为灰度图像等。 ⏱ 2020-08-25 22:53:59</p></blockquote><h3 id="_2-2-像素处理" tabindex="-1">2.2 像素处理 <a class="header-anchor" href="#_2-2-像素处理" aria-label="Permalink to &quot;2.2 像素处理&quot;">​</a></h3><blockquote><p>📌 可以通过位置索引的形式对图像内的元素进行访问、处理。 ⏱ 2020-08-26 08:32:53</p></blockquote><blockquote><p>📌 在OpenCV中，最小的数据类型是无符号的8位数。 ⏱ 2020-08-26 11:42:52</p></blockquote><blockquote><p>📌 图像就是Numpy库中的数组。一个OpenCV灰度图像是一个二维数组，可以使用表达式访问其中的像素值。 ⏱ 2020-08-26 11:43:33</p></blockquote><blockquote><p>📌 image[0,0]访问图像image第0行第0列位置上的像素点。第0行第0列位于图像的左上角， ⏱ 2022-12-12 08:51:16</p></blockquote><blockquote><p>📌 通过本例中两个窗口显示的图像可知，二维数组与图像之间存在对应关系。 ⏱ 2022-12-12 08:52:59</p></blockquote><blockquote><p>📌 RGB模式的彩色图像在读入OpenCV内进行处理时，会按照行方向依次读取该RGB图像的B通道、G通道、R通道的像素点，并将像素点以行为单位存储在ndarray的列中。 ⏱ 2020-08-26 11:45:55</p></blockquote><h3 id="_2-3-使用numpy-array访问像素" tabindex="-1">2.3 使用numpy.array访问像素 <a class="header-anchor" href="#_2-3-使用numpy-array访问像素" aria-label="Permalink to &quot;2.3 使用numpy.array访问像素&quot;">​</a></h3><blockquote><p>📌 numpy.array提供了item()和itemset()函数来访问和修改像素值，而且这两个函数都是经过优化处理的，能够更大幅度地提高处理效率。在访问及修改像素点的值时，利用numpy.array提供的函数比直接使用索引要快得多，同时，这两个函数的可读性也更好。 ⏱ 2022-12-12 08:57:20</p></blockquote><h3 id="_2-4-感兴趣区域-roi" tabindex="-1">2.4 感兴趣区域（ROI） <a class="header-anchor" href="#_2-4-感兴趣区域-roi" aria-label="Permalink to &quot;2.4 感兴趣区域（ROI）&quot;">​</a></h3><blockquote><p>📌 在图像处理过程中，我们可能会对图像的某一个特定区域感兴趣，该区域被称为感兴趣区域（Region of Interest, ROI）。在设定感兴趣区域ROI后，就可以对该区域进行整体操作。 ⏱ 2020-08-26 12:40:21</p></blockquote><blockquote><p>📌 图像中的黑色ROI可以表示为img[200:400, 200:400]。 ⏱ 2020-08-26 12:40:20</p></blockquote><h3 id="_2-5-通道操作" tabindex="-1">2.5 通道操作 <a class="header-anchor" href="#_2-5-通道操作" aria-label="Permalink to &quot;2.5 通道操作&quot;">​</a></h3><blockquote><p>📌 ，在OpenCV中，通道是按照B通道→G通道→R通道的顺序存储的。 ⏱ 2020-08-26 11:56:31</p></blockquote><h2 id="第3章-图像运算" tabindex="-1">第3章 图像运算 <a class="header-anchor" href="#第3章-图像运算" aria-label="Permalink to &quot;第3章 图像运算&quot;">​</a></h2><blockquote><p>📌 通过cv2.add()函数对图像进行加法运算。 ⏱ 2020-08-30 11:39:22</p></blockquote><h3 id="_5-2-翻转" tabindex="-1">5.2 翻转 <a class="header-anchor" href="#_5-2-翻转" aria-label="Permalink to &quot;5.2 翻转&quot;">​</a></h3><blockquote><p>📌 在OpenCV中，图像的翻转采用函数cv2.flip()实现，该函数能够实现图像在水平方向翻转、垂直方向翻转、两个方向同时翻转，其语法结构为： dst = cv2.flip( src, flipCode ) ⏱ 2020-08-30 11:53:00</p></blockquote><h3 id="_5-3-仿射" tabindex="-1">5.3 仿射 <a class="header-anchor" href="#_5-3-仿射" aria-label="Permalink to &quot;5.3 仿射&quot;">​</a></h3><blockquote><p>📌 在使用函数cv2.warpAffine()对图像进行旋转时，可以通过函数cv2.getRotationMatrix2D()获取转换矩阵。该函数的语法格式为： retval=cv2.getRotationMatrix2D(center, angle, scale) ⏱ 2020-08-30 11:53:38</p></blockquote><h2 id="第10章-canny边缘检测" tabindex="-1">第10章 Canny边缘检测 <a class="header-anchor" href="#第10章-canny边缘检测" aria-label="Permalink to &quot;第10章 Canny边缘检测&quot;">​</a></h2><blockquote><p>📌 OpenCV提供了函数cv2.Canny()实现Canny边缘检测。 ⏱ 2022-12-11 21:15:18</p></blockquote><h2 id="第11章-图像金字塔" tabindex="-1">第11章 图像金字塔 <a class="header-anchor" href="#第11章-图像金字塔" aria-label="Permalink to &quot;第11章 图像金字塔&quot;">​</a></h2><blockquote><p>📌 图像金字塔是由一幅图像的多个不同分辨率的子图所构成的图像集合。该组图像是由单个图像通过不断地降采样所产生的，最小的图像可能仅仅有一个像素点。 ⏱ 2022-12-11 21:15:47</p></blockquote><h3 id="_11-2-pyrdown函数及使用" tabindex="-1">11.2 pyrDown函数及使用 <a class="header-anchor" href="#_11-2-pyrdown函数及使用" aria-label="Permalink to &quot;11.2 pyrDown函数及使用&quot;">​</a></h3><blockquote><p>📌 OpenCV提供了函数cv2.pyrDown()，用于实现图像高斯金字塔操作中的向下采样，其语法形式为： dst = cv2.pyrDown( src[, dstsize[, borderType]] ) ⏱ 2022-12-11 21:16:06</p></blockquote><h2 id="第12章-图像轮廓" tabindex="-1">第12章 图像轮廓 <a class="header-anchor" href="#第12章-图像轮廓" aria-label="Permalink to &quot;第12章 图像轮廓&quot;">​</a></h2><blockquote><p>📌 OpenCV提供了查找图像轮廓的函数cv2.findContours()，该函数能够查找图像内的轮廓信息，而函数cv2.drawContours()能够将轮廓绘制出来。图像轮廓是图像中非常重要的一个特征信息，通过对图像轮廓的操作，我们能够获取目标图像的大小、位置、方向等信息。 ⏱ 2022-12-10 22:24:54</p></blockquote><blockquote><p>📌 待处理的源图像必须是灰度二值图。因此，在通常情况下，都要预先对图像进行阈值分割或者边缘检测处理，得到满意的二值图像后再将其作为参数使用。 ⏱ 2022-12-10 23:23:15</p></blockquote><blockquote><p>📌 在OpenCV中，都是从黑色背景中查找白色对象。因此，对象必须是白色的，背景必须是黑色的。 ⏱ 2022-12-10 23:22:04</p></blockquote><h3 id="_12-2-矩特征" tabindex="-1">12.2 矩特征 <a class="header-anchor" href="#_12-2-矩特征" aria-label="Permalink to &quot;12.2 矩特征&quot;">​</a></h3><blockquote><p>📌 OpenCV提供了函数cv2.moments()来获取图像的moments特征。通常情况下，我们将使用函数cv2.moments()获取的轮廓特征称为“轮廓矩”。轮廓矩描述了一个轮廓的重要特征，使用轮廓矩可以方便地比较两个轮廓。 ⏱ 2022-12-11 21:16:24</p></blockquote><blockquote><p>📌 函数cv2.contourArea()用于计算轮廓的面积。 ⏱ 2022-12-11 21:16:47</p></blockquote><blockquote><p>📌 函数cv2.arcLength()用于计算轮廓的长度，其语法格式为： retval = cv2.arcLength( curve, closed ) ⏱ 2022-12-11 21:16:56</p></blockquote><h2 id="第15章-模板匹配" tabindex="-1">第15章 模板匹配 <a class="header-anchor" href="#第15章-模板匹配" aria-label="Permalink to &quot;第15章 模板匹配&quot;">​</a></h2><blockquote><p>📌 模板匹配是指在当前图像A内寻找与图像B最相似的部分， ⏱ 2022-12-11 21:18:04</p></blockquote><h2 id="第18章-视频处理" tabindex="-1">第18章 视频处理 <a class="header-anchor" href="#第18章-视频处理" aria-label="Permalink to &quot;第18章 视频处理&quot;">​</a></h2><blockquote><p>📌 OpenCV提供了cv2.VideoCapture类来处理视频。 ⏱ 2020-08-30 12:07:38</p></blockquote><h2 id="第19章-绘图及交互" tabindex="-1">第19章 绘图及交互 <a class="header-anchor" href="#第19章-绘图及交互" aria-label="Permalink to &quot;第19章 绘图及交互&quot;">​</a></h2><blockquote><p>📌 OpenCV提供了鼠标事件，使用户可以通过鼠标与图像交互。鼠标事件能够识别常用的鼠标操作，例如：针对不同按键的单击、双击，鼠标的滑动、拖曳等。 ⏱ 2020-08-30 12:09:01</p></blockquote><blockquote><p>📌 OpenCV提供了绘制直线的函数cv2.line()、绘制矩形的函数cv2.rectangle()、 ⏱ 2020-08-30 12:08:29</p></blockquote><blockquote><p>📌 OpenCV提供了函数cv2.polylines()用来绘制多边形。该函数的语法格式为： img = cv2.polylines( img, pts, isClosed, color[, thickness[, lineType[, shift]]]) ⏱ 2020-08-30 12:09:46</p></blockquote><blockquote><p>📌 OpenCV提供了函数cv2.putText()用来在图形上绘制文字。该函数的语法格式为： img=cv2.putText(img, text, org, fontFace, fontScale, color[, thickness[, lineType[, bottomLeftOrigin]]]) ⏱ 2020-08-30 12:10:27</p></blockquote><h2 id="第23章-人脸识别" tabindex="-1">第23章 人脸识别 <a class="header-anchor" href="#第23章-人脸识别" aria-label="Permalink to &quot;第23章 人脸识别&quot;">​</a></h2><blockquote><p>📌 在OpenCV中，人脸检测使用的是cv2.CascadeClassifier.detectMultiScale()函数，它可以检测出图片中所有的人脸 ⏱ 2022-12-11 21:19:07</p></blockquote>',61)])])}const s=o(n,[["render",r]]);export{q as __pageData,s as default};
