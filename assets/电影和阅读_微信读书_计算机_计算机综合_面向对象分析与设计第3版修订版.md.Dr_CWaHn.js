import{_ as e,o as t,c as l,a6 as c}from"./chunks/framework.BB0md0jN.js";const n=JSON.parse('{"title":"面向对象分析与设计（第3版）（修订版）","description":"","frontmatter":{"layout":"doc","title":"面向对象分析与设计（第3版）（修订版）","readingTime":"38 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/计算机_计算机综合/面向对象分析与设计第3版修订版.md","filePath":"电影和阅读/微信读书/计算机_计算机综合/面向对象分析与设计第3版修订版.md"}'),u={name:"电影和阅读/微信读书/计算机_计算机综合/面向对象分析与设计第3版修订版.md"};function b(q,o,p,k,a,r){return t(),l("div",null,[...o[0]||(o[0]=[c('<h1 id="面向对象分析与设计-第3版-修订版" tabindex="-1">面向对象分析与设计（第3版）（修订版） <a class="header-anchor" href="#面向对象分析与设计-第3版-修订版" aria-label="Permalink to &quot;面向对象分析与设计（第3版）（修订版）&quot;">​</a></h1><p><img src="https://cdn.weread.qq.com/weread/cover/18/YueWen_33380973/t6_YueWen_33380973.jpg" alt=" 面向对象分析与设计（第3版）（修订版）"></p><ul><li><strong>书名</strong>： 面向对象分析与设计（第3版）（修订版）</li><li><strong>作者</strong>： 格雷迪·布奇 罗伯特·A.马克西</li><li><strong>简介</strong>： 全书分为理论和应用两部分。理论部分深刻剖析了面向对象分析与设计（OOAD）的概念和方法。应用部分连续列出了5个不同类型、不同领域的应用，描述如何从初始阶段到交付阶段，将OOAD理论和方法应用到项目中。应用部分所涉及的领域包括系统架构、数据获取、密码分析、控制系统和Web开发，还给出了一些关于重要问题的有效建议，包括分类、实现策略和高性价比的项目管理。书中介绍的概念都基于牢固的理论基础。同时，作者十分注重实效，基于其丰富的经验，面向软件工程实践者的实际需要，提出了改进的对象开发方法，用于解决系统和软件开发者面临的复杂问题；运用大量例子说明了基本概念，解释了方法，并展示了在不同领域的成功应用。</li><li><strong>出版时间</strong>： 2016-05-01 00:00:00</li><li><strong>ISBN</strong>： 9787121286667</li><li><strong>分类</strong>： 计算机-计算机综合</li><li><strong>出版社</strong>： 电子工业出版社</li><li><strong>PC地址</strong>： <a href="https://weread.qq.com/web/reader/06632f0071fd5a6d06638a2" target="_blank" rel="noreferrer">https://weread.qq.com/web/reader/06632f0071fd5a6d06638a2</a></li></ul><h2 id="经久不息的回荡" tabindex="-1">经久不息的回荡 <a class="header-anchor" href="#经久不息的回荡" aria-label="Permalink to &quot;经久不息的回荡&quot;">​</a></h2><blockquote><p>📌 仔细想来，软件开发与古典音乐岂非有异曲同工之妙？既是人类心智索问精确科学的探究，亦是寻觅美学享受的追求。工程是艺术的根基，而艺术是工程的极致。 ⏱ 2021-09-23 10:32:15</p></blockquote><h2 id="重看面向对象" tabindex="-1">重看面向对象 <a class="header-anchor" href="#重看面向对象" aria-label="Permalink to &quot;重看面向对象&quot;">​</a></h2><blockquote><p>📌 计算机科学的基石是图灵机抽象：一个输入集合，一个输出集合，一个内部状态集合，一个计算规则集合。这个抽象十分强大，我们甚至可以认为一头奶牛也是一个图灵机：吃的是草，挤的是奶。 ⏱ 2021-04-11 11:40:47</p></blockquote><blockquote><p>📌 编程或设计软件就是在通用图灵机的基础上，设计一个具体的图灵机。我们设计软件接受怎样的输入，设计软件内部的状态，设计表示计算规则的代码，设计软件的输出。 ⏱ 2021-04-11 11:41:33</p></blockquote><blockquote><p>📌 由此也导出了Map-Reduce等流行的架构设计模式：一个计算集群仍然是一个图灵机。 ⏱ 2021-04-11 11:42:26</p></blockquote><blockquote><p>📌 纯粹的函数有一点不足，它没有内部状态。可以说，它是简化了的图灵机。但在有些时候，我们确实需要内部状态。根据内部状态的不同，对于同样的输入，可能给出不一样的输出。于是便有了闭包的概念，它是一个函数加上相关的上下文环境状态。 ⏱ 2021-04-11 11:44:15</p></blockquote><blockquote><p>📌 闭包可以看成是拥有内部状态的函数 ⏱ 2021-04-11 11:53:45</p></blockquote><blockquote><p>📌 反过来，对象可以看成是几个闭包，它们共享了内部状态。 ⏱ 2021-04-11 11:54:28</p></blockquote><blockquote><p>📌 因此，函数式编程和面向对象思想，在底层基础上是一致的。 ⏱ 2021-04-11 11:54:33</p></blockquote><blockquote><p>📌 只有利用抽象概念，才能实现人与人之间的沟通。“你想吃苹果吗？”这里的“苹果”就是一个抽象概念，它隐藏了苹果实现的许多细节。人的大脑喜欢工作在一组抽象概念上。名词是结构或存在的抽象，动词是行为或过程的抽象。 ⏱ 2021-04-11 11:55:01</p></blockquote><blockquote><p>📌 数据在不同的概念抽象之间反复倒手 ⏱ 2021-09-23 11:02:22</p></blockquote><blockquote><p>📌 面向对象思想在过去的软件开发中取得了辉煌的成绩。函数式编程让我们能从另一个角度审视面向对象，更进一步体会面向对象抽象的强大，也发现面向对象中一些误用的地方。如无必要，勿增实体。 ⏱ 2021-04-11 11:58:52</p></blockquote><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><blockquote><p>📌 人类渴望得到精神上的宁静、美学上的成就、家庭的安全、正义和自由。这一切都不能通过工业化的生产效率来直接满足。 ⏱ 2021-04-11 12:07:00</p></blockquote><blockquote><p>📌 我们面临着在计算资源和人力资源有限的条件下创建复杂系统的任务。 ⏱ 2021-09-23 11:04:15</p></blockquote><blockquote><p>📌 许多人可能从没研究过面向对象（OO）概念本身的发展，即使有所了解，在初次学习OO方法时，也许未能理解其重要性。 ⏱ 2021-04-11 12:10:08</p></blockquote><blockquote><p>📌 确定有意义的类和对象是面向对象开发中的关键任务，因此我们花了相当多的时间来研究分类的本质。 ⏱ 2021-04-11 12:11:13</p></blockquote><blockquote><p>📌 基于对象模型提出了复杂系统开发的一种方法。针对面向对象的分析与设计，首先提出了一套图形表示法（即UML），然后是一个通用的过程框架。 ⏱ 2021-04-11 12:11:45</p></blockquote><blockquote><p>📌 我们关注的是为现实世界构建有用的系统 ⏱ 2021-09-23 11:06:31</p></blockquote><blockquote><p>📌 软件系统的开发不同于按菜谱做菜，因此我们强调应用程序的增量式开发， ⏱ 2021-04-11 12:12:22</p></blockquote><blockquote><p>📌 我们主要使用两个很好的工具来画图：IBM Rational Software Architect和Sparx Systems Enterprise Architect。 ⏱ 2021-09-23 11:07:00</p></blockquote><h2 id="第1章-复杂性" tabindex="-1">第1章 复杂性 <a class="header-anchor" href="#第1章-复杂性" aria-label="Permalink to &quot;第1章 复杂性&quot;">​</a></h2><blockquote><p>📌 系统越复杂，就越容易全面崩溃”[5]。建筑师一般不会想要为一幢100层的大楼添加一个新的地下室，因为这样做成本会很高，无疑将失败。 ⏱ 2021-04-11 12:20:46</p></blockquote><h3 id="_1-1-复杂系统的结构" tabindex="-1">1.1 复杂系统的结构 <a class="header-anchor" href="#_1-1-复杂系统的结构" aria-label="Permalink to &quot;1.1 复杂系统的结构&quot;">​</a></h3><blockquote><p>📌 我们之所以能够理解计算机的工作方式，是因为可以将它分解为能够独立研究的部件。因此，我们可以独立地研究显示器的操作和硬盘驱动器的操作。 ⏱ 2021-04-11 12:22:07</p></blockquote><blockquote><p>📌 复杂系统不仅仅是层次化的，而且这种层次也代表了不同的抽象级别，一层构建于另一层之上，每一层都可以分开来理解。在每一个抽象层都可以发现一组设备，相互协作，为更高的抽象层提供服务。 ⏱ 2021-04-11 12:32:16</p></blockquote><blockquote><p>📌 给定抽象层的内外之间总有清晰的边界。 ⏱ 2021-09-23 11:12:07</p></blockquote><blockquote><p>📌 简而言之，在不同抽象层的不同部分之间，存在着清晰的关注点分离。 ⏱ 2021-04-11 12:33:47</p></blockquote><h3 id="_1-2-软件固有的复杂性" tabindex="-1">1.2 软件固有的复杂性 <a class="header-anchor" href="#_1-2-软件固有的复杂性" aria-label="Permalink to &quot;1.2 软件固有的复杂性&quot;">​</a></h3><blockquote><p>📌 用户常常发现，很难用开发者能够理解的形式对他们的需求给出准确的表述。在某些情况下，用户只是对想要的软件系统有一个模糊的想法。这既不是系统用户的错，也不是系统开发者的错，出现这种情况是因为这些人都缺乏另一个领域的经验。 ⏱ 2021-04-11 14:41:33</p></blockquote><blockquote><p>📌 实际上，即使用户对他们的需求知道得很清楚，我们目前也没有什么好方法来准确地记录下这些需求。常见的描述需求的方法是用一大段文字，偶尔配有一些插图。这样的文档是难以理解的，可能产生不同的解读 ⏱ 2021-04-11 14:41:00</p></blockquote><blockquote><p>📌 更麻烦的是，软件系统在开发过程中经常发生需求改变，主要是因为软件开发项目本身改变了问题的规则。看到早期的产品（如设计文档和原型）之后，在安装好并使用系统之后，在强制使用所有功能之后，用户会对他们的需求有更好的理解和表述。同时，这个过程也帮助开发者了解了问题域，使他们能够问出更好的问题，从而照亮系统期望行为中的黑暗角落。 ⏱ 2021-09-23 11:21:30</p></blockquote><blockquote><p>📌 但在今天，常常看到交付系统的代码规模达到几十万甚至几百万行（而且这些都是用高级语言写的）。没有哪个人能完全理解这样一个系统。 ⏱ 2021-09-23 11:23:32</p></blockquote><blockquote><p>📌 建筑行业对原材料的品质有着统一的编码和标准，但软件行业却很少有这种标准。结果，软件行业还是一种劳动密集型的产业。 ⏱ 2021-04-11 14:45:48</p></blockquote><blockquote><p>📌 我们是在数字计算机上执行软件，所以我们的系统具有离散的状态。与此形成对比的是，像抛球运动这样的模拟系统是连续的系统。 ⏱ 2021-04-11 14:46:39</p></blockquote><blockquote><p>📌 我们试图以关注点分离的方式来设计我们的系统，这样，系统某部分的行为对其他部分行为的影响就能降至最低。但是有一个事实仍未改变，即离散系统中的状态转换不能够用连续函数来建模。软件系统之外的每个事件都有可能让系统进入一个新的状态， ⏱ 2021-09-23 11:26:01</p></blockquote><blockquote><p>📌 穷尽所有可能的测试是无法做到的。既然数学工具和我们的智能都不能够对大型离散系统的完整行为进行建模，对于系统的正确性，我们必须满足于可接受的信心级别。 ⏱ 2021-09-23 11:26:32</p></blockquote><h3 id="_1-3-复杂系统的5个属性" tabindex="-1">1.3 复杂系统的5个属性 <a class="header-anchor" href="#_1-3-复杂系统的5个属性" aria-label="Permalink to &quot;1.3 复杂系统的5个属性&quot;">​</a></h3><blockquote><p>📌 复杂性常常以层次结构的形式存在。复杂的系统由一些相关的子系统组成，这些子系统又有自己的子系统，如此下去，直到达到某种最低层次的基本组件。 ⏱ 2021-04-11 15:45:52</p></blockquote><blockquote><p>📌 复杂系统的架构是它所有的组件及其层次结构的函数，认识到这一点很重要。 ⏱ 2021-04-11 15:53:28</p></blockquote><blockquote><p>📌 “选择哪些作为系统的基础组件相对来说比较随意，这在很大程度上取决于系统观察者的判断。”对于一个观察者来说很基础的东西，对另一个观察者可能具有很高的抽象层次。 ⏱ 2021-09-23 11:28:40</p></blockquote><blockquote><p>📌 “组件内的联系通常比组件间的联系更强。这一事实实际上将组件中高频率的动作（涉及组件的内部结构）和低频率的动作（涉及组件间的相互作用）分离开来。”[10] ⏱ 2021-04-11 16:01:25</p></blockquote><blockquote><p>📌 随着系统的演变，曾经认为是复杂的对象就变成了基础对象，在这些对象的基础上构建更复杂的系统。而且，永远也不能够第一次就正确打造出这些基础对象，必须在上下文环境中使用它们，然后随着时间的推移不断地改进它们，因为我们对系统的真实行为了解得越来越多。 ⏱ 2021-09-23 11:42:25</p></blockquote><h3 id="_1-4-有组织和无组织的复杂性" tabindex="-1">1.4 有组织和无组织的复杂性 <a class="header-anchor" href="#_1-4-有组织和无组织的复杂性" aria-label="Permalink to &quot;1.4 有组织和无组织的复杂性&quot;">​</a></h3><blockquote><p>📌 应该既研究它的“是一种”层次结构，也研究“组成部分”层次结构。我们把这些层次结构分别称为“类结构”和“对象结构”， ⏱ 2021-09-23 11:44:14</p></blockquote><blockquote><p>📌 我们将系统的类结构和对象结构统称为它的“架构”。 ⏱ 2021-09-23 12:12:51</p></blockquote><blockquote><p>📌 类结构和对象结构不是完全独立的，对象结构中的每个对象都代表了某个类的一个具体实例。 ⏱ 2021-09-23 12:15:04</p></blockquote><blockquote><p>📌 复杂系统中对象的数量通常比类的数量要多很多。 ⏱ 2021-09-23 12:16:09</p></blockquote><blockquote><p>📌 如果不揭示系统的类结构，我们就不得不将属性方面的知识重复地放到每个部分中。通过类结构，我们在一个地方记录了这些共同的属性。 ⏱ 2021-04-11 21:30:38</p></blockquote><blockquote><p>📌 在刚开始分析复杂软件系统时，我们发现许多部分必须以多种交错的方式进行交互，这些部分和它们的交互行为之间几乎没有什么显见的共性。这就是无组织的复杂性的例子。当我们通过设计的过程对这种复杂性进行组织时，必须同时考虑许多事情 ⏱ 2021-04-11 21:30:38</p></blockquote><blockquote><p>📌 一个人绝对没有办法同时追踪所有的细节。 ⏱ 2021-09-23 12:49:28</p></blockquote><blockquote><p>📌 我们面对的是一个根本难题：要开发的软件系统的复杂性在增加，而我们处理复杂性的能力却有局限。怎样才能解决这个困境？ ⏱ 2021-04-11 21:30:38</p></blockquote><h3 id="_1-5-从混沌到有序" tabindex="-1">1.5 从混沌到有序 <a class="header-anchor" href="#_1-5-从混沌到有序" aria-label="Permalink to &quot;1.5 从混沌到有序&quot;">​</a></h3><blockquote><p>📌 但是，“这个世界上天才很少，没有理由相信软件工程领域拥有大量的天才”[2]。尽管我们中间确实有一些天才，但是在工业级软件开发的领域，我们不能够总是依赖个人的灵感引导我们前进。 ⏱ 2021-09-23 12:52:33</p></blockquote><blockquote><p>📌 “控制复杂性的技巧我们从远古时代就知道了，即分而治之。 ⏱ 2021-09-23 12:55:23</p></blockquote><blockquote><p>📌 ，所以我们将分解作为一种简单的算法分解，即系统中的每个模块代表了某个总体过程的一个主要步骤。 ⏱ 2021-09-23 12:55:58</p></blockquote><blockquote><p>📌 更新信息”不是存在于一个独立的算法中，而是与“File of Updates（更新文件）”对象相关联的一个操作。调用这个方法创建了另一个对象，即“Update to Card（对卡的更新）”。 ⏱ 2021-04-11 21:30:40</p></blockquote><blockquote><p>📌 算法的观点强调了事件的顺序，面向对象的观点强调了一些代理，它们要么发出动作，要么是这些操作执行的对象。 ⏱ 2021-09-23 13:01:31</p></blockquote><blockquote><p>📌 面向对象分析的底层概念是设计者应该将系统建模为一组协作的对象，将单个对象作为类的实例，而类之间具有层次关系。 ⏱ 2021-09-23 13:05:33</p></blockquote><blockquote><p>📌 ]开始分解系统时，我们必须要么从算法开始，要么从对象开始，然后利用得到的结构作为框架来表达其他的看法 ⏱ 2021-09-23 13:20:41</p></blockquote><blockquote><p>📌 经验使我们首先应用面向对象的观点，因为这种方法更有助于组织软件系统的内在复杂性。 ⏱ 2021-04-11 21:30:40</p></blockquote><blockquote><p>📌 面向对象分解通过复用共同的机制，得到一些较小的系统，从而提供了重要的表达经济性。面向对象系统在应对变化时也更有弹性，从而更能够随时间演变 ⏱ 2021-04-11 21:30:40</p></blockquote><blockquote><p>📌 它们的思路是从我们有信心的、较小的系统开始增量式地演进。而且，通过帮助我们明智地决定对巨大的状态空间进行关注点分离，面向对象的分解直接关注了软件的内在复杂性。 ⏱ 2021-04-11 21:30:41</p></blockquote><blockquote><p>📌 对象作为真实世界中实体的抽象，代表了特定的一块密集而内聚的信息。 ⏱ 2021-09-23 13:23:35</p></blockquote><blockquote><p>📌 另一种增加单块信息的语义内容的方法，是在复杂的软件系统中显式地组织类和对象层次结构。对象结构很重要，因为它展示了不同的对象之间如何通过一些交互模式进行协作，我们把这些交互模式称为“机制”。类结构也同样重要，因为它强调了系统中的公共结构行为。 ⏱ 2021-04-11 21:30:41</p></blockquote><blockquote><p>📌 确定复杂软件系统中的层次关系通常并不容易，因为这要求在许多对象之中发现模式，每个对象都可能拥有大量复杂的行为。但当我们整理出这些层次结构之后，复杂系统的结构以及我们对它的理解都得到了极大的简化。 ⏱ 2021-04-11 21:30:41</p></blockquote><h3 id="_1-6-复杂系统的设计" tabindex="-1">1.6 复杂系统的设计 <a class="header-anchor" href="#_1-6-复杂系统的设计" aria-label="Permalink to &quot;1.6 复杂系统的设计&quot;">​</a></h3><blockquote><p>📌 程序设计任务是应用抽象的大规模练习，因此既需要正规数学家的能力，也需要称职工程师的态度 ⏱ 2021-09-23 13:27:33</p></blockquote><blockquote><p>📌 在大量的可复用软件组件库中，软件工程师必须以一种创新的方式来组装这些部分，以满足明确和隐含的需求，就像画家或音乐家必须将他们的介质发挥到极致一样。 ⏱ 2021-09-23 13:30:02</p></blockquote><blockquote><p>📌 建模在所有工程实践中都已得到广泛接受，这主要是因为建模引证了分解、抽象和层次结构的原则[42]。设计中的每个模型都描述了被考虑的系统的某个方面。 ⏱ 2021-09-23 13:31:01</p></blockquote><blockquote><p>📌 模型让我们有机会在受控制的条件下失败。我们在预期的情况和特殊的情况下评估每个模型，当它们没能按照我们的期望工作时，我们就修改它们。 ⏱ 2021-09-23 13:31:22</p></blockquote><blockquote><p>📌 通过反复实践，我们发现，构建关注问题域中的“事物”的模型具有很大的价值，这形成了我们所谓的面向对象分解。 ⏱ 2021-04-11 21:30:41</p></blockquote><blockquote><p>📌 通过明智地分离软件的状态空间，我们对软件正确性的信心提升到了一个新高度。最终，降低了开发复杂软件系统所固有的风险。 ⏱ 2021-04-11 21:30:42</p></blockquote><h3 id="_1-7-小结" tabindex="-1">1.7 小结 <a class="header-anchor" href="#_1-7-小结" aria-label="Permalink to &quot;1.7 小结&quot;">​</a></h3><blockquote><p>📌 将世界看作是一组有意义的对象进行协作，实现某种高级的行为。 ⏱ 2021-09-23 13:36:25</p></blockquote><h3 id="_2-1-对象模型的演进" tabindex="-1">2.1 对象模型的演进 <a class="header-anchor" href="#_2-1-对象模型的演进" aria-label="Permalink to &quot;2.1 对象模型的演进&quot;">​</a></h3><blockquote><p>📌 在第二代语言中，重点是算法抽象。 ⏱ 2021-09-23 13:42:16</p></blockquote><blockquote><p>📌 ，这一代的程序设计语言让我们向问题空间又靠近了一步，向底层计算机又远离了一步。 ⏱ 2021-09-23 13:42:25</p></blockquote><blockquote><p>📌 第三代语言演进到支持数据抽象。这时，程序员可以描述相关数据的意义（它们的类型），并让程序设计语言强制确保这些设计决策。 ⏱ 2021-09-23 13:42:36</p></blockquote><blockquote><p>📌 全局数据结构对于所有子程序都是可见的。 ⏱ 2021-09-23 13:45:28</p></blockquote><blockquote><p>📌 这种结构关注早期语言的一些不足之处，具体来说就是需要对算法抽象有更强的控制。但是，它仍然未能解决大规模程序设计和数据设计的问题。 ⏱ 2021-09-23 13:48:09</p></blockquote><blockquote><p>📌 通过过程可以实现的抽象在本质上很适合描述抽象操作，但并不太适合描述抽象的对象。 ⏱ 2021-09-23 13:50:41</p></blockquote><blockquote><p>📌 在许多应用中，要操作的数据对象的复杂性在很大程度上决定了问题的复杂性。 ⏱ 2021-09-23 13:52:18</p></blockquote><blockquote><p>📌 这类语言的构建块是模块，它表现为逻辑上的一组类或对象，而不像早期语言那样是子程序。换言之，“如果过程和函数是动词，数据是名词，那么面向过程语言的程序就是围绕动词组织的，面向对象的程序就是围绕名词组织的” ⏱ 2021-09-23 13:58:51</p></blockquote><blockquote><p>📌 小型或中型面向对象应用的物理结构表现为一个图，而不像面向算法的语言那样通常是一棵树。另外，基本上很少或没有全局数据。数据和操作放在一个单元中，系统的基本逻辑构建块不再是算法，而是类或对象。 ⏱ 2021-09-23 14:08:03</p></blockquote><h3 id="_2-2-对象模型基础" tabindex="-1">2.2 对象模型基础 <a class="header-anchor" href="#_2-2-对象模型基础" aria-label="Permalink to &quot;2.2 对象模型基础&quot;">​</a></h3><blockquote><p>📌 只利用算法分解在处理大量复杂性的情况时是有局限的，所以我们必须转向面向对象分解。 ⏱ 2021-09-23 14:13:32</p></blockquote><blockquote><p>📌 如果一个木匠不懂电，给他一个电钻，他也只会把它当作锤子来用。 ⏱ 2021-09-23 14:14:37</p></blockquote><blockquote><p>📌 将对象定义为“包含了属性、过程和数据的实体，它们执行计算并保存局部的状态”[8]。 ⏱ 2021-09-23 14:16:07</p></blockquote><blockquote><p>📌 对象统一了算法抽象和数据抽象的思想。 ⏱ 2021-09-23 14:18:23</p></blockquote><blockquote><p>📌 面向对象概念和C的结合产生了C++和Objective C。然后出现了Java， ⏱ 2021-09-24 02:49:25</p></blockquote><blockquote><p>📌 “面向对象编程是一种实现的方法，在这种方法中，程序被组织成许多组相互协作的对象，每个对象代表某个类的一个实例，而类则属于一个通过继承关系形成的层次结构。” ⏱ 2021-09-24 02:50:56</p></blockquote><blockquote><p>📌 具体来说，没有继承的编程显然不是面向对象的，那只是利用抽象数据类型在编程。 ⏱ 2021-09-24 02:52:26</p></blockquote><blockquote><p>📌 这些对象是具有命名的操作接口和隐藏的内部状态的数据抽象； ⏱ 2021-09-24 03:27:28</p></blockquote><h3 id="_2-3-对象模型要素" tabindex="-1">2.3 对象模型要素 <a class="header-anchor" href="#_2-3-对象模型要素" aria-label="Permalink to &quot;2.3 对象模型要素&quot;">​</a></h3><blockquote><p>📌 对于所有面向对象的东西，概念框架就是对象模型。这个模型有四个主要要素：（1）抽象；（2）封装；（3）模块化；（4）层次结构。 ⏱ 2021-09-24 03:38:13</p></blockquote><blockquote><p>📌 ，对象的接口只提供它的基本行为，此外别无其他[46] ⏱ 2021-09-24 03:41:10</p></blockquote><blockquote><p>📌 对于给定的问题域决定一组正确的抽象，就是面向对象设计的核心问题。 ⏱ 2021-09-24 03:41:37</p></blockquote><blockquote><p>📌 抽象思想的核心是不变性的概念。“不变量（invariant）”是某种布尔（真或假）条件，它的值必须保持不变。对于对象的每个操作，我们可以定义“前置条件（precondition）”（操作假定的不变量）和“后置条件（postcondition）”（操作满足的不变量）。 ⏱ 2021-09-26 13:57:48</p></blockquote><blockquote><p>📌 所有的抽象都有静态和动态的属性。 ⏱ 2021-09-26 13:57:38</p></blockquote><blockquote><p>📌 可能有一个对象位于人机界面的边界上，将人的输入转变成计划。 ⏱ 2021-09-26 14:14:07</p></blockquote><blockquote><p>📌 没有对象是孤立的，每个对象都与其他对象协作，实现某些行为。[1]这些对象之间如何协作的设计决策，定义了每种抽象的边界，从而也定义了每个对象的职责和协议。 ⏱ 2021-09-26 14:20:36</p></blockquote><blockquote><p>📌 通常，对象的结构是隐藏的，其方法的实现也是隐藏的。“复杂系统的每一部分都不应该依赖于其他部分的内部细节。”[50]抽象“帮助人们思考他们做什么”，而封装“让程序可以借助最少的工作进行可靠的修改”[51]。 ⏱ 2021-09-26 14:24:29</p></blockquote><blockquote><p>📌 类似地，在设计数据库应用时，标准的实践是编写程序时不关心数据的物理表示，而是仅仅依赖于说明数据逻辑视图的方案[52]。 ⏱ 2021-09-26 14:47:54</p></blockquote><blockquote><p>📌 在一个抽象层次上的对象看不到较低抽象层次的实现细节。 ⏱ 2021-09-26 14:48:09</p></blockquote><blockquote><p>📌 “要让抽象能工作，必须将实现封装起来。”[53]在实践中，这意味着每个类必须有两个部分：一个接口和一个实现。类的接口描述了它的外部视图，包含了这个类所有实例的共同行为的抽象。类的实现包括抽象的表示以及实现期望行为的机制。 ⏱ 2021-09-26 14:50:20</p></blockquote><blockquote><p>📌 培育计划本质上是一个时间/动作映射表。也许对这种抽象最合理的表示方式是一个时间/动作字典 ⏱ 2021-09-27 05:41:27</p></blockquote><blockquote><p>📌 分割程序的更大理由是它在程序内部创造了一些定义良好的、有文档描述的边界。这些边界，或者叫接口，对于理解程序非常有价值。” ⏱ 2021-09-27 05:44:15</p></blockquote><blockquote><p>📌 特别是对于较大型的应用来说，可能有成百上千个类，使用模块对管理复杂性有很大的帮助。 ⏱ 2021-09-27 05:44:52</p></blockquote><blockquote><p>📌 对于一个给定的问题决定一组正确的模块，这和决定一组正确的抽象的难度几乎差不多 ⏱ 2021-09-27 06:25:53</p></blockquote><blockquote><p>📌 对于很小的问题来说，开发者可能决定将所有的类和对象都声明在同一个包中。对于稍微有点实际意义的软件来说，更好的解决方案是将逻辑上相关的类和对象放在同一个模块中，只暴露出其他模块必须看到的元素。 ⏱ 2021-09-27 06:27:05</p></blockquote><blockquote><p>📌 随意的模块化有时候比不实现模块化还要糟。 ⏱ 2021-09-27 06:27:37</p></blockquote><blockquote><p>📌 。在实践中，编译一个模块的成本相对来说是很小的：只有一个单元需要重新编译，然后重新链接应用。但是，重新编译模块接口的成本相对是较高的。 ⏱ 2021-09-27 06:34:53</p></blockquote><blockquote><p>📌 每个数据结构对于一个模块来说都是私有的，它可能被这个模块中的一个或几个程序访问，但模块外的程序不能访问它。 ⏱ 2021-09-27 06:36:02</p></blockquote><blockquote><p>📌 经验丰富的设计师通常负责模块的接口，经验较少的开发者完成模块的实现。 ⏱ 2021-09-27 06:38:52</p></blockquote><blockquote><p>📌 类和对象的确定是系统逻辑设计的一部分，而模块的确定是系统物理设计的一部分。我们不能在物理设计之前完成所有逻辑设计，反之亦然。设计决策是以一种迭代的方式进行的。 ⏱ 2021-09-27 06:39:47</p></blockquote><blockquote><p>📌 在面向对象的设计中，定义这个主程序常常是最不重要的设计决策；而在传统的结构化设计中，这个主程序是根，是把所有东西聚在一起的基石。 ⏱ 2021-09-27 06:40:29</p></blockquote><blockquote><p>📌 超类代表了一般化的抽象，子类代表了特殊的抽象，会添加、修改甚至隐藏来自超类的属性和方法。通过这种方式，继承让我们以一种经济的方式表达我们的抽象。 ⏱ 2021-09-27 06:46:02</p></blockquote><blockquote><p>📌 对于某一个类，通常有两种客户：调用该类实例的方法的对象以及从这个类继承的子类。 ⏱ 2021-09-27 06:47:58</p></blockquote><blockquote><p>📌 具体来说，类的接口可以有三个部分：私有部分，声明只能够由该类本身访问的成员；保护部分，声明可以由该类及其子类访问的成员；公有部分，可以让所有客户访问。 ⏱ 2021-09-27 06:48:39</p></blockquote><blockquote><p>📌 但是，如果需要对一种既开花，又结果的植物进行建模呢？例如，种花人常常采用苹果、樱桃和李子的花。对于这种抽象，需要设计第三个类，即花卉果蔬类（FlowerFruitVegetable），它复制了来自花卉类和果蔬类的信息。 ⏱ 2021-09-27 06:49:33</p></blockquote><blockquote><p>📌 某些语言禁止重复继承，某些语言单方面地选择了一条路径，而另一些语言，如C++，则允许由程序员来决定。 ⏱ 2021-09-27 06:50:42</p></blockquote><h3 id="_3-1-对象的本质" tabindex="-1">3.1 对象的本质 <a class="header-anchor" href="#_3-1-对象的本质" aria-label="Permalink to &quot;3.1 对象的本质&quot;">​</a></h3><blockquote><p>📌 “对象是一个具有状态、行为和标识符的实体。结构和行为类似的对象定义在它们共同的类中。‘实例’和‘对象’这两个术语可以互换使用。” ⏱ 2021-09-27 07:07:21</p></blockquote><blockquote><p>📌 ：人们操作一个对象的次序是重要的。这种行为依赖事件或依赖时间的原因在于对象内部存在状态。 ⏱ 2021-09-27 07:10:13</p></blockquote><blockquote><p>📌 “对象的状态包括这个对象的所有属性（通常是静态的）以及每个属性当前的值（通常是动态的）。” ⏱ 2021-09-27 07:10:37</p></blockquote><blockquote><p>📌 属性是一种内在或独特的特征、特点、品质或特性，使一个对象区别于别的对象。 ⏱ 2021-09-27 07:11:38</p></blockquote><blockquote><p>📌 所有的对象都有某种值，这个值可能是一个简单的数量，也可能代表另一个对象。 ⏱ 2021-09-27 07:12:21</p></blockquote><blockquote><p>📌 每个对象都有状态。这一事实意味着，每个对象都会在物理世界或计算机内存中占据一定的空间。 ⏱ 2021-09-27 07:13:18</p></blockquote><blockquote><p>📌 可以说，系统中所有的对象都封装了某种状态，系统中所有的状态都由对象所封装。 ⏱ 2021-09-27 07:19:29</p></blockquote><blockquote><p>📌 这些对象不会与其他对象共享空间，虽然它们都有相同的属性。它们的状态具有共同的表现形式。 ⏱ 2021-09-27 07:20:29</p></blockquote><blockquote><p>📌 没有对象是孤立存在的。对象与对象之间会相互操作。因此，我们可以这样说：“行为是对象在状态改变和消息传递方面的动作和反应的方式。”换言之，对象的行为代表了它外部可见的活动。 ⏱ 2021-09-27 07:24:11</p></blockquote><blockquote><p>📌 ，我们说一个对象向另一个对象传递一个消息。一般来说，一个消息就是一个对象执行了另一个对象的操作， ⏱ 2021-09-27 07:31:11</p></blockquote><blockquote><p>📌 因此可以说，一个对象的行为是它的状态以及施加在它上面的操作的函数。这个副作用的概念让我们改进了状态的定义：“一个对象的状态代表了它的行为的累积效果。” ⏱ 2021-09-27 07:32:48</p></blockquote><blockquote><p>📌 一个对象的所有方法共同构成了它的协议。因此，一个对象的协议定义了对象允许的行为的封装，构成了这个对象完整的静态视图和动态视图。 ⏱ 2021-09-27 07:52:03</p></blockquote><h3 id="_3-2-对象之间的关系" tabindex="-1">3.2 对象之间的关系 <a class="header-anchor" href="#_3-2-对象之间的关系" aria-label="Permalink to &quot;3.2 对象之间的关系&quot;">​</a></h3><blockquote><p>📌 一个对象本身是非常无趣的。对象通过与其他对象协作，为系统的行为做出贡献。 ⏱ 2021-09-29 09:09:24</p></blockquote><blockquote><p>📌 通过这种关联，一个对象（客户）请求另一个对象（服务提供者）的服务，或者通过这种关联从一个对象导航到另一个对象。 ⏱ 2021-09-30 01:26:48</p></blockquote>',142)])])}const h=e(u,[["render",b]]);export{n as __pageData,h as default};
