import{_ as e,o as t,c as o,a6 as r}from"./chunks/framework.BB0md0jN.js";const q=JSON.parse('{"title":"Unity 3D游戏开发（第2版）","description":"","frontmatter":{"layout":"doc","title":"Unity 3D游戏开发（第2版）","readingTime":"7 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/计算机_软件学习/Unity_3D游戏开发第2版.md","filePath":"电影和阅读/微信读书/计算机_软件学习/Unity_3D游戏开发第2版.md"}'),l={name:"电影和阅读/微信读书/计算机_软件学习/Unity_3D游戏开发第2版.md"};function i(n,a,c,d,h,u){return t(),o("div",null,[...a[0]||(a[0]=[r('<h1 id="unity-3d游戏开发-第2版" tabindex="-1">Unity 3D游戏开发（第2版） <a class="header-anchor" href="#unity-3d游戏开发-第2版" aria-label="Permalink to &quot;Unity 3D游戏开发（第2版）&quot;">​</a></h1><p><img src="https://cdn.weread.qq.com/weread/cover/41/YueWen_38493651/t6_YueWen_38493651.jpg" alt=" Unity 3D游戏开发（第2版）"></p><ul><li><strong>书名</strong>： Unity 3D游戏开发（第2版）</li><li><strong>作者</strong>： 宣雨松编著</li><li><strong>简介</strong>： Unity是一款市场占有率非常高的商业游戏引擎，横跨25个主流游戏平台。本书基于Unity 2018，结合2D游戏开发和3D游戏开发的案例，详细介绍了它的方方面面，内容涉及编辑器、游戏脚本、UGUI游戏界面、动画系统、持久化数据、静态对象、多媒体、资源加载与优化、自动化与打包等。本书适合初学者或者有一定基础的开发者阅读。</li><li><strong>出版时间</strong>： 2018-09-01 00:00:00</li><li><strong>ISBN</strong>： 9787115492944</li><li><strong>分类</strong>： 计算机-软件学习</li><li><strong>出版社</strong>： 人民邮电出版社</li><li><strong>PC地址</strong>： <a href="https://weread.qq.com/web/reader/2e332790724b5dd32e3a16c" target="_blank" rel="noreferrer">https://weread.qq.com/web/reader/2e332790724b5dd32e3a16c</a></li></ul><h3 id="_4-3-多脚本管理" tabindex="-1">4.3 多脚本管理 <a class="header-anchor" href="#_4-3-多脚本管理" aria-label="Permalink to &quot;4.3 多脚本管理&quot;">​</a></h3><blockquote><p>📌 学过编程的朋友都应该知道计算机处理是没有同时这个概念的，它们都是有先后顺序的，也就是说排在前面的脚本会优先执行。 ⏱ 2021-11-18 10:54:50</p></blockquote><h4 id="_4-3-2-多脚本优化" tabindex="-1">4.3.2 多脚本优化 <a class="header-anchor" href="#_4-3-2-多脚本优化" aria-label="Permalink to &quot;4.3.2 多脚本优化&quot;">​</a></h4><blockquote><p>📌 脚本挂得越多，执行效率就越低。这些脚本都需要执行生命周期的方法，此时Unity需要遍历它们，然后再反射调用每个脚本的方法。 ⏱ 2021-11-18 10:55:16</p></blockquote><h4 id="_7-5-1-创建timeline" tabindex="-1">7.5.1 创建Timeline <a class="header-anchor" href="#_7-5-1-创建timeline" aria-label="Permalink to &quot;7.5.1 创建Timeline&quot;">​</a></h4><blockquote><p>📌 Activation Track：激活轨迹。绑定游戏对象后，在时间线中进行隐藏和显示操作。 ⏱ 2021-11-22 09:21:04</p></blockquote><blockquote><p>📌 Control Track：控制轨迹。需要绑定Prefab，它可在时间线中动态实例化并且挂在某个节点下，例如特效。 ⏱ 2021-11-22 09:19:40</p></blockquote><h4 id="_7-5-2-activation-track" tabindex="-1">7.5.2 Activation Track <a class="header-anchor" href="#_7-5-2-activation-track" aria-label="Permalink to &quot;7.5.2 Activation Track&quot;">​</a></h4><blockquote><p>📌 时间线结束后，可以设置模型的状态，其中Active表示激活，Inactive表示隐藏，Revert表示还原初始状态，Leave As Is表示保留最后的状态。 ⏱ 2021-11-22 09:21:46</p></blockquote><h4 id="_7-5-3-animation-track" tabindex="-1">7.5.3 Animation Track <a class="header-anchor" href="#_7-5-3-animation-track" aria-label="Permalink to &quot;7.5.3 Animation Track&quot;">​</a></h4><blockquote><p>📌 Add Override Track表示还可以添加一个Override层，它和前面讲过的Avatar Mask一样，可以添加遮罩，以禁止该层上的动画。 ⏱ 2021-11-22 09:22:04</p></blockquote><h3 id="_7-6-playables" tabindex="-1">7.6 Playables <a class="header-anchor" href="#_7-6-playables" aria-label="Permalink to &quot;7.6 Playables&quot;">​</a></h3><blockquote><p>📌 如果游戏中的模型动画很多，每一个都需要手动用Animator Controller来连线的话，那就太麻烦了。截止到目前，依然有很多项目在使用老版本动画系统，其原因就是老版动画系统是纯代码控制的，不需要创建Animator Controller文件，控制起来更加灵活。 ⏱ 2021-11-22 09:32:02</p></blockquote><h4 id="_13-1-1-固定渲染管线" tabindex="-1">13.1.1 固定渲染管线 <a class="header-anchor" href="#_13-1-1-固定渲染管线" aria-label="Permalink to &quot;13.1.1 固定渲染管线&quot;">​</a></h4><blockquote><p>📌 每个Pass就是一个DrawCall，所以尽量只使用一个Pass。 ⏱ 2021-11-18 11:08:34</p></blockquote><h4 id="_13-1-2-可编程渲染管线" tabindex="-1">13.1.2 可编程渲染管线 <a class="header-anchor" href="#_13-1-2-可编程渲染管线" aria-label="Permalink to &quot;13.1.2 可编程渲染管线&quot;">​</a></h4><blockquote><p>📌 如果需要对每一个片段像素点做特殊着色，那么在Shader中首先需要获取几何图形对应的顶点以及UV信息，然后通过UV以及贴图拿到当前片段的像素信息，最终就可以自定义着色了。 ⏱ 2021-11-19 09:46:40</p></blockquote><blockquote><p>📌 使用CGPROGRAM和ENDCG来标记CG程序块，这是标准的C++ 语法。 ⏱ 2021-11-19 09:47:48</p></blockquote><blockquote><p>📌 。光照模型的算法是一致的，然而都需要在vertex方法中实现。 ⏱ 2021-11-22 09:05:02</p></blockquote><h4 id="_13-1-4-深度排序" tabindex="-1">13.1.4 深度排序 <a class="header-anchor" href="#_13-1-4-深度排序" aria-label="Permalink to &quot;13.1.4 深度排序&quot;">​</a></h4><blockquote><p>📌 模型之间是有遮挡关系的，所以需要设置模型之间的渲染顺序，这可以在Shader中标明，例如Tags{&quot;RenderType&quot;=&quot;Opaque&quot;}。一共分为5个类型，它们代表的数值也不一样。 ⏱ 2021-11-22 09:06:30</p></blockquote><h4 id="_13-1-5-透明" tabindex="-1">13.1.5 透明 <a class="header-anchor" href="#_13-1-5-透明" aria-label="Permalink to &quot;13.1.5 透明&quot;">​</a></h4><blockquote><p>📌 在Shader中要实现透明效果，可以使用Alpha Test和Alpha Blend这两种方式。 ⏱ 2021-11-22 09:07:00</p></blockquote><blockquote><p>📌 可以看到，Alpha Blend透明部分会和背景混合，而Alpha Test则不会，只会出现透明和不透明两种结果。 ⏱ 2021-11-22 09:07:18</p></blockquote><blockquote><p>📌 Alpha Test无法做混合。而且由于移动平台下不支持Early-Z，它的效率会比Alpha Blend慢。游戏中有时候还需要用到它，比如类似自身溶解的效果。Alpha Blend的使用场景就非常多了，比如粒子特效、角色身体、翅膀等发光效果。 ⏱ 2021-11-22 09:07:42</p></blockquote><blockquote><p>📌 由于透明会出现混合的现象，这样渲染队列必须是从后向前渲染，此时就会出现大量的过度绘制（overdraw）的现象。如果是不透明的话，可以将它设置到Geometry上，这样渲染顺序就会从前向后渲染。 ⏱ 2021-11-22 09:08:07</p></blockquote><blockquote><p>📌 最后，大家在写Shader的时候，尤其需要注意复杂的数学函数。在片段着色器中，每个点都需要做运算，可想而知它的效率。强烈推荐使用Mobile下的Shader，其运行效率更高，但是可选参数很少。大部分情况下，Mobile下的Shader可以满足需求。 ⏱ 2021-11-22 09:08:42</p></blockquote><h4 id="_13-1-7-着色器变体采集" tabindex="-1">13.1.7 着色器变体采集 <a class="header-anchor" href="#_13-1-7-着色器变体采集" aria-label="Permalink to &quot;13.1.7 着色器变体采集&quot;">​</a></h4><blockquote><p>📌 通常，Shader可以直接放在Resources目录下。运行时，可以这样读取：Shader a = Resources.Load&lt;Shader&gt;(&quot;shader name&quot;);Shader b = Shader.Find(&quot;shader name&quot;); ⏱ 2021-11-22 09:09:15</p></blockquote>',32)])])}const b=e(l,[["render",i]]);export{q as __pageData,b as default};
