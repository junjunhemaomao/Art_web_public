import{_ as e,o as t,c as l,a6 as a}from"./chunks/framework.BB0md0jN.js";const n=JSON.parse('{"title":"游戏编程模式","description":"","frontmatter":{"layout":"doc","title":"游戏编程模式","readingTime":"16 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/计算机_计算机综合/游戏编程模式.md","filePath":"电影和阅读/微信读书/计算机_计算机综合/游戏编程模式.md"}'),c={name:"电影和阅读/微信读书/计算机_计算机综合/游戏编程模式.md"};function u(b,o,q,r,p,k){return t(),l("div",null,[...o[0]||(o[0]=[a('<h1 id="游戏编程模式" tabindex="-1">游戏编程模式 <a class="header-anchor" href="#游戏编程模式" aria-label="Permalink to &quot;游戏编程模式&quot;">​</a></h1><p><img src="https://cdn.weread.qq.com/weread/cover/47/YueWen_22651409/t6_YueWen_22651409.jpg" alt=" 游戏编程模式"></p><ul><li><strong>书名</strong>： 游戏编程模式</li><li><strong>作者</strong>： Robert Nystrom</li><li><strong>简介</strong>： 游戏开发一直是热门的领域，掌握良好的游戏编程模式是开发人员的应备技能。本书细致地讲解了游戏开发需要用到的各种编程模式，并提供了丰富的示例。全书共分20章，通过三大部分内容全面介绍了与游戏编程模式相关的各类知识点。首部分介绍了基础知识和框架；第二部分深入探索设计模式，并介绍了模式与游戏开发之间的关联；第三部分介绍了13种有效的游戏设计模式。本书提供了丰富的代码示例，通过理论和代码示例相结合的方式帮助读者更好地学习。无论是游戏领域的设计人员、开发人员，还是想要进入游戏开发领域的学生和普通程序员，都可以阅读本书。</li><li><strong>出版时间</strong>： 2016-09-01 00:00:00</li><li><strong>ISBN</strong>： 9787115426888</li><li><strong>分类</strong>： 计算机-计算机综合</li><li><strong>出版社</strong>： 人民邮电出版社</li><li><strong>PC地址</strong>： <a href="https://weread.qq.com/web/reader/6b932b607159a2116b93835" target="_blank" rel="noreferrer">https://weread.qq.com/web/reader/6b932b607159a2116b93835</a></li></ul><h2 id="第1篇-概述" tabindex="-1">第1篇 概述 <a class="header-anchor" href="#第1篇-概述" aria-label="Permalink to &quot;第1篇 概述&quot;">​</a></h2><blockquote><p>📌 每个程序都具有一定的组织性，即使它只是“把所有东西扔到main()函数里然后看看会发生什么 ⏱ 2020-08-13 00:05:20</p></blockquote><blockquote><p>📌 衡量一个设计好坏的方法就是看它应对变化的灵活性。 ⏱ 2020-08-13 00:08:04</p></blockquote><blockquote><p>📌 在你打开编辑器添加新功能，修复bug或者由于其他原因要修改代码之前，你必须要明白现有的代码在做什么。 ⏱ 2020-08-13 00:08:18</p></blockquote><blockquote><p>📌 我们倾向于略过这一步，但它往往是编程中最耗时的部分。 ⏱ 2020-08-13 00:08:43</p></blockquote><blockquote><p>📌 一旦你的大脑有了一个全面正确的认识，则只需稍微思考一下就能提出解决方案。这观点值得反复斟酌，但通常这是比较明确的。一旦你理解了这个问题和它涉及的代码，则实际的编码有时是微不足道的。 ⏱ 2020-08-13 00:08:55</p></blockquote><blockquote><p>📌 如果两块代码耦合，意味着你必须同时了解这两块代码。如果你让它们解耦，那么你只需了解其一。 ⏱ 2020-08-13 00:10:52</p></blockquote><blockquote><p>📌 对我来说，这是软件架构的一个关键目标：在你前进前，最小化你脑海中的知识储存量。 ⏱ 2020-08-13 00:11:03</p></blockquote><blockquote><p>📌 天下没有免费的午餐。良好的架构需要很大的努力及一系列准则。 ⏱ 2020-08-13 00:12:12</p></blockquote><blockquote><p>📌 事情就在这里开始变得棘手。当你添加了一个抽象层或者支持可扩展的地方，你猜想到你以后会需要这种灵活性，于是你便为你的游戏增加了代码和复杂性，这需要时间来开发、调试和维护。 ⏱ 2020-08-13 00:17:56</p></blockquote><blockquote><p>📌 从理论上讲，解耦意味着在你进行扩展时仅需理解少量代码，然而抽象却增加了理解代码的难度。 ⏱ 2020-08-13 00:18:47</p></blockquote><blockquote><p>📌 一味地追求可扩展性让无数开发者在一个“引擎”上花费数年却没有搞清楚引擎究竟是用来做什么的。 ⏱ 2020-08-13 00:19:10</p></blockquote><blockquote><p>📌 你越快地对想法付诸实践并观察效果，你就能越多地尝试并越有可能找到一些很棒的东西。即便在你已经找到合适的技术之后，你也要用充足的时间来进行调整。 ⏱ 2020-08-13 00:21:02</p></blockquote><blockquote><p>📌 根据我的经验，将一款有趣的游戏做得高效要比将一款高性能的游戏做的有趣更简单些。一种折中的办法是保持代码的灵活性，直到设计稳定下来，然后去除一些抽象，以提高游戏的性能。</p></blockquote><ul><li>💭 先跑通逻辑，验证细节，然后优化性能。先创作出来，再去优化。 - ⏱ 2020-08-13 00:23:24</li></ul><blockquote><p>📌 游戏设计需要大量的试验和探索，特别是在早期，编写一些你知道迟早要扔掉的代码是很稀松平常的。 ⏱ 2020-08-13 00:26:11</p></blockquote><blockquote><p>📌 好的架构从长远来看，改进了生产力，但维护一个良好的架构就意味着每一个变化都需要更多的努力来保持代码的干净。 ⏱ 2020-08-13 00:32:04</p></blockquote><blockquote><p>📌 高度优化过的代码缺乏灵活性，很难改变。 ⏱ 2023-10-14 22:22:09</p></blockquote><blockquote><p>📌 在一周内便可掌握的领域最终是无聊的。你不会接触到在别人的杰出职业生涯中所挖掘出的东西。 ⏱ 2020-08-13 00:33:57</p></blockquote><blockquote><p>📌 我们很少会遇到一个非常复杂的问题，用例反而有一大堆，例如，你想让X在Z的情况下执行Y而在A的情况下执行W，以此类推。换句话说，是一个不同实例行为的长列表。 最省脑力的方法就是只编写一次测试用例。 ⏱ 2023-10-14 22:27:37</p></blockquote><blockquote><p>📌 当我们考虑优雅的解决方案时，浮现脑海中的就有一个：一小块逻辑就能正确地处理一大片用例。 你会发现这有点像模式匹配或解谜。它需要努力识破测试用例的分散点， ⏱ 2023-10-14 22:28:02</p></blockquote><blockquote><p>📌 抽象和解耦能够使得你的程序开发变得更快和更简单。但不要浪费时间来做这件事，除非你确信存在问题的代码需要这种灵活性。·在你的开发周期中要对性能进行思考和设计，但是要推迟那些降低灵活性的、底层的、详尽的优化，能晚则晚。 ⏱ 2020-08-13 00:36:49</p></blockquote><blockquote><p>📌 如果你将要删除代码，那么不要浪费时间将它整理得很整洁。摇滚明星把酒店房间弄得很乱是因为他们知道第二天就要结账走人。 ⏱ 2020-08-13 00:37:43</p></blockquote><blockquote><p>📌 相信我，在游戏发布前的两个月并不是你开始担心“游戏的FPS只有1帧”问题的时候。 ⏱ 2020-08-13 00:37:56</p></blockquote><h3 id="第2章-命令模式" tabindex="-1">第2章 命令模式 <a class="header-anchor" href="#第2章-命令模式" aria-label="Permalink to &quot;第2章 命令模式&quot;">​</a></h3><blockquote><p>📌 将一个请求（request）封装成一个对象，从而允许你使用不同的请求、队列或日志将客户端参数化，同时支持请求操作的撤销与恢复。 ⏱ 2023-10-14 22:47:26</p></blockquote><blockquote><p>📌 命令模式是我最喜爱的模式之一。在我开发的绝大多数大型游戏或其他程序中，最终都用到了它。正确地使用它，你的代码会变得更加优雅。 ⏱ 2023-10-14 22:47:37</p></blockquote><blockquote><p>📌 命令就是一个对象化（实例化）的方法调用（A command is a reified method call） ⏱ 2023-10-14 22:48:34</p></blockquote><blockquote><p>📌 命令模式是一个“对象化的方法调用”，我的意思就是封装在一个对象中的一个方法调用。 ⏱ 2023-10-14 22:53:26</p></blockquote><blockquote><p>📌 每个游戏都有一处代码块用来读取用户原始输入：按钮点击、键盘事件、鼠标点击，或者其他输入等。它记录每次的输入，并将之转换为游戏中一个有意义的动作（action），如图2-1所示。[插图]图2-1 按钮与游戏行为的映射 ⏱ 2020-08-13 00:41:20</p></blockquote><blockquote><p>📌 许多游戏允许用户配置他们的按钮与游戏行为之间的映射关系。为了支持自定义配置，我们需要把那些对jump()和fireGun()方法的直接调用转换为我们可以更换（swap out）的东西。 ⏱ 2020-08-13 00:56:52</p></blockquote><blockquote><p>📌 以前每个输入都会直接调用一个函数，现在则增加了一个间接调用层，如图2-2所示。[插图]图2-2 按钮与可分配命令的映射简而言之，这就是命令模式。 ⏱ 2020-08-13 00:58:26</p></blockquote><blockquote><p>📌 而在命令和角色之间加入的间接层使得我们可以让玩家控制游戏中的任何角色，只需通过改变命令执行时传入的角色对象即可。 ⏱ 2020-08-13 00:45:51</p></blockquote><blockquote><p>📌 选择命令的AI和表现玩家的代码之间的解耦为我们提供了很大的灵活性。我们可以对不同的角色使用不同的AI模块。或者我们可以针对不同种类的行为将AI进行混搭。你想要一个更加具有侵略性的敌人？只需要插入一段更具侵略性的AI代码来为它生成命令。 ⏱ 2020-08-13 01:06:58</p></blockquote><blockquote><p>📌 解除了函数直接调用这样的紧耦合。把它想象成一个队列（queue）或者一个命令流 ⏱ 2020-08-13 01:09:04</p></blockquote><blockquote><p>📌 一些代码（输入处理或者AI）生成命令并将它们放置于命令流中，一些代码（发送者或者角色自身）执行命令并且调用它们。通过中间的队列，我们将生产者端和消费者端解耦。 ⏱ 2020-08-13 01:10:19</p></blockquote><blockquote><p>📌 如果我们把这些命令序列化，我们便可以通过网络发送数据流。我们可以把玩家的输入，通过网络发送到另外一台机器上，然后进行回放。这是多人网络游戏很重要的一部分。 ⏱ 2020-08-13 01:10:47</p></blockquote><blockquote><p>📌 如果没有命令模式，那么实现撤销是很困难的。有了它，这简直是小菜一碟啊。假定一个情景，我们在制作一款单人回合制的游戏，我们想让玩家能够撤销一些行动以便他们能够更多地专注于策略而不是猜测。 ⏱ 2020-08-13 01:13:23</p></blockquote><blockquote><p>📌 支持多次撤销并不难。这次我们不再保存最后一个命令，取而代之的是，我们维护一个命令列表和一个对“当前”（current）命令的一个引用。当玩家执行了一个命令，我们将这个命令添加到列表中，并将“current”指向它（见图2-4）。 ⏱ 2020-08-13 01:16:34</p></blockquote><blockquote><p>📌 我们需要制定规则来确保每个数据的更改都经由一个命令实现，但只要定了规则，剩下的就容易得多。 ⏱ 2020-08-13 01:17:25</p></blockquote><blockquote><p>📌 重做在游戏中并不常见，但回放却很常见。一个很简单的实现方法就是记录每一帧的游戏状态以便能够回放，但是这样会使用大量的内存。 ⏱ 2020-08-13 01:34:28</p></blockquote><blockquote><p>📌 在某些方面，命令模式对于没有闭包的语言来说是模拟闭包的一种方式。</p></blockquote><ul><li>💭 是一个数据序列和操作序列，模拟闭包函数内的算法 - ⏱ 2020-08-13 01:35:54</li></ul><blockquote><p>📌 对于我来说，命令模式真实地展现出了函数式编程在解决许多问题时的高效性。 ⏱ 2020-08-13 01:49:25</p></blockquote><h3 id="第4章-观察者模式" tabindex="-1">第4章 观察者模式 <a class="header-anchor" href="#第4章-观察者模式" aria-label="Permalink to &quot;第4章 观察者模式&quot;">​</a></h3><blockquote><p>📌 观察者模式在GoF设计模式里面的使用最为广泛，是最为人所熟知的设计模式之一。但是，它在游戏开发领域有时候却应用不多。所以，它对你而言可能会有些陌生。 ⏱ 2024-08-11 22:54:54</p></blockquote><h2 id="第1篇-概述-1" tabindex="-1">第1篇 概述 <a class="header-anchor" href="#第1篇-概述-1" aria-label="Permalink to &quot;第1篇 概述&quot;">​</a></h2><h3 id="划线评论" tabindex="-1">划线评论 <a class="header-anchor" href="#划线评论" aria-label="Permalink to &quot;划线评论&quot;">​</a></h3><blockquote><p>📌 根据我的经验，将一款有趣的游戏做得高效要比将一款高性能的游戏做的有趣更简单些。一种折中的办法是保持代码的灵活性，直到设计稳定下来，然后去除一些抽象，以提高游戏的性能。<br> - 💭 先跑通逻辑，验证细节，然后优化性能。先创作出来，再去优化。 - ⏱ 2020-08-13 00:24:15</p></blockquote><h3 id="划线评论-1" tabindex="-1">划线评论 <a class="header-anchor" href="#划线评论-1" aria-label="Permalink to &quot;划线评论&quot;">​</a></h3><blockquote><p>📌 根据我的经验，将一款有趣的游戏做得高效要比将一款高性能的游戏做的有趣更简单些。<br> - 💭 有趣比高效更难 - ⏱ 2020-08-13 00:22:50</p></blockquote><h2 id="第2章-命令模式-1" tabindex="-1">第2章 命令模式 <a class="header-anchor" href="#第2章-命令模式-1" aria-label="Permalink to &quot;第2章 命令模式&quot;">​</a></h2><h3 id="划线评论-2" tabindex="-1">划线评论 <a class="header-anchor" href="#划线评论-2" aria-label="Permalink to &quot;划线评论&quot;">​</a></h3><blockquote><p>📌 在某些方面，命令模式对于没有闭包的语言来说是模拟闭包的一种方式。<br> - 💭 是一个数据序列和操作序列，模拟闭包函数内的算法 - ⏱ 2020-08-13 01:36:47</p></blockquote>',57)])])}const s=e(c,[["render",u]]);export{n as __pageData,s as default};
