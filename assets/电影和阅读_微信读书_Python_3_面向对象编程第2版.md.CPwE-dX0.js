import{_ as t,o as e,c as a,a6 as l}from"./chunks/framework.BB0md0jN.js";const k=JSON.parse('{"title":"Python 3 面向对象编程（第2版）","description":"","frontmatter":{"layout":"doc","title":"Python 3 面向对象编程（第2版）","readingTime":"22 min read"},"headers":[],"relativePath":"电影和阅读/微信读书/Python_3_面向对象编程第2版.md","filePath":"电影和阅读/微信读书/Python_3_面向对象编程第2版.md"}'),c={name:"电影和阅读/微信读书/Python_3_面向对象编程第2版.md"};function r(u,o,b,n,p,q){return e(),a("div",null,[...o[0]||(o[0]=[l('<h1 id="python-3-面向对象编程-第2版" tabindex="-1">Python 3 面向对象编程（第2版） <a class="header-anchor" href="#python-3-面向对象编程-第2版" aria-label="Permalink to &quot;Python 3 面向对象编程（第2版）&quot;">​</a></h1><p><img src="https://cdn.weread.qq.com/weread/cover/68/cpplatform_ohrrzmumpftjohtdw5k1nf/t6_cpplatform_ohrrzmumpftjohtdw5k1nf1681438731.jpg" alt=" Python 3 面向对象编程（第2版）"></p><ul><li><strong>书名</strong>： Python 3 面向对象编程（第2版）</li><li><strong>作者</strong>： 【加】Dusty Phillips</li><li><strong>简介</strong>： 本书主要介绍如何使用Python 3进行面向对象编程。第1~4章介绍面向对象这一编程范式的基本准则，以及Python是如何运用这些准则实现面向对象编程的；第5~8章介绍如何利用Python中的内置函数快速、简单地实现面向对象编程；第9~11章介绍许多面向对象编程中常用的设计模式，以及如何使用符合Python语言习惯的方式来实现这些设计模式；最后，第12、13章介绍Python 3中与并发编程相关的主题。 本书中的每一章都会包含一节案例学习的内容，通过一个实践相关的案例将本章介绍的主要内容以及前面章节中介绍过的内容串联起来。除此之外，每一章最后的练习旨在指导你利用本章学习到的知识，使用面向对象编程改善以往项目中的代码，并进一步掌握如何在合适的时机使用Python 3进行面向对象编程。</li><li><strong>出版时间</strong>： 2018-06-01 00:00:00</li><li><strong>ISBN</strong>： 9787121341366</li><li><strong>分类</strong>： 计算机-计算机综合</li><li><strong>出版社</strong>： 电子工业出版社</li><li><strong>PC地址</strong>： <a href="https://weread.qq.com/web/reader/b6e328e0813ab7c25g012fbe" target="_blank" rel="noreferrer">https://weread.qq.com/web/reader/b6e328e0813ab7c25g012fbe</a></li></ul><h2 id="第1章-面向对象设计" tabindex="-1">第1章 面向对象设计 <a class="header-anchor" href="#第1章-面向对象设计" aria-label="Permalink to &quot;第1章 面向对象设计&quot;">​</a></h2><blockquote><p>📌 在软件开发中，设计通常被认为是发生在编程之前的步骤，然而这并不是真的。在现实中，分析、编程与设计是相互重叠、组合、交织在一起的。 ⏱ 2023-08-22 13:19:33</p></blockquote><h3 id="面向对象" tabindex="-1">面向对象 <a class="header-anchor" href="#面向对象" aria-label="Permalink to &quot;面向对象&quot;">​</a></h3><blockquote><p>📌 通常来说，真实世界总是更加黑暗的。无论我们如何努力想要区分这些阶段，我们总会发现在设计阶段还有很多东西需要进一步分析。在编程时也总能发现需要在设计阶段澄清的特性。 ⏱ 2023-08-22 13:21:39</p></blockquote><blockquote><p>📌 21世纪绝大多数的开发都遵循迭代开发模型。在迭代开发中，一小块任务将会被建模、设计并通过编程实现，然后这些程序将在后续一系列的快速开发循环中不断被检查、扩展，从而改善已有特征并加入新的特性。 ⏱ 2023-08-22 13:22:04</p></blockquote><h3 id="指定属性和行为" tabindex="-1">指定属性和行为 <a class="header-anchor" href="#指定属性和行为" aria-label="Permalink to &quot;指定属性和行为&quot;">​</a></h3><blockquote><p>📌 通常，在设计阶段我们不需要过度担心数据类型的问题，因为具体的实现细节是在编程阶段来选择的。 ⏱ 2023-08-22 21:39:53</p></blockquote><blockquote><p>📌 然而，有一些隐含的属性我们可以进一步说明——对象之间的关系。对于一个橘子，我们可能有一个属性用来表示这个橘子所在的篮子。 ⏱ 2023-08-22 21:47:57</p></blockquote><blockquote><p>📌 像函数一样，方法也接收一些参数并返回值。参数(parameter)对于方法来说就是在调用方法时需要传递给方法的一系列对象（传递给调用对象的对象通常被称为实参(argument)）。 ⏱ 2023-08-22 21:52:11</p></blockquote><blockquote><p>📌 给每个对象添加模型和方法让我们能够创建一个由交互对象所组成的系统。系统中的每个对象都是特定类的成员。这些类指定了对象可以拥有哪些类型的数据以及可以调用什么样的方法。每个对象的数据可能与同一类中其他对象的数据处于不同的状态，因为数据状态不同，所以在调用每个对象的方法时可能产生不同的反应。 面向对象的分析与设计就是为了弄清楚这些对象是什么以及它们之间如何交互。 ⏱ 2023-08-22 22:01:52</p></blockquote><h3 id="隐藏细节并创建公共接口" tabindex="-1">隐藏细节并创建公共接口 <a class="header-anchor" href="#隐藏细节并创建公共接口" aria-label="Permalink to &quot;隐藏细节并创建公共接口&quot;">​</a></h3><blockquote><p>📌 在面向对象设计中建模对象的关键目的在于，决定该对象的公共接口是什么。接口是对象的一些属性与方法的集合，其他对象可以用接口与这个对象进行交互。其他对象不需要，通常也不允许，获取对象的内部内容。一个真实世界中常见的例子就是电视机。 ⏱ 2023-08-22 22:04:50</p></blockquote><blockquote><p>📌 被封装的数据并不一定是隐藏的。 ⏱ 2023-08-22 22:03:28</p></blockquote><blockquote><p>📌 公共接口还是非常重要的，需要仔细设计，因为在未来很难更改。更改接口将会导致所有调用它的客户端对象出错。我们可以随意改变内部构造 ⏱ 2023-08-22 22:25:22</p></blockquote><blockquote><p>📌 如果我们改变了接口中可以公开获取的属性名，或者更改了方法参数的顺序或类型，所有的客户端对象都需要进行更改。在讨论公共接口的时候，应尽量保持简单，永远基于易用性而非编码的难度来设计对象接口 ⏱ 2023-08-22 22:25:45</p></blockquote><blockquote><p>📌 ，抽象意味着只处理与给定任务相关的最必要的一层细节，是从内部细节中提取公共接口的过程。汽车司机需要与方向盘、油门和刹车进行交互，而不需要考虑发动机、传动系统以及刹车系统的工作原理。 ⏱ 2023-08-22 22:26:56</p></blockquote><blockquote><p>📌 不要对将来可能有用的对象或行为进行建模，而是建模系统当前需要执行的任务，这样设计将会自然而然地落在合适的抽象层 ⏱ 2023-08-22 22:39:53</p></blockquote><h3 id="组合" tabindex="-1">组合 <a class="header-anchor" href="#组合" aria-label="Permalink to &quot;组合&quot;">​</a></h3><blockquote><p>📌 组合是将几个对象收集在一起生成一个新对象的行为。当一个对象是另外一个对象的一部分时，组合通常是不错的选择。 ⏱ 2023-08-22 22:43:05</p></blockquote><blockquote><p>📌 面向对象系统中的对象偶尔也会代表物理对象，例如人、书或者手机。但是更多时候代表的是抽象的概念。人有名字、书有标题、手机用于打电话，我们通常不把打电话、标题、账号、名字、约会以及支付等看作物理世界中的对象，但是它们在计算机系统中却经常被建模。 ⏱ 2023-08-22 22:44:04</p></blockquote><blockquote><p>📌 聚合几乎与组合的概念相同，区别在于聚合的对象可以独立存在。 ⏱ 2023-08-22 23:50:57</p></blockquote><blockquote><p>📌 组合关系在UML中用实心的菱形表示，而空心菱形表示聚合关系。 ⏱ 2023-08-22 23:54:00</p></blockquote><h3 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-label="Permalink to &quot;继承&quot;">​</a></h3><blockquote><p>📌 在子类型中重写方法让我们能够开发非常强大的面向对象系统。 ⏱ 2023-08-22 23:57:56</p></blockquote><blockquote><p>📌 创建为抽象类并将移动方法声明为抽象方法来实现。抽象方法基本上就是说，“我们要求所有非抽象的子类中必须存在这一方法，但是在当前类中暂不提供实现方案。” 实际上，我们可以让一个类不实现任何方法。这样一个类只会告诉我们它可以做什么，但是完全不告诉我们要如何去做。用面向对象的语言，这种类叫作接口 ⏱ 2023-08-23 00:03:19</p></blockquote><blockquote><p>📌 继承是“是一个”关系最优的解决方案，但是可能被滥用。程序员经常用继承来共享代码，即使两种对象之间可能只有很少的关联，而不是“是一个”关系。虽然这并不一定就是不好的设计，但这是一个极好的机会去问一下他们为何要采用这样的设计，用别的关系或设计模式是否会更合适。 ⏱ 2023-08-23 00:29:02</p></blockquote><h3 id="练习" tabindex="-1">练习 <a class="header-anchor" href="#练习" aria-label="Permalink to &quot;练习&quot;">​</a></h3><blockquote><p>📌 考虑属性的类型，它们是基本类型还是类？有没有哪些属性实际上是行为伪装的？有时候有些看起来像是数据的属性实际上是从对象中的其他数据计算得来的，并且你可以通过一个方法完成这些计算。 ⏱ 2023-08-23 00:30:20</p></blockquote><blockquote><p>📌 从系统的最高抽象层草拟出类图，找出最主要的交互对象和较少支持的对象。从最有趣的几个对象入手深入其属性和方法的细节。将不同的对象带入不同层次的抽象，找到可以应用继承或组合关系的地方，找到应该避免使用继承关系的地方。 ⏱ 2023-08-23 00:31:07</p></blockquote><blockquote><p>📌 现在，打开你最常用的搜索引擎去搜索一些UML教程。这样的教程有很多，找到最契合你自己的学习方法。试着为你前面找到的对象画一些类图或时序图。不要太纠结于记住语法（毕竟，如果它很重要，你还可以以后再查），只是感受一下这门语言。有些东西会留在你的大脑中，如果你在下一次面向对象编程讨论中可以快速画一些草图，它可以帮助你更容易地沟通。 ⏱ 2023-08-23 00:32:10</p></blockquote><h3 id="创建python类" tabindex="-1">创建Python类 <a class="header-anchor" href="#创建python类" aria-label="Permalink to &quot;创建Python类&quot;">​</a></h3><blockquote><p>📌 任何好用的代码编辑器都支持将Tab键输入替换为4个空格。 ⏱ 2023-08-23 00:55:21</p></blockquote><blockquote><p>📌 为对象属性赋值的语法是&lt;对象&gt;.&lt;属性&gt;=&lt;值&gt;。这种方法被称为点标记法(dot notation)。 ⏱ 2023-08-23 00:40:50</p></blockquote><blockquote><p>📌 面向对象编程的重点在于不同对象之间的交互 ⏱ 2023-08-23 00:44:00</p></blockquote><blockquote><p>📌 正常函数与方法之间的区别之一是，所有的方法都有一个必要的参数。 ⏱ 2023-08-29 20:39:09</p></blockquote><blockquote><p>📌 大多数面向对象编程语言都有构造函数(constructor)的概念，是创建对象时进行创建和初始化的特定方法。Python有一点不一样，它同时拥有构造函数和初始化方法。除非你需要做一些异乎寻常的事，否则很少用到构造函数，所以我们就先讨论初始化方法。 ⏱ 2023-08-23 00:44:30</p></blockquote><blockquote><p>📌 除了初始化函数，Python还有一个构造函数。你可能永远都不会用到Python的构造函数，但是知道它的存在还是有帮助的 ⏱ 2023-08-29 22:08:36</p></blockquote><blockquote><p>📌 构造函数对元编程的复杂艺术有很多有趣的可能性，但是在日常编程中可能没什么用。在实践过程中，你可能很少用到__new__，大部分情况下__init__就足够用了。 ⏱ 2023-08-29 22:08:42</p></blockquote><h3 id="模块和包" tabindex="-1">模块和包 <a class="header-anchor" href="#模块和包" aria-label="Permalink to &quot;模块和包&quot;">​</a></h3><blockquote><p>📌 不要这样做。每个有经验的Python程序员都会告诉你永远不要用这个语法。他们会给出一些诸如“这样会污染命名空间”之类隐晦的理由，这对初学者来说完全不知所云。 ⏱ 2023-08-29 22:10:58</p></blockquote><blockquote><p>📌 模块中用到的每一个变量名都应该放在合适的位置，不管是在模块中定义的还是从其他模块中导入的。不应该有凭空出现的魔法变量。我们应该总是能够立刻识别出当前命名空间中变量名的来源。我可以向你保证，如果你用了这个邪恶的语法，总有一天你会遇到让你极度抓狂的时刻，“这个类到底是从哪里来的？” ⏱ 2023-08-23 00:46:00</p></blockquote><blockquote><p>📌 我们只需要在目录下添加一个名为__init__.py的文件（通常是空文件）就可以告诉Python这个目录是一个包。如果忘记添加这个文件，我们就没办法从目录导入模块了。 ⏱ 2023-08-29 22:58:28</p></blockquote><blockquote><p>📌 有这么多选择，我们该用那种语法？这取决于你的个人爱好和手头的应用。如果products模块下有数十个我想用的类和函数，我通常会用from ecommerce import products语法来导入模块名，然后通过products.Product的形式访问每个类。如果products模块下只有一两个类是我需要的，那么可以直接用from ecommerce.products import Product语法导入。 ⏱ 2023-08-29 23:21:11</p></blockquote><h3 id="组织模块内容" tabindex="-1">组织模块内容 <a class="header-anchor" href="#组织模块内容" aria-label="Permalink to &quot;组织模块内容&quot;">​</a></h3><blockquote><p>📌 前面这个类的问题在于database对象会在导入模块时立即被创建，通常是在程序启动的时候。这通常并不是最理想的，因为连接数据库可能需要一点时间，这会降低启动速度，或者无法获取数据库连接信息。我们可以推迟创建数据库，直到真正需要的时候通过调用initialize_database函数来创建模块层的变量： ⏱ 2023-08-29 23:26:23</p></blockquote><blockquote><p>📌 global关键字告诉Python initialize_database内部的变量database是我们刚刚在模块层定义的全局变量。 ⏱ 2023-08-29 23:27:13</p></blockquote><blockquote><p>📌 正如以上两个例子所说明的，所有模块层的代码都会在导入的时候立即执行。然而，如果是方法或函数的内部，只会创建这一函数，而内部代码只有在函数被调用时才会执行。 ⏱ 2023-08-29 23:41:18</p></blockquote><blockquote><p>📌 然而，一旦我们导入它，所有在模块层的代码就都会立即执行。如果我们不注意，可能会执行第一个程序里的所有代码，而实际上我们只想要访问其中的几个函数。 ⏱ 2023-08-29 23:42:17</p></blockquote><blockquote><p>📌 每个模块都有一个特殊变量__name__（记住，Python用双下画线标记特殊变量，如类中的__init__方法）存储模块被导入时的名字。 ⏱ 2023-08-29 23:44:47</p></blockquote><blockquote><p>📌 类可以在任何地方定义，通常定义在模块层，但是也可以定义在一个函数或方法的内部 ⏱ 2023-08-30 00:08:59</p></blockquote><blockquote><p>📌 这些内部的类和函数通常用于一次性的对象，不会需要在模块层用到它的作用域，或者只有在一个单独的方法内才是有意义的。然而，在Python的代码中，这一技巧的使用并不多见。 ⏱ 2023-08-30 00:10:17</p></blockquote><h3 id="谁可以访问我的数据" tabindex="-1">谁可以访问我的数据 <a class="header-anchor" href="#谁可以访问我的数据" aria-label="Permalink to &quot;谁可以访问我的数据&quot;">​</a></h3><blockquote><p>📌 大多数面向对象编程语言都有访问权限的概念。这与抽象有关。一些属性和方法可以被标记为私有的，意味着只有对象可以访问它们。另外一些被标记为受保护的，意味着只有该类及其子类可以访问它们。剩下的就是公开的，意味着任何对象都可以访问它们。 Python不是这样做的。Python不相信那些将来会对你造成妨碍的强制性规矩 ⏱ 2023-08-30 00:17:27</p></blockquote><blockquote><p>📌 严格来说，类的所有方法和属性都是对外公开的。如果我们想要说明某个方法不应该公开使用，则可以在它的文档字符串中表明这个方法只用于内部使用（更好的做法是，介绍对外公开的API应该如何使用）。 ⏱ 2023-08-30 00:17:51</p></blockquote><blockquote><p>📌 依据惯例，我们也可以在属性或方法前面加一个下画线字符_的前缀。Python程序员就会明白“这是一个内部变量，直接访问它之前请务必三思”。 ⏱ 2023-08-30 00:18:11</p></blockquote><blockquote><p>📌 还有另外一种方式可以更强势地表明外部对象不能访问某个属性或方法：用双下画线__作为前缀。 ⏱ 2023-08-30 00:18:47</p></blockquote><blockquote><p>📌 所以说，名字改装并不能保证私有性，它只是强烈建议保持私有。大部分Python程序员除非有非常强有力的理由，不然很少会在别的对象中用到双下画线的变量。 ⏱ 2023-08-30 00:19:49</p></blockquote><h3 id="第三方库" tabindex="-1">第三方库 <a class="header-anchor" href="#第三方库" aria-label="Permalink to &quot;第三方库&quot;">​</a></h3><blockquote><p>📌 Python社区的共识是只应该用系统安装器安装第三方库到系统中的Python目录。 ⏱ 2023-08-30 00:24:25</p></blockquote><blockquote><p>📌 Python 3.4提供了一个venv工具。这一工具在你的工作目录下提供给你一个迷你版本的Python，称为虚拟环境(virtual environment)。当你激活这一迷你版本的Python，与Python相关的命令将在当前目录执行，而非系统目录。因此当你执行pip或python，它们根本不会用到系统Python。 ⏱ 2023-08-30 00:24:50</p></blockquote><blockquote><p>📌 通常，你需要为每个Python项目创建一个不同的虚拟环境。你可以将虚拟环境存储在任何位置，但是我通常将它们保存在与项目中其他文件相同的目录中（但是在版本控制工具中要将其忽略），因此我们先cd到项目目录。然后运行venv工具创建一个虚拟环境，名为env。最后，用最后一行命令（根据注释中提示的操作系统选择你需要的）来激活环境。每次当需要用到特定的虚拟环境时，都要执行这一行命令，然后当我们完成这一项目之后，可以用deactivate命令退出。 ⏱ 2023-08-30 00:26:58</p></blockquote><h3 id="练习-1" tabindex="-1">练习 <a class="header-anchor" href="#练习-1" aria-label="Permalink to &quot;练习&quot;">​</a></h3><blockquote><p>📌 但是对于理解面向对象的准则来说，自上而下的工作流程更合适。 ⏱ 2023-08-23 00:47:52</p></blockquote>',66)])])}const i=t(c,[["render",r]]);export{k as __pageData,i as default};
