# 武器动画系统与引擎使用的设计和实现 
为了保持武器系统的可扩展，角色动画和武器动画解耦，使用插槽（Socket）的方案，让武器绑定系统和身体绑定系统分离   

- 如果武器只有刀剑等没动画的静态物体，两种方式区别不大    
- 如果武器有动画，武器骨骼和身体做一体，武器没有扩展性，且和角色动画强耦合    
- 任何静态网格体（Static Mesh）或骨骼网格体（Skeletal Mesh）都可以动态挂载到插槽上。  
> 模拟手臂和武器。两个独立的动画系统     

![alt text](./rig1.gif)   

## 插槽数据同步  
需要Maya武器的挂点输出坐标信息，提供给Unreal中的插槽同步   
json文件保存在工程路径下data文件夹下  
```
import maya.cmds as cmds
import json
import os

# 获取当前选择的物体
selected_objects = cmds.ls(selection=True)

# 检查是否选择了物体
if not selected_objects:
    print("No objects selected. Please select a locator or control object.")
else:
    # 获取选择的第一个物体作为挂点
    socket_name = selected_objects[0]
    
    # 获取物体的本地变换
    try:
        translate = cmds.getAttr(f"{socket_name}.translate")[0]
        rotate = cmds.getAttr(f"{socket_name}.rotate")[0]
    except Exception as e:
        print(f"Error while getting transform data for {socket_name}: {e}")
        exit()

    # 构建数据
    socket_data = {
        "name": socket_name,
        "location": {"x": translate[0], "y": translate[1], "z": translate[2]},
        "rotation": {"x": rotate[0], "y": rotate[1], "z": rotate[2]},
    }

    # 获取 Maya 工程路径
    project_path = cmds.workspace(q=True, rootDirectory=True)

    # 设置导出路径 (工程路径下的 data 文件夹)
    export_folder = os.path.join(project_path, "data")
    if not os.path.exists(export_folder):
        os.makedirs(export_folder)  # 如果文件夹不存在，则创建

    export_path = os.path.join(export_folder, f"{socket_name}_socket_data.json")

    # 导出到 JSON
    with open(export_path, "w") as f:
        json.dump(socket_data, f, indent=4)

    print(f"Socket data exported successfully to {export_path}!")
```
数据示例结果： 
```
{
    "name": "WeaponSocket_Locator",
    "location": {
        "x": 34.87415616288925,
        "y": 97.2246691574479,
        "z": -7.911222900529021
    },
    "rotation": {
        "x": -22.946276037348976,
        "y": 3.8551410351372555,
        "z": -81.16297601679955
    }
}
```
Maya软件UI显示的精度有裁剪。可以看到如果手动对位是不可能精确对上的   

## 武器约束及导出
制作的关键点在于**使用约束**来保持角色与武器动画的一致性，而不是直接将武器作为角色骨骼的子节点。  
通过约束，可以独立管理角色和武器的骨骼层级，制作完成后解除约束，让武器回归原点并导出独立动画。 

- 添加一个二级控制器，用于精确调整武器与手部交互的姿态
- 一级控制器只用来切换约束跟随，专注于父子约束的切换。  

动画完成后：
   1. 解除一级控制器的约束
   2. 武器一级控制器回归世界坐标原点  
   3. 烘焙武器动画
   4. 导出武器动画  

特别要注意，武器一级控制器有没有被KEY上动画，这里是错位发生的关键点  
> 模拟手臂和武器。武器系统在手控制器的约束下进行动画   

![alt text](./rig2.gif)    
如果需要频繁解除约束并将武器回归原点，可以通过 Maya 脚本简化流程：
```
import maya.cmds as cmds

def bake_and_reset_selected():
    controller = cmds.ls(selection=True)
    # 获取与控制器关联的约束节点
    constraint_nodes = cmds.listConnections(controller, type="constraint") or []

    # 删除约束
    for constraint in constraint_nodes:
        if cmds.objExists(constraint):
            cmds.delete(constraint)

    # 重置控制器的位置和旋转到原点
    cmds.setAttr(f"{controller}.translate", 0, 0, 0)
    cmds.setAttr(f"{controller}.rotate", 0, 0, 0)

    # 烘焙动画
    start_frame = cmds.playbackOptions(q=True, min=True)
    end_frame = cmds.playbackOptions(q=True, max=True)
    cmds.bakeResults(controller, t=(start_frame, end_frame))

    print(f"Operation completed for {controller}.")

bake_and_reset_selected()
```
## 武器约束切换
有很多情况，角色不止一个挂载点，会从身上切换   
原则是把切换控制属性做在武器根控制器上，关联身体不同部位的父子约束值的切换，做到切换不同的跟随目标     
通过属性控制父子约束的权重，方便在武器不同的携带状态（例如手持、背挂、腰挂）之间切换。  
在武器根控制器上添加自定义枚举属性（例如 FollowTarget）。
```
import maya.cmds as cmds

selected_objects = cmds.ls(selection=True)

if not selected_objects:
    print("No objects selected. Please select a control object.")
else:
    for obj in selected_objects:
        if not cmds.attributeQuery("FollowTarget", node=obj, exists=True):
            cmds.addAttr(
                obj,
                longName="FollowTarget",
                attributeType="enum",
                enumName="RightHand:LeftHand:Back:Waist",
                keyable=True
            )
            print("Added 'FollowTarget' attribute to {}".format(obj))
        else:
            print("Object {} already has the 'FollowTarget' attribute.".format(obj))
```  
使用 Maya 的 Set Driven Key（SDK） 或脚本将 FollowTarget 属性驱动每个父子约束的权重。  
约束的点的命名需要按工程情况进行修改制定  
```
def switch_follow_target(target):
    follow_targets = {
        "RightHand": [1, 0, 0, 0],
        "LeftHand": [0, 1, 0, 0],
        "Back": [0, 0, 1, 0],
        "Waist": [0, 0, 0, 1]
    }
    weights = follow_targets.get(target, [0, 0, 0, 0])
    cmds.setAttr("Weapon_Root_RightHandConstraint.w0", weights[0])
    cmds.setAttr("Weapon_Root_LeftHandConstraint.w1", weights[1])
    cmds.setAttr("Weapon_Root_BackConstraint.w2", weights[2])
    cmds.setAttr("Weapon_Root_WaistConstraint.w3", weights[3])

switch_follow_target("Back")  # 示例切换到背挂点
```  
需要说明的是：  
即使在 Maya 中切换了不同挂点，最终导入 Unreal 的动画，武器的位置和旋转依然只需要与 初始挂点（Socket） 对齐即可。除非有逻辑上的需要，可以操作其余插槽。    
在 Maya 中切换挂点的约束只是为了方便制作动画。 
## 推荐工作流   
1. Maya 用于初始对齐   
在 Maya 中设置好挂点（Locator 或辅助骨骼）：  
    帮助动画师精确制作交互动画。
    导出初始位置和旋转作为 Unreal 插槽的参考。
2. Unreal 中完善插槽
在 Unreal 中，将 Maya 的挂点转换为插槽：
    通过手动设置插槽位置和旋转，修正可能的偏差。
    为插槽命名，方便蓝图逻辑调用。
在游戏逻辑中利用插槽的动态特性实现高级功能（如武器切换、挂载饰品等）。

## 结论
Maya 中的挂点是制作动画的工具，而 Unreal 的插槽是用于运行时动态管理挂载物体的系统。二者可以很好地结合使用：  
在 Maya 中完成精确的动画制作。  
在 Unreal 中使用插槽实现动态和实时的灵活性。  
这种分工可以最大限度地提升工作流效率和系统灵活性。  

[3dmsx操作](https://www.bilibili.com/video/BV1u14y1z7kG/?spm_id_from=333.337.search-card.all.click&vd_source=9cdd98cc53d87aeb4190d2743832662b)