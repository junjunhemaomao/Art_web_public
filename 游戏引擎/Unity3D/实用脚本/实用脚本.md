# 实用脚本
> 如果没有特别说明，都是针对URP渲染管线
## UI类
#### UI图片的闪烁效果
脚本实现了UI图片的闪烁效果，通过时间参数可以控制时间节奏。挂载在UI的image上
```csharp
using UnityEngine;
using UnityEngine.UI;

public class ShowHide : MonoBehaviour 
{
    // 第二张图片，由用户在Inspector中指定
    public Sprite img2;

    // 切换间隔时间，默认值为 1 秒，可在Inspector中设置
    public float interval = 1f;
    
    private Image uiImage;
    private Sprite img1; // 默认图片 (source image)

    void Start()
    {
        // 获取 Image 组件
        uiImage = GetComponent<Image>();

        // 获取 Image 组件的默认图片
        img1 = uiImage.sprite;
    }

    void Update() 
    {
        // 每隔 interval 秒在两张图片之间切换
        if (Time.time % (interval * 2) < interval)
        {
            uiImage.sprite = img1; // 显示第一张图片（默认图片）
        }
        else
        {
            uiImage.sprite = img2; // 显示第二张图片
        }
    }
}
```
#### UI文字打字机效果
我们使用 JSON 文件来存储文本内容。可以创建一个 JSON 文件（例如 TextData.json）并将其放在 Unity 的 Resources 文件夹中。
```JSON
{
    "texts": [
        "Welcome to the game! Enjoy your adventure.",
        "Once upon a time in a land far away...",
        "This is the final message after user clicks."
    ]
}
```  
步骤:   
1. 添加 TextMeshPro 组件：在 Unity 中，右键点击 Hierarchy 窗口中的空白处，选择 UI > TextMeshPro - Text 来创建一个 TextMeshPro 组件。调整其样式以符合需求。
2. 在场景中创建一个空对象，添加 AudioSource 组件，并将打字机声音拖到 AudioSource 的 AudioClip 插槽中。
3. 将 TypewriterEffect 脚本附加到空对象上，配置 letterPause、textMeshPro。
```csharp
using UnityEngine;
using TMPro;
using System.Collections;

public class TypewriterEffect : MonoBehaviour
{
    public float letterPause = 0.05f; // 每个字出现的时间间隔
    public TextMeshProUGUI textMeshPro; // 使用 TextMeshPro 显示文本

    private AudioSource audioSource; // 用于播放声音的 AudioSource
    private string[] texts; // 从 JSON 文件中读取的文本数组
    private int currentTextIndex = 0; // 当前显示的文本索引

    void Start()
    {
        // 获取 AudioSource 组件
        audioSource = GetComponent<AudioSource>();

        // 加载 JSON 文件并读取文本内容
        LoadTextData();

        // 初始化文本为空
        textMeshPro.text = "";

        // 显示第一个文本
        StartCoroutine(TypeText(texts[currentTextIndex], true));
    }

    void LoadTextData()
    {
        // 从 Resources 文件夹加载 JSON 文件
        TextAsset jsonData = Resources.Load<TextAsset>("TextData");
        if (jsonData != null)
        {
            // 解析 JSON 数据
            TextData data = JsonUtility.FromJson<TextData>(jsonData.text);
            texts = data.texts; // 获取文本数组
        }
        else
        {
            Debug.LogError("TextData.json file not found in Resources folder.");
        }
    }

    IEnumerator TypeText(string text, bool waitForClick)
    {
        foreach (char letter in text.ToCharArray())
        {
            textMeshPro.text += letter;

            // 播放声音（如果 AudioSource 组件存在）
            if (audioSource)
            {
                audioSource.Play(); // 播放配置好的音效
            }

            // 等待每个字符的时间间隔
            yield return new WaitForSeconds(letterPause);
        }

        // 如果需要等待用户点击，设置标志位
        if (waitForClick)
        {
            yield return new WaitUntil(() => Input.GetMouseButtonDown(0)); // 等待鼠标左键点击

            // 清空当前文本并显示下一个文本
            textMeshPro.text = "";
            currentTextIndex++;
            if (currentTextIndex < texts.Length)
            {
                StartCoroutine(TypeText(texts[currentTextIndex], currentTextIndex < texts.Length - 1));
            }
        }
    }
}

[System.Serializable]
public class TextData
{
    public string[] texts; // 文本数组
}
```

## 场景类
#### 面片正面始终朝向摄像机
```csharp
using UnityEngine;

public class CameraFacingBillboard : MonoBehaviour
{
    public Camera cameraToLookAt;

    // 记录初始面片的本地旋转
    private Quaternion initialRotation;

    void Start()
    {
        // 如果没有手动指定摄像机，则默认使用主摄像机
        if (cameraToLookAt == null)
        {
            cameraToLookAt = Camera.main;
        }

        // 获取面片的初始旋转
        initialRotation = transform.rotation;
    }

    void Update()
    {
        // 获取摄像机与面片的相对方向
        Vector3 direction = transform.position - cameraToLookAt.transform.position;

        // 只让面片在水平面上旋转（忽略 Y 轴的影响）
        direction.y = 0f;

        // 创建一个旋转，让物体的正面朝向摄像机
        Quaternion lookRotation = Quaternion.LookRotation(direction);

        // 保持面片的初始旋转，并叠加新的朝向
        transform.rotation = lookRotation * Quaternion.Inverse(initialRotation);
    }
}
```
## 特效
#### UV序列动画
在模型片上移动UV，实现UV动画   
要确认所使用的材质有Offset参数，不然偏移动画不能实现
```csharp
using UnityEngine;

public class UVScrollAnimation : MonoBehaviour
{
    public float scrollSpeed = 5f; // 控制动画的速度
    public int countX = 4;         // 横向的帧数
    public int countY = 4;         // 纵向的帧数

    private Vector2 singleTexSize; // 单帧的贴图尺寸
    private Renderer rend;         // 渲染器组件

    void Start()
    {
        // 获取当前物体的渲染器组件
        rend = GetComponent<Renderer>();
        // 计算每帧的贴图大小
        singleTexSize = new Vector2(1.0f / countX, 1.0f / countY);
        // 设置材质的纹理缩放
        rend.material.mainTextureScale = singleTexSize;
    }

    void Update()
    {
        // 计算当前的帧
        int totalFrames = countX * countY; // 总帧数
        int frame = Mathf.FloorToInt(Time.time * scrollSpeed) % totalFrames;

        // 计算当前帧的横纵坐标
        int xIndex = frame % countX;
        int yIndex = countY - 1 - (frame / countX);

        // 计算纹理的偏移量
        Vector2 offset = new Vector2(xIndex * singleTexSize.x, yIndex * singleTexSize.y);
        // 应用偏移到材质的纹理
        rend.material.SetTextureOffset("_MainTex", offset);
    }
}
```
## 材质贴图
#### 在模型上变换贴图
将脚本拖到物体上，在脚本的 Inspector 面板中设置 frames 数组的大小，并将贴图拖到数组中。  
设置 framesPerSecond 为希望的动画速度。  
可以利用贴图帧，来模拟水流，岩浆等，既保留了贴图精度，也不用处理贴图合并。而且可以解决图集是奇数的问题。
```csharp
using UnityEngine;

public class TextureAnimation : MonoBehaviour
{
    public Texture[] frames; // 存放贴图的数组
    public int framesPerSecond = 10; // 每秒播放的帧数

    private Renderer rend; // 渲染器组件

    void Start()
    {
        // 获取当前物体的渲染器组件
        rend = GetComponent<Renderer>();
    }

    void Update()
    {
        // 计算当前帧的索引
        int index = Mathf.FloorToInt(Time.time * framesPerSecond) % frames.Length;
        // 将当前帧的贴图应用到材质上
        rend.material.mainTexture = frames[index];
    }
}
```
#### 模型材质渐隐
```CSHARP
using UnityEngine;

[RequireComponent(typeof(Renderer))]
public class ColorFader : MonoBehaviour
{
    public float fadeDuration = 0.2f; // 透明度变化的时间
    private float alphaValue = 1f;
    private float time = 0f;
    private bool fading = false;
    private Renderer objectRenderer;
    private MaterialPropertyBlock materialPropertyBlock;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();
        materialPropertyBlock = new MaterialPropertyBlock();

        if (objectRenderer != null)
        {
            var material = objectRenderer.material;
            // 确保材质的 Shader 支持透明度
            if (material.HasProperty("_BaseColor"))
            {
                material.SetFloat("_Surface", 1); // 1 表示透明
                material.SetFloat("_Blend", 0);   // 0 表示 Alpha
            }
        }
    }

    void Update()
    {
        if (objectRenderer == null)
        {
            return;
        }

        time += Time.deltaTime;

        if (time >= fadeDuration)
        {
            fading = true;
            time = 0f;
        }

        if (fading)
        {
            alphaValue -= 0.1f;
            if (alphaValue <= 0f)
            {
                alphaValue = 1f;
            }
            fading = false;
        }

        // 更新颜色
        objectRenderer.GetPropertyBlock(materialPropertyBlock);
        Color color = materialPropertyBlock.GetColor("_BaseColor");
        color.a = alphaValue;
        materialPropertyBlock.SetColor("_BaseColor", color);
        objectRenderer.SetPropertyBlock(materialPropertyBlock);

        Debug.Log(alphaValue);
    }
}
```
#### 缓慢改变物体颜色 
```CSHARP
function Update() {
renderer.material.color = Color.Lerp(Color.white, Color.red, Time.time);
}
```
在C#中，协同程序的使用语法与JavaScript不同。
协同程序必须返回一个IEnumerator类型，并且使用yieldreturn...    
永远不要使用构造器来初始化值，而应该在Awake或Start中进行，单例模式（SingletonPattern）对象使用构造器进行初始化时，可能会导致值为空的严重后果。因此，应该在Awake方法中来初始化单例模式对象。请记住：任何继承至MonoBehaviour的类中，都不能包含使用构造器的代码。