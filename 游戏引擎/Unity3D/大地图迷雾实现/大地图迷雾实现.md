
# 大地图迷雾实现思路
![alt text](./image.png)
## 1.基础效果
迷雾的表现，一般可以是雾、云、烟之类的，它的特性和水有一些相似，这里我做的是云，首先肯定要动起来，我用了和常规的水相同的做法——采样一张颜色贴图两次，做uv的反向流动，两张贴图的tilling值设置不同，uv流速不同，可以有一些变化。
```
    float4 BlendTwocloud(float2 uv)
    {
        float4 c=tex2D( cloudTex, uv* TillingFactor + Time.x*CloudSpeed.xy); 
        float3 c2=tex2D( cloudTex, uv + Time.x*cloudSpeed.zw); 
        c.rgb=(c.rgb + c2)/ 2; 
        return c; 
    }
    mask的贴图精度会影响云边缘的效果，但我们不能因为想要边缘清晰就随意扩大贴图，所以用一个简单的计算来调整。
    float clampAndPowValue(float val,float3 minMaxPow)
    {
        float mValue;mValue = saturate((val-minMaxPow.x)/(minMaxPow.y- minMaxPow.x));
        mValue = saturate(pow(mValue, minMaxPow.z));
        return mValue;
    } 
```
现在边缘看着很死板，我们需要处理一下，思路为扰动mask的uv。为了节省贴图，我把上面采样了两次的颜色帖图去色作为扰动噪声，与mask的uv做加法。因为加法会导致mask偏移，所以我加了两个变量去修正位置。
``` 
    //offset 处理边缘
    float gray =(c.r+c.g+c.b)/ 3;
    float2 disoffset=float2(gray-Shade0ffset.x,gray -Shadeoffset.y)Shadeoffset.z *0.01;
    //mask
    float4 mask = tex2D( MainTex, maskUV + disoffset);
    //mask r
    mask.r=clampAndPowValue(mask.r,MaskRValues.xyz);
```
现在看着像一张薄薄的纸，少了点厚重感，我们需要给云加上投影。额外加一个pass渲染即可。 
```
    Pass
    {
        Name "cloudshadow"
        CGPROGRAM
        #pragma vertex vertShadow
        #pragma fragment fragShadow
        ENDCG
    }
    Pass
    {
        Name "cloudColor"
        CGPROGRAM
        #pragma vertex vertCloud
        #pragma fragment fragcloud
        ENDCG
    }
```
需要注意的是投影pass必须写在正常pass前面，不然投影会盖住整体。 
## 2.选中效果
我们首先要获取到选中区域，这里我们用上面采样的mask的G通道来标记。然后我给选中写了个简单的闪烁效果。 
```
    float flicker = lerp(1,sin( Time.y*FlickSpeed),FlickIntensity);
    c.rgb += c.rgb * flicker * mask.g* _FlickLevel;
```
## 3.溶解效果
采样一张溶解贴图，然后用mask的B通道作为溶解值去计算。
```
    float DissolveMaskR(float3 mask, float2 dissolveUV)
    {
        float dissolve =tex2D( DissolveTex,dissolveUV).r;
        float maskR = lerp(mask.r * smoothstep(8, saturate(dissolve + mask.b)+ 0.01, mask.b), mask.r, mask.b);
        return maskR;
    }
```
## 4.逻辑思路
从以上的效果中，我们不难看出，mask占了很大的比重，而且与程序的桥接中，也主要是处理mask，它就是效果与数据之间的桥梁。一般在项目中，mask会由程序动态创建，程序从策划那里得到地图规模(N * N)，然后创建贴图，SetPixel，保存数据。这里和数据有关的只有R通道，因为从数据的角度来看，我们只需要得到迷雾那里解锁，哪里未解锁。至于选中和溶解，都是表现层的东西。

```
    ///<summary>
    ///初始化数据并填色
    ///</summary>
    2 个引用
    public void InitDataAndColor()
    {
        GlobalVariable.CreateJson();
        CleanDataList(GlobalVariable.curMaskRList);
        for(int j=0:j< cloudData.height; j++)
        {
            for(int i=0;i< cloudData.width; i++)
            {
                //cloudData.maskRList.Add(1): //读行初始化数据
                GlobalVariable.curMaskRList.Add(1);//初始化临时列表数据
                GlobalVariable.maskTex.SetPixel(i,j, new Color(1,0,1,1)); //初始化填色
                //Debug.Log(i +" "+ j);
            }

        }
        GlobalVariable.ApplyColorToTex(cloudRender);
        GlobalVariable.WriteJson(); //写json
    }
```  
当我们点击某块迷雾解锁时，这一瞬间数据中的这块迷雾就已经是解锁状态，以保证假如玩家点击了解锁后，因为某些原因中断了游戏，再次进入时，这块被他解锁过的迷雾是正确的状态。而不能让溶解效果的滞后影响到实际解锁结果。
当已有数据，就要优先读取数据，根据数据来创建mask。
```
///<summary>
/// 根据数据填色
///</summary>
private void InitColorFromData()
{
    pixelX = 0;
    pixelY = 0;
    rowCount =1;

    for (int i=0;i< GlobalVariable.curMaskRList.Count; i++)
    {
        //根据数据id计算行列
        if(i>cloudData.width *rowCount -1)
        {
            rowCount += 1;
            pixelY += 1;
            pixelX= 0;
        }
        Globalvariable. maskrex. SetPixel(pixelx, pixely, new Color(Globalvariable. curaskRlist[i], 0,Globalvariable. curaskRlist[i], 1); //用数据填色
        //Debug.Log(pixelX +" " + pixelY);
        pixelX  += 1;
    }
    GlobalVariable. ApplyColorToTex(cloudRender);
}
```
在做溶解时，用到了单例计时器的思路，点击解锁时，创建计时器，以保证某块正在解锁时，玩家在点击了下一块，它们之间不会互相影响。关于计时器，网上已有很多教程，这里就不赘述了。  
关于格子点击，我用了射线检测，获取格子坐标的方式也比较简单，这里写了两种方式：向下取整和四舍五入，前者格子的左下角与unity单位格锚点对齐，后者格子中心与unity格子锚点对齐。
```
    //射线检测
    clickRay = Camera.main.ScreenPointToRay(Input.mousePosition);
    if (Physics. Raycast (clickRay, out clickHit, float. PositiveInfinity, LayerMask. GetMask("collider")))
    {
        Debug.Log(clickHit.transform.name);
        curTilePos = GetTilePos(clickHit.point);
        //选中框位置赋值并显示
        selectObj.position =new Vector3(curTilePos.x,0, curTilePos.y);



    //<summary>
    ///获取点击块的坐标
    </sumary>
    ///<param name-"clickHitPos"></param>
    ///<returns></returns>
    2 个引用
    private Vector2GetTilePos(Vector3 clickHitPos)
    {
        switch (pivotType)
        {
            case PivotType. BottomLeft:
            return new Vector2 (Mathf.Floor(clickHitPos.x), Mathf.Floor(clickHitPos.z)); //格子坐标向下取整
            case PivotType.Center:
            return new Vector2 (Mathf. Round(clickHitPos.x), Mathf. Round(clickHitPos.z)); //格子坐标四舍五入
            default :
            return new Vector2 (Mathf. Floor(clickHitPos.x), Mathf.Floor(clickHitPos.z)); //格子坐标向下取整
        }
    }
```
以上是基本的思路框架，感谢观看。实际制作中更多的是美术和程序的配合与联调，才能使效果一步步变得更好。

[unity实现的SLG地图迷雾效果](https://www.bilibili.com/video/BV18Q4y1771Z/?spm_id_from=333.337.search-card.all.click&vd_source=9cdd98cc53d87aeb4190d2743832662b)  
***
## GPT 总结
在这种迷雾效果的实现中，C# 代码和 Shader 是需要结合使用的，而无法全部在 Shader 内完成。原因如下：

Shader 主要负责视觉效果：包括云的动态渲染、边缘处理、投影、选中、溶解等特效。这些处理是实时的、基于 GPU 的，适合放在 Shader 中。
C# 负责数据逻辑和状态管理：例如迷雾解锁状态、贴图的动态生成与更新、点击事件处理。这些涉及到游戏逻辑层面的操作，适合在 C# 中实现。
```csharp
using UnityEngine;

public class FogOfWarController : MonoBehaviour
{
    public Texture2D maskTex; // 迷雾贴图
    public Material fogMaterial; // 云的材质
    public int mapWidth = 100;
    public int mapHeight = 100;

    private void Start()
    {
        InitDataAndColor();
    }

    public void InitDataAndColor()
    {
        maskTex = new Texture2D(mapWidth, mapHeight);
        for (int y = 0; y < mapHeight; y++)
        {
            for (int x = 0; x < mapWidth; x++)
            {
                maskTex.SetPixel(x, y, new Color(1, 0, 1, 1)); // 初始化为不可见区域
            }
        }
        maskTex.Apply();
        fogMaterial.SetTexture("_MaskTex", maskTex); // 传递贴图给Shader
    }

    private void Update()
    {
        if (Input.GetMouseButtonDown(0)) // 检测点击事件
        {
            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            if (Physics.Raycast(ray, out RaycastHit hit))
            {
                Vector2 tilePos = GetTilePos(hit.point);
                UnlockTile((int)tilePos.x, (int)tilePos.y);
            }
        }
    }

    private Vector2 GetTilePos(Vector3 hitPoint)
    {
        return new Vector2(Mathf.Floor(hitPoint.x), Mathf.Floor(hitPoint.z));
    }

    private void UnlockTile(int x, int y)
    {
        maskTex.SetPixel(x, y, new Color(0, 0, 0, 1)); // 解锁点击的区域
        maskTex.Apply(); // 更新贴图
    }
}
```
2. Shader 代码
```
Shader "Custom/FogOfWar"
{
    Properties
    {
        _MainTex ("Main Texture", 2D) = "white" {}
        _MaskTex ("Mask Texture", 2D) = "white" {}
        _CloudSpeed ("Cloud Speed", Vector) = (0.1, 0.1, 0.2, 0.2)
        _TillingFactor ("Tilling Factor", float) = 1.0
        _FlickSpeed ("Flicker Speed", float) = 1.0
        _FlickIntensity ("Flicker Intensity", float) = 1.0
        _FlickLevel ("Flicker Level", float) = 0.5
    }

    SubShader
    {
        Tags { "RenderType" = "Opaque" }
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"

            sampler2D _MainTex;
            sampler2D _MaskTex;
            float4 _CloudSpeed;
            float _TillingFactor;
            float _FlickSpeed;
            float _FlickIntensity;
            float _FlickLevel;

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 pos : SV_POSITION;
            };

            v2f vert (appdata v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.uv = v.uv;
                return o;
            }

            float4 BlendTwocloud(float2 uv)
            {
                float4 c = tex2D(_MainTex, uv * _TillingFactor + _Time.x * _CloudSpeed.xy);
                float4 c2 = tex2D(_MainTex, uv + _Time.x * _CloudSpeed.zw);
                return (c + c2) / 2;
            }

            float clampAndPowValue(float val, float3 minMaxPow)
            {
                float mValue = saturate((val - minMaxPow.x) / (minMaxPow.y - minMaxPow.x));
                return saturate(pow(mValue, minMaxPow.z));
            }

            float4 frag (v2f i) : SV_Target
            {
                float4 cloudColor = BlendTwocloud(i.uv);
                float4 mask = tex2D(_MaskTex, i.uv);

                // Flicker effect based on mask
                float flicker = lerp(1, sin(_Time.y * _FlickSpeed), _FlickIntensity);
                cloudColor.rgb += cloudColor.rgb * flicker * mask.g * _FlickLevel;

                // Combine cloud and mask
                cloudColor.a *= mask.r;
                return cloudColor;
            }
            ENDCG
        }
    }
}
```
## 工作原理：  

C# 部分：  
初始化并填充迷雾状态的 mask 贴图。
在点击时解锁某个区域（通过 SetPixel 修改 mask 数据），并将更新后的数据传递给 Shader。  

Shader 部分：  
实现动态云效果，通过两次采样云的贴图进行混合。
根据 C# 传入的 mask 贴图来处理迷雾的遮盖、选中闪烁等效果。
通过片段着色器（frag 函数）将云与 mask 贴图结合显示。

FogOfWarController 通常会挂载在场景中的一个管理对象上，比如一个空的 GameObject，来控制迷雾的状态和解锁行为。这个控制器主要处理地图上的迷雾数据、与玩家的交互（如点击解锁区域）以及更新迷雾贴图的内容。

FogOfWarController 和云（Fog of War）的关系：  
C# 负责逻辑：FogOfWarController 管理迷雾的解锁状态和更新。  
Shader 负责视觉：负责渲染迷雾（云的效果），动态显示解锁的区域。   

C# 通过更新 mask 贴图（在 FogOfWarController 中完成），Shader 通过这张贴图控制云层的显示和遮罩，实现视觉上的迷雾效果。